#include "ns3module.h"
static PyMethodDef internet_FatalImpl_functions[] = {
    {NULL, NULL, 0, NULL}
};

static PyObject *
initinternet_FatalImpl(void)
{
    PyObject *m;
    m = Py_InitModule3((char *) "internet.FatalImpl", internet_FatalImpl_functions, NULL);
    if (m == NULL) {
        return NULL;
    }
    return m;
}
static PyMethodDef internet_functions[] = {
    {NULL, NULL, 0, NULL}
};
/* --- classes --- */


PyTypeObject *_PyNs3Address_Type;
std::map<void*, PyObject*> *_PyNs3Address_wrapper_registry;


PyTypeObject *_PyNs3AsciiTraceHelper_Type;
std::map<void*, PyObject*> *_PyNs3AsciiTraceHelper_wrapper_registry;


PyTypeObject *_PyNs3AsciiTraceHelperForDevice_Type;
std::map<void*, PyObject*> *_PyNs3AsciiTraceHelperForDevice_wrapper_registry;


PyTypeObject *_PyNs3AttributeConstructionList_Type;
std::map<void*, PyObject*> *_PyNs3AttributeConstructionList_wrapper_registry;


PyTypeObject *_PyNs3AttributeConstructionListItem_Type;
std::map<void*, PyObject*> *_PyNs3AttributeConstructionListItem_wrapper_registry;


PyTypeObject *_PyNs3Buffer_Type;
std::map<void*, PyObject*> *_PyNs3Buffer_wrapper_registry;


PyTypeObject *_PyNs3BufferIterator_Type;
std::map<void*, PyObject*> *_PyNs3BufferIterator_wrapper_registry;


PyTypeObject *_PyNs3ByteTagIterator_Type;
std::map<void*, PyObject*> *_PyNs3ByteTagIterator_wrapper_registry;


PyTypeObject *_PyNs3ByteTagIteratorItem_Type;
std::map<void*, PyObject*> *_PyNs3ByteTagIteratorItem_wrapper_registry;


PyTypeObject *_PyNs3ByteTagList_Type;
std::map<void*, PyObject*> *_PyNs3ByteTagList_wrapper_registry;


PyTypeObject *_PyNs3ByteTagListIterator_Type;
std::map<void*, PyObject*> *_PyNs3ByteTagListIterator_wrapper_registry;


PyTypeObject *_PyNs3ByteTagListIteratorItem_Type;
std::map<void*, PyObject*> *_PyNs3ByteTagListIteratorItem_wrapper_registry;


PyTypeObject *_PyNs3CallbackBase_Type;
std::map<void*, PyObject*> *_PyNs3CallbackBase_wrapper_registry;


PyTypeObject *_PyNs3EventId_Type;
std::map<void*, PyObject*> *_PyNs3EventId_wrapper_registry;


PyTypeObject *_PyNs3IntToType__0_Type;
std::map<void*, PyObject*> *_PyNs3IntToType__0_wrapper_registry;


PyTypeObject *_PyNs3IntToType__1_Type;
std::map<void*, PyObject*> *_PyNs3IntToType__1_wrapper_registry;


PyTypeObject *_PyNs3IntToType__2_Type;
std::map<void*, PyObject*> *_PyNs3IntToType__2_wrapper_registry;


PyTypeObject *_PyNs3IntToType__3_Type;
std::map<void*, PyObject*> *_PyNs3IntToType__3_wrapper_registry;


PyTypeObject *_PyNs3IntToType__4_Type;
std::map<void*, PyObject*> *_PyNs3IntToType__4_wrapper_registry;


PyTypeObject *_PyNs3IntToType__5_Type;
std::map<void*, PyObject*> *_PyNs3IntToType__5_wrapper_registry;


PyTypeObject *_PyNs3IntToType__6_Type;
std::map<void*, PyObject*> *_PyNs3IntToType__6_wrapper_registry;


PyTypeObject *_PyNs3Ipv4Address_Type;
std::map<void*, PyObject*> *_PyNs3Ipv4Address_wrapper_registry;


PyTypeObject *_PyNs3Ipv4Mask_Type;
std::map<void*, PyObject*> *_PyNs3Ipv4Mask_wrapper_registry;


PyTypeObject *_PyNs3Ipv6Address_Type;
std::map<void*, PyObject*> *_PyNs3Ipv6Address_wrapper_registry;


PyTypeObject *_PyNs3Ipv6Prefix_Type;
std::map<void*, PyObject*> *_PyNs3Ipv6Prefix_wrapper_registry;


PyTypeObject *_PyNs3Mac48Address_Type;
std::map<void*, PyObject*> *_PyNs3Mac48Address_wrapper_registry;


PyTypeObject *_PyNs3NetDeviceContainer_Type;
std::map<void*, PyObject*> *_PyNs3NetDeviceContainer_wrapper_registry;


PyTypeObject *_PyNs3NodeContainer_Type;
std::map<void*, PyObject*> *_PyNs3NodeContainer_wrapper_registry;


PyTypeObject *_PyNs3ObjectBase_Type;
std::map<void*, PyObject*> *_PyNs3ObjectBase_wrapper_registry;


PyTypeObject *_PyNs3ObjectDeleter_Type;
std::map<void*, PyObject*> *_PyNs3ObjectDeleter_wrapper_registry;


PyTypeObject *_PyNs3ObjectFactory_Type;
std::map<void*, PyObject*> *_PyNs3ObjectFactory_wrapper_registry;


PyTypeObject *_PyNs3PacketMetadata_Type;
std::map<void*, PyObject*> *_PyNs3PacketMetadata_wrapper_registry;


PyTypeObject *_PyNs3PacketMetadataItem_Type;
std::map<void*, PyObject*> *_PyNs3PacketMetadataItem_wrapper_registry;


PyTypeObject *_PyNs3PacketMetadataItemIterator_Type;
std::map<void*, PyObject*> *_PyNs3PacketMetadataItemIterator_wrapper_registry;


PyTypeObject *_PyNs3PacketTagIterator_Type;
std::map<void*, PyObject*> *_PyNs3PacketTagIterator_wrapper_registry;


PyTypeObject *_PyNs3PacketTagIteratorItem_Type;
std::map<void*, PyObject*> *_PyNs3PacketTagIteratorItem_wrapper_registry;


PyTypeObject *_PyNs3PacketTagList_Type;
std::map<void*, PyObject*> *_PyNs3PacketTagList_wrapper_registry;


PyTypeObject *_PyNs3PacketTagListTagData_Type;
std::map<void*, PyObject*> *_PyNs3PacketTagListTagData_wrapper_registry;


PyTypeObject *_PyNs3PcapFile_Type;
std::map<void*, PyObject*> *_PyNs3PcapFile_wrapper_registry;


PyTypeObject *_PyNs3PcapHelper_Type;
std::map<void*, PyObject*> *_PyNs3PcapHelper_wrapper_registry;


PyTypeObject *_PyNs3PcapHelperForDevice_Type;
std::map<void*, PyObject*> *_PyNs3PcapHelperForDevice_wrapper_registry;


PyTypeObject *_PyNs3SequenceNumber32_Type;
std::map<void*, PyObject*> *_PyNs3SequenceNumber32_wrapper_registry;


PyTypeObject *_PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map;


PyTypeObject *_PyNs3Simulator_Type;
std::map<void*, PyObject*> *_PyNs3Simulator_wrapper_registry;


PyTypeObject *_PyNs3Tag_Type;


PyTypeObject *_PyNs3TagBuffer_Type;
std::map<void*, PyObject*> *_PyNs3TagBuffer_wrapper_registry;


PyTypeObject *_PyNs3Timer_Type;
std::map<void*, PyObject*> *_PyNs3Timer_wrapper_registry;


PyTypeObject *_PyNs3TimerImpl_Type;
std::map<void*, PyObject*> *_PyNs3TimerImpl_wrapper_registry;


PyTypeObject *_PyNs3TypeId_Type;
std::map<void*, PyObject*> *_PyNs3TypeId_wrapper_registry;


PyTypeObject *_PyNs3TypeIdAttributeInformation_Type;
std::map<void*, PyObject*> *_PyNs3TypeIdAttributeInformation_wrapper_registry;


PyTypeObject *_PyNs3TypeIdTraceSourceInformation_Type;
std::map<void*, PyObject*> *_PyNs3TypeIdTraceSourceInformation_wrapper_registry;


PyTypeObject *_PyNs3Empty_Type;
std::map<void*, PyObject*> *_PyNs3Empty_wrapper_registry;


PyTypeObject *_PyNs3Int64x64_t_Type;
std::map<void*, PyObject*> *_PyNs3Int64x64_t_wrapper_registry;


PyTypeObject *_PyNs3Chunk_Type;


PyTypeObject *_PyNs3Header_Type;


PyTypeObject *_PyNs3Object_Type;


PyTypeObject *_PyNs3ObjectAggregateIterator_Type;
std::map<void*, PyObject*> *_PyNs3ObjectAggregateIterator_wrapper_registry;


PyTypeObject *_PyNs3PcapFileWrapper_Type;


PyTypeObject *_PyNs3RandomVariableStream_Type;


PyTypeObject *_PyNs3SequentialRandomVariable_Type;


PyTypeObject *_PyNs3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt____typeid_map;


PyTypeObject *_PyNs3Socket_Type;


PyTypeObject *_PyNs3SocketAddressTag_Type;


PyTypeObject *_PyNs3SocketFactory_Type;


PyTypeObject *_PyNs3SocketIpTtlTag_Type;


PyTypeObject *_PyNs3SocketSetDontFragmentTag_Type;


PyTypeObject *_PyNs3Time_Type;
std::map<void*, PyObject*> *_PyNs3Time_wrapper_registry;


PyTypeObject *_PyNs3TraceSourceAccessor_Type;


PyTypeObject *_PyNs3Trailer_Type;


PyTypeObject *_PyNs3TriangularRandomVariable_Type;


PyTypeObject *_PyNs3UniformRandomVariable_Type;


PyTypeObject *_PyNs3WeibullRandomVariable_Type;


PyTypeObject *_PyNs3ZetaRandomVariable_Type;


PyTypeObject *_PyNs3ZipfRandomVariable_Type;


PyTypeObject *_PyNs3AttributeAccessor_Type;


PyTypeObject *_PyNs3AttributeChecker_Type;


PyTypeObject *_PyNs3AttributeValue_Type;


PyTypeObject *_PyNs3CallbackChecker_Type;


PyTypeObject *_PyNs3CallbackImplBase_Type;


PyTypeObject *_PyNs3CallbackValue_Type;


PyTypeObject *_PyNs3Channel_Type;


PyTypeObject *_PyNs3ConstantRandomVariable_Type;


PyTypeObject *_PyNs3DeterministicRandomVariable_Type;


PyTypeObject *_PyNs3EmpiricalRandomVariable_Type;


PyTypeObject *_PyNs3EmptyAttributeValue_Type;


PyTypeObject *_PyNs3ErlangRandomVariable_Type;


PyTypeObject *_PyNs3EventImpl_Type;


PyTypeObject *_PyNs3ExponentialRandomVariable_Type;


PyTypeObject *_PyNs3GammaRandomVariable_Type;


PyTypeObject *_PyNs3Ipv4AddressChecker_Type;


PyTypeObject *_PyNs3Ipv4AddressValue_Type;


PyTypeObject *_PyNs3Ipv4MaskChecker_Type;


PyTypeObject *_PyNs3Ipv4MaskValue_Type;


PyTypeObject *_PyNs3Ipv6AddressChecker_Type;


PyTypeObject *_PyNs3Ipv6AddressValue_Type;


PyTypeObject *_PyNs3Ipv6PrefixChecker_Type;


PyTypeObject *_PyNs3Ipv6PrefixValue_Type;


PyTypeObject *_PyNs3LogNormalRandomVariable_Type;


PyTypeObject *_PyNs3Mac48AddressChecker_Type;


PyTypeObject *_PyNs3Mac48AddressValue_Type;


PyTypeObject *_PyNs3NetDevice_Type;


PyTypeObject *_PyNs3NixVector_Type;


PyTypeObject *_PyNs3Node_Type;


PyTypeObject *_PyNs3NormalRandomVariable_Type;


PyTypeObject *_PyNs3ObjectFactoryChecker_Type;


PyTypeObject *_PyNs3ObjectFactoryValue_Type;


PyTypeObject *_PyNs3OutputStreamWrapper_Type;


PyTypeObject *_PyNs3Packet_Type;


PyTypeObject *_PyNs3ParetoRandomVariable_Type;


PyTypeObject *_PyNs3TimeChecker_Type;


PyTypeObject *_PyNs3TimeValue_Type;


PyTypeObject *_PyNs3TypeIdChecker_Type;


PyTypeObject *_PyNs3TypeIdValue_Type;


PyTypeObject *_PyNs3AddressChecker_Type;


PyTypeObject *_PyNs3AddressValue_Type;


PyTypeObject *_PyNs3BridgeChannel_Type;


PyTypeObject *_PyNs3BridgeNetDevice_Type;


std::map<void*, PyObject*> PyNs3AsciiTraceHelperForIpv4_wrapper_registry;

void
PyNs3AsciiTraceHelperForIpv4__PythonHelper::EnableAsciiIpv4Internal(ns3::Ptr< ns3::OutputStreamWrapper > stream, std::string prefix, ns3::Ptr< ns3::Ipv4 > ipv4, uint32_t interface, bool explicitFilename)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AsciiTraceHelperForIpv4 *self_obj_before;
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *py_OutputStreamWrapper;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    const char *prefix_ptr;
    Py_ssize_t prefix_len;
    PyNs3Ipv4 *py_Ipv4;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter2;
    PyTypeObject *wrapper_type2 = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "EnableAsciiIpv4Internal"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3AsciiTraceHelperForIpv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AsciiTraceHelperForIpv4* >(m_pyself)->obj = (ns3::AsciiTraceHelperForIpv4*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_OutputStreamWrapper = NULL;
    } else {
        py_OutputStreamWrapper = (PyNs3OutputStreamWrapper *) wrapper_lookup_iter->second;
        Py_INCREF(py_OutputStreamWrapper);
    }
    
    if (py_OutputStreamWrapper == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream))), &PyNs3OutputStreamWrapper_Type);
        py_OutputStreamWrapper = PyObject_New(PyNs3OutputStreamWrapper, wrapper_type);
        py_OutputStreamWrapper->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream))->Ref();
        py_OutputStreamWrapper->obj = const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream));
        PyNs3Empty_wrapper_registry[(void *) py_OutputStreamWrapper->obj] = (PyObject *) py_OutputStreamWrapper;
    }
    prefix_ptr = (prefix).c_str();
    prefix_len = (prefix).size();
    if (typeid(*(const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4)))).name() == typeid(PyNs3Ipv4__PythonHelper).name())
    {
        py_Ipv4 = (PyNs3Ipv4*) (((PyNs3Ipv4__PythonHelper*) const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4)))->m_pyself);
        py_Ipv4->obj = const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4));
        Py_INCREF(py_Ipv4);
    } else {
        wrapper_lookup_iter2 = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4)));
        if (wrapper_lookup_iter2 == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Ipv4 = NULL;
        } else {
            py_Ipv4 = (PyNs3Ipv4 *) wrapper_lookup_iter2->second;
            Py_INCREF(py_Ipv4);
        }
    
        if (py_Ipv4 == NULL)
        {
            wrapper_type2 = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4))), &PyNs3Ipv4_Type);
            py_Ipv4 = PyObject_GC_New(PyNs3Ipv4, wrapper_type2);
            py_Ipv4->inst_dict = NULL;
            py_Ipv4->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4))->Ref();
            py_Ipv4->obj = const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4->obj] = (PyObject *) py_Ipv4;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "EnableAsciiIpv4Internal", (char *) "Ns#NNN", py_OutputStreamWrapper, prefix_ptr, prefix_len, py_Ipv4, PyLong_FromUnsignedLong(interface), PyBool_FromLong(explicitFilename));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AsciiTraceHelperForIpv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AsciiTraceHelperForIpv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AsciiTraceHelperForIpv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3AsciiTraceHelperForIpv4__tp_init__0(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3AsciiTraceHelperForIpv4 *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3AsciiTraceHelperForIpv4_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3AsciiTraceHelperForIpv4_Type)
    {
        self->obj = new PyNs3AsciiTraceHelperForIpv4__PythonHelper(*((PyNs3AsciiTraceHelperForIpv4 *) arg0)->obj);
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3AsciiTraceHelperForIpv4__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'AsciiTraceHelperForIpv4' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3AsciiTraceHelperForIpv4__tp_init__1(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3AsciiTraceHelperForIpv4_Type)
    {
        self->obj = new PyNs3AsciiTraceHelperForIpv4__PythonHelper();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3AsciiTraceHelperForIpv4__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'AsciiTraceHelperForIpv4' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3AsciiTraceHelperForIpv4__tp_init(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}



PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__0(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv4", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!I|O", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv4_Type, &ipv4, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnableAsciiIpv4(std::string(prefix, prefix_len), ns3::Ptr< ns3::Ipv4  > (ipv4_ptr), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__1(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    unsigned int interface;
    const char *keywords[] = {"stream", "ipv4", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &PyNs3Ipv4_Type, &ipv4, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    self->obj->EnableAsciiIpv4(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), ns3::Ptr< ns3::Ipv4  > (ipv4_ptr), interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__2(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *ipv4Name;
    Py_ssize_t ipv4Name_len;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv4Name", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#I|O", (char **) keywords, &prefix, &prefix_len, &ipv4Name, &ipv4Name_len, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnableAsciiIpv4(std::string(prefix, prefix_len), std::string(ipv4Name, ipv4Name_len), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__3(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *ipv4Name;
    Py_ssize_t ipv4Name_len;
    unsigned int interface;
    const char *keywords[] = {"stream", "ipv4Name", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#I", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &ipv4Name, &ipv4Name_len, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv4(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), std::string(ipv4Name, ipv4Name_len), interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__4(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv4InterfaceContainer *c;
    const char *keywords[] = {"prefix", "c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv4InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnableAsciiIpv4(std::string(prefix, prefix_len), *((PyNs3Ipv4InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__5(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    PyNs3Ipv4InterfaceContainer *c;
    const char *keywords[] = {"stream", "c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &PyNs3Ipv4InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv4(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), *((PyNs3Ipv4InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__6(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3NodeContainer *n;
    const char *keywords[] = {"prefix", "n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3NodeContainer_Type, &n)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnableAsciiIpv4(std::string(prefix, prefix_len), *((PyNs3NodeContainer *) n)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__7(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    PyNs3NodeContainer *n;
    const char *keywords[] = {"stream", "n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &PyNs3NodeContainer_Type, &n)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv4(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), *((PyNs3NodeContainer *) n)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__8(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    unsigned int nodeid;
    unsigned int deviceid;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"prefix", "nodeid", "deviceid", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#IIO", (char **) keywords, &prefix, &prefix_len, &nodeid, &deviceid, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnableAsciiIpv4(std::string(prefix, prefix_len), nodeid, deviceid, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__9(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    unsigned int nodeid;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"stream", "nodeid", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!IIO", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &nodeid, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnableAsciiIpv4(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), nodeid, interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[10] = {0,};
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__4(self, args, kwargs, &exceptions[4]);
    if (!exceptions[4]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__5(self, args, kwargs, &exceptions[5]);
    if (!exceptions[5]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__6(self, args, kwargs, &exceptions[6]);
    if (!exceptions[6]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__7(self, args, kwargs, &exceptions[7]);
    if (!exceptions[7]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        Py_DECREF(exceptions[6]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__8(self, args, kwargs, &exceptions[8]);
    if (!exceptions[8]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        Py_DECREF(exceptions[6]);
        Py_DECREF(exceptions[7]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4__9(self, args, kwargs, &exceptions[9]);
    if (!exceptions[9]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        Py_DECREF(exceptions[6]);
        Py_DECREF(exceptions[7]);
        Py_DECREF(exceptions[8]);
        return retval;
    }
    error_list = PyList_New(10);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyList_SET_ITEM(error_list, 4, PyObject_Str(exceptions[4]));
    Py_DECREF(exceptions[4]);
    PyList_SET_ITEM(error_list, 5, PyObject_Str(exceptions[5]));
    Py_DECREF(exceptions[5]);
    PyList_SET_ITEM(error_list, 6, PyObject_Str(exceptions[6]));
    Py_DECREF(exceptions[6]);
    PyList_SET_ITEM(error_list, 7, PyObject_Str(exceptions[7]));
    Py_DECREF(exceptions[7]);
    PyList_SET_ITEM(error_list, 8, PyObject_Str(exceptions[8]));
    Py_DECREF(exceptions[8]);
    PyList_SET_ITEM(error_list, 9, PyObject_Str(exceptions[9]));
    Py_DECREF(exceptions[9]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}



PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4All__0(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *keywords[] = {"prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &prefix, &prefix_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnableAsciiIpv4All(std::string(prefix, prefix_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4All__1(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv4All(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4All(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4All__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4All__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4Internal(PyNs3AsciiTraceHelperForIpv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"stream", "prefix", "ipv4", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#O!IO", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &prefix, &prefix_len, &PyNs3Ipv4_Type, &ipv4, &interface, &py_explicitFilename)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnableAsciiIpv4Internal(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), std::string(prefix, prefix_len), ns3::Ptr< ns3::Ipv4  > (ipv4_ptr), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3AsciiTraceHelperForIpv4_methods[] = {
    {(char *) "EnableAsciiIpv4", (PyCFunction) _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnableAsciiIpv4All", (PyCFunction) _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4All, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnableAsciiIpv4Internal", (PyCFunction) _wrap_PyNs3AsciiTraceHelperForIpv4_EnableAsciiIpv4Internal, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3AsciiTraceHelperForIpv4__tp_clear(PyNs3AsciiTraceHelperForIpv4 *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::AsciiTraceHelperForIpv4 *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3AsciiTraceHelperForIpv4__tp_traverse(PyNs3AsciiTraceHelperForIpv4 *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3AsciiTraceHelperForIpv4__PythonHelper).name() )
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3AsciiTraceHelperForIpv4__tp_dealloc(PyNs3AsciiTraceHelperForIpv4 *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3AsciiTraceHelperForIpv4_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3AsciiTraceHelperForIpv4_wrapper_registry.end()) {
        PyNs3AsciiTraceHelperForIpv4_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3AsciiTraceHelperForIpv4__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3AsciiTraceHelperForIpv4__tp_richcompare (PyNs3AsciiTraceHelperForIpv4 *PYBINDGEN_UNUSED(self), PyNs3AsciiTraceHelperForIpv4 *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3AsciiTraceHelperForIpv4_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3AsciiTraceHelperForIpv4_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.AsciiTraceHelperForIpv4",            /* tp_name */
    sizeof(PyNs3AsciiTraceHelperForIpv4),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3AsciiTraceHelperForIpv4__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3AsciiTraceHelperForIpv4__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3AsciiTraceHelperForIpv4__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3AsciiTraceHelperForIpv4__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3AsciiTraceHelperForIpv4_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3AsciiTraceHelperForIpv4, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3AsciiTraceHelperForIpv4__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3AsciiTraceHelperForIpv6_wrapper_registry;

void
PyNs3AsciiTraceHelperForIpv6__PythonHelper::EnableAsciiIpv6Internal(ns3::Ptr< ns3::OutputStreamWrapper > stream, std::string prefix, ns3::Ptr< ns3::Ipv6 > ipv6, uint32_t interface, bool explicitFilename)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AsciiTraceHelperForIpv6 *self_obj_before;
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *py_OutputStreamWrapper;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    const char *prefix_ptr;
    Py_ssize_t prefix_len;
    PyNs3Ipv6 *py_Ipv6;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter2;
    PyTypeObject *wrapper_type2 = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "EnableAsciiIpv6Internal"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3AsciiTraceHelperForIpv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AsciiTraceHelperForIpv6* >(m_pyself)->obj = (ns3::AsciiTraceHelperForIpv6*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_OutputStreamWrapper = NULL;
    } else {
        py_OutputStreamWrapper = (PyNs3OutputStreamWrapper *) wrapper_lookup_iter->second;
        Py_INCREF(py_OutputStreamWrapper);
    }
    
    if (py_OutputStreamWrapper == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream))), &PyNs3OutputStreamWrapper_Type);
        py_OutputStreamWrapper = PyObject_New(PyNs3OutputStreamWrapper, wrapper_type);
        py_OutputStreamWrapper->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream))->Ref();
        py_OutputStreamWrapper->obj = const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream));
        PyNs3Empty_wrapper_registry[(void *) py_OutputStreamWrapper->obj] = (PyObject *) py_OutputStreamWrapper;
    }
    prefix_ptr = (prefix).c_str();
    prefix_len = (prefix).size();
    if (typeid(*(const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6)))).name() == typeid(PyNs3Ipv6__PythonHelper).name())
    {
        py_Ipv6 = (PyNs3Ipv6*) (((PyNs3Ipv6__PythonHelper*) const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6)))->m_pyself);
        py_Ipv6->obj = const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6));
        Py_INCREF(py_Ipv6);
    } else {
        wrapper_lookup_iter2 = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6)));
        if (wrapper_lookup_iter2 == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Ipv6 = NULL;
        } else {
            py_Ipv6 = (PyNs3Ipv6 *) wrapper_lookup_iter2->second;
            Py_INCREF(py_Ipv6);
        }
    
        if (py_Ipv6 == NULL)
        {
            wrapper_type2 = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6))), &PyNs3Ipv6_Type);
            py_Ipv6 = PyObject_GC_New(PyNs3Ipv6, wrapper_type2);
            py_Ipv6->inst_dict = NULL;
            py_Ipv6->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6))->Ref();
            py_Ipv6->obj = const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6->obj] = (PyObject *) py_Ipv6;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "EnableAsciiIpv6Internal", (char *) "Ns#NNN", py_OutputStreamWrapper, prefix_ptr, prefix_len, py_Ipv6, PyLong_FromUnsignedLong(interface), PyBool_FromLong(explicitFilename));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AsciiTraceHelperForIpv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AsciiTraceHelperForIpv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AsciiTraceHelperForIpv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3AsciiTraceHelperForIpv6__tp_init__0(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3AsciiTraceHelperForIpv6 *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3AsciiTraceHelperForIpv6_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3AsciiTraceHelperForIpv6_Type)
    {
        self->obj = new PyNs3AsciiTraceHelperForIpv6__PythonHelper(*((PyNs3AsciiTraceHelperForIpv6 *) arg0)->obj);
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3AsciiTraceHelperForIpv6__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'AsciiTraceHelperForIpv6' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3AsciiTraceHelperForIpv6__tp_init__1(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3AsciiTraceHelperForIpv6_Type)
    {
        self->obj = new PyNs3AsciiTraceHelperForIpv6__PythonHelper();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3AsciiTraceHelperForIpv6__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'AsciiTraceHelperForIpv6' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3AsciiTraceHelperForIpv6__tp_init(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}



PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__0(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv6", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!I|O", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv6_Type, &ipv6, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnableAsciiIpv6(std::string(prefix, prefix_len), ns3::Ptr< ns3::Ipv6  > (ipv6_ptr), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__1(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    unsigned int interface;
    const char *keywords[] = {"stream", "ipv6", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &PyNs3Ipv6_Type, &ipv6, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    self->obj->EnableAsciiIpv6(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), ns3::Ptr< ns3::Ipv6  > (ipv6_ptr), interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__2(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *ipv6Name;
    Py_ssize_t ipv6Name_len;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv6Name", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#I|O", (char **) keywords, &prefix, &prefix_len, &ipv6Name, &ipv6Name_len, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnableAsciiIpv6(std::string(prefix, prefix_len), std::string(ipv6Name, ipv6Name_len), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__3(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *ipv6Name;
    Py_ssize_t ipv6Name_len;
    unsigned int interface;
    const char *keywords[] = {"stream", "ipv6Name", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#I", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &ipv6Name, &ipv6Name_len, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv6(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), std::string(ipv6Name, ipv6Name_len), interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__4(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv6InterfaceContainer *c;
    const char *keywords[] = {"prefix", "c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv6InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnableAsciiIpv6(std::string(prefix, prefix_len), *((PyNs3Ipv6InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__5(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    PyNs3Ipv6InterfaceContainer *c;
    const char *keywords[] = {"stream", "c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &PyNs3Ipv6InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv6(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), *((PyNs3Ipv6InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__6(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3NodeContainer *n;
    const char *keywords[] = {"prefix", "n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3NodeContainer_Type, &n)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnableAsciiIpv6(std::string(prefix, prefix_len), *((PyNs3NodeContainer *) n)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__7(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    PyNs3NodeContainer *n;
    const char *keywords[] = {"stream", "n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &PyNs3NodeContainer_Type, &n)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv6(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), *((PyNs3NodeContainer *) n)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__8(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    unsigned int nodeid;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"prefix", "nodeid", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#IIO", (char **) keywords, &prefix, &prefix_len, &nodeid, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnableAsciiIpv6(std::string(prefix, prefix_len), nodeid, interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__9(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    unsigned int nodeid;
    unsigned int interface;
    const char *keywords[] = {"stream", "nodeid", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!II", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &nodeid, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv6(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), nodeid, interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[10] = {0,};
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__4(self, args, kwargs, &exceptions[4]);
    if (!exceptions[4]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__5(self, args, kwargs, &exceptions[5]);
    if (!exceptions[5]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__6(self, args, kwargs, &exceptions[6]);
    if (!exceptions[6]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__7(self, args, kwargs, &exceptions[7]);
    if (!exceptions[7]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        Py_DECREF(exceptions[6]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__8(self, args, kwargs, &exceptions[8]);
    if (!exceptions[8]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        Py_DECREF(exceptions[6]);
        Py_DECREF(exceptions[7]);
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6__9(self, args, kwargs, &exceptions[9]);
    if (!exceptions[9]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        Py_DECREF(exceptions[6]);
        Py_DECREF(exceptions[7]);
        Py_DECREF(exceptions[8]);
        return retval;
    }
    error_list = PyList_New(10);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyList_SET_ITEM(error_list, 4, PyObject_Str(exceptions[4]));
    Py_DECREF(exceptions[4]);
    PyList_SET_ITEM(error_list, 5, PyObject_Str(exceptions[5]));
    Py_DECREF(exceptions[5]);
    PyList_SET_ITEM(error_list, 6, PyObject_Str(exceptions[6]));
    Py_DECREF(exceptions[6]);
    PyList_SET_ITEM(error_list, 7, PyObject_Str(exceptions[7]));
    Py_DECREF(exceptions[7]);
    PyList_SET_ITEM(error_list, 8, PyObject_Str(exceptions[8]));
    Py_DECREF(exceptions[8]);
    PyList_SET_ITEM(error_list, 9, PyObject_Str(exceptions[9]));
    Py_DECREF(exceptions[9]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}



PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6All__0(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *keywords[] = {"prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &prefix, &prefix_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnableAsciiIpv6All(std::string(prefix, prefix_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6All__1(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv6All(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6All(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6All__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6All__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6Internal(PyNs3AsciiTraceHelperForIpv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"stream", "prefix", "ipv6", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#O!IO", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &prefix, &prefix_len, &PyNs3Ipv6_Type, &ipv6, &interface, &py_explicitFilename)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnableAsciiIpv6Internal(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), std::string(prefix, prefix_len), ns3::Ptr< ns3::Ipv6  > (ipv6_ptr), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3AsciiTraceHelperForIpv6_methods[] = {
    {(char *) "EnableAsciiIpv6", (PyCFunction) _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnableAsciiIpv6All", (PyCFunction) _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6All, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnableAsciiIpv6Internal", (PyCFunction) _wrap_PyNs3AsciiTraceHelperForIpv6_EnableAsciiIpv6Internal, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3AsciiTraceHelperForIpv6__tp_clear(PyNs3AsciiTraceHelperForIpv6 *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::AsciiTraceHelperForIpv6 *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3AsciiTraceHelperForIpv6__tp_traverse(PyNs3AsciiTraceHelperForIpv6 *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3AsciiTraceHelperForIpv6__PythonHelper).name() )
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3AsciiTraceHelperForIpv6__tp_dealloc(PyNs3AsciiTraceHelperForIpv6 *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3AsciiTraceHelperForIpv6_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3AsciiTraceHelperForIpv6_wrapper_registry.end()) {
        PyNs3AsciiTraceHelperForIpv6_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3AsciiTraceHelperForIpv6__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3AsciiTraceHelperForIpv6__tp_richcompare (PyNs3AsciiTraceHelperForIpv6 *PYBINDGEN_UNUSED(self), PyNs3AsciiTraceHelperForIpv6 *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3AsciiTraceHelperForIpv6_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3AsciiTraceHelperForIpv6_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.AsciiTraceHelperForIpv6",            /* tp_name */
    sizeof(PyNs3AsciiTraceHelperForIpv6),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3AsciiTraceHelperForIpv6__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3AsciiTraceHelperForIpv6__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3AsciiTraceHelperForIpv6__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3AsciiTraceHelperForIpv6__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3AsciiTraceHelperForIpv6_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3AsciiTraceHelperForIpv6, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3AsciiTraceHelperForIpv6__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3CandidateQueue_wrapper_registry;

static int
_wrap_PyNs3CandidateQueue__tp_init(PyNs3CandidateQueue *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    self->obj = new ns3::CandidateQueue();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyNs3CandidateQueue_Clear(PyNs3CandidateQueue *self)
{
    PyObject *py_retval;
    
    self->obj->Clear();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3CandidateQueue_Reorder(PyNs3CandidateQueue *self)
{
    PyObject *py_retval;
    
    self->obj->Reorder();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3CandidateQueue_Empty(PyNs3CandidateQueue *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->Empty();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3CandidateQueue_Size(PyNs3CandidateQueue *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->Size();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}

static PyMethodDef PyNs3CandidateQueue_methods[] = {
    {(char *) "Clear", (PyCFunction) _wrap_PyNs3CandidateQueue_Clear, METH_NOARGS, NULL },
    {(char *) "Reorder", (PyCFunction) _wrap_PyNs3CandidateQueue_Reorder, METH_NOARGS, NULL },
    {(char *) "Empty", (PyCFunction) _wrap_PyNs3CandidateQueue_Empty, METH_NOARGS, NULL },
    {(char *) "Size", (PyCFunction) _wrap_PyNs3CandidateQueue_Size, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3CandidateQueue__tp_dealloc(PyNs3CandidateQueue *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3CandidateQueue_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3CandidateQueue_wrapper_registry.end()) {
        PyNs3CandidateQueue_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::CandidateQueue *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyNs3CandidateQueue__tp_str(PyNs3CandidateQueue *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyNs3CandidateQueue__tp_richcompare (PyNs3CandidateQueue *PYBINDGEN_UNUSED(self), PyNs3CandidateQueue *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3CandidateQueue_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3CandidateQueue_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.CandidateQueue",            /* tp_name */
    sizeof(PyNs3CandidateQueue),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3CandidateQueue__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyNs3CandidateQueue__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3CandidateQueue__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3CandidateQueue_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3CandidateQueue__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3GlobalRouteManager_wrapper_registry;

static int
_wrap_PyNs3GlobalRouteManager__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'GlobalRouteManager' cannot be constructed ()");
    return -1;
}


PyObject *
_wrap_PyNs3GlobalRouteManager_BuildGlobalRoutingDatabase(void)
{
    PyObject *py_retval;
    
    ns3::GlobalRouteManager::BuildGlobalRoutingDatabase();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouteManager_InitializeRoutes(void)
{
    PyObject *py_retval;
    
    ns3::GlobalRouteManager::InitializeRoutes();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouteManager_DeleteGlobalRoutes(void)
{
    PyObject *py_retval;
    
    ns3::GlobalRouteManager::DeleteGlobalRoutes();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouteManager_AllocateRouterId(void)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = ns3::GlobalRouteManager::AllocateRouterId();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}

static PyMethodDef PyNs3GlobalRouteManager_methods[] = {
    {(char *) "BuildGlobalRoutingDatabase", (PyCFunction) _wrap_PyNs3GlobalRouteManager_BuildGlobalRoutingDatabase, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "InitializeRoutes", (PyCFunction) _wrap_PyNs3GlobalRouteManager_InitializeRoutes, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "DeleteGlobalRoutes", (PyCFunction) _wrap_PyNs3GlobalRouteManager_DeleteGlobalRoutes, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "AllocateRouterId", (PyCFunction) _wrap_PyNs3GlobalRouteManager_AllocateRouterId, METH_NOARGS|METH_STATIC, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3GlobalRouteManager__tp_dealloc(PyNs3GlobalRouteManager *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3GlobalRouteManager_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3GlobalRouteManager_wrapper_registry.end()) {
        PyNs3GlobalRouteManager_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::GlobalRouteManager *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3GlobalRouteManager__tp_richcompare (PyNs3GlobalRouteManager *PYBINDGEN_UNUSED(self), PyNs3GlobalRouteManager *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3GlobalRouteManager_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3GlobalRouteManager_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.GlobalRouteManager",            /* tp_name */
    sizeof(PyNs3GlobalRouteManager),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3GlobalRouteManager__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3GlobalRouteManager__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3GlobalRouteManager_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3GlobalRouteManager__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3GlobalRouteManagerImpl_wrapper_registry;

void
PyNs3GlobalRouteManagerImpl__PythonHelper::DeleteGlobalRoutes()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::GlobalRouteManagerImpl *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DeleteGlobalRoutes"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::GlobalRouteManagerImpl::DeleteGlobalRoutes();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj = (ns3::GlobalRouteManagerImpl*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DeleteGlobalRoutes", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3GlobalRouteManagerImpl__PythonHelper::BuildGlobalRoutingDatabase()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::GlobalRouteManagerImpl *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "BuildGlobalRoutingDatabase"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::GlobalRouteManagerImpl::BuildGlobalRoutingDatabase();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj = (ns3::GlobalRouteManagerImpl*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "BuildGlobalRoutingDatabase", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3GlobalRouteManagerImpl__PythonHelper::InitializeRoutes()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::GlobalRouteManagerImpl *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "InitializeRoutes"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::GlobalRouteManagerImpl::InitializeRoutes();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj = (ns3::GlobalRouteManagerImpl*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "InitializeRoutes", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3GlobalRouteManagerImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

static int
_wrap_PyNs3GlobalRouteManagerImpl__tp_init(PyNs3GlobalRouteManagerImpl *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    if (self->ob_type != &PyNs3GlobalRouteManagerImpl_Type)
    {
        self->obj = new PyNs3GlobalRouteManagerImpl__PythonHelper();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3GlobalRouteManagerImpl__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        self->obj = new ns3::GlobalRouteManagerImpl();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    }
    return 0;
}


PyObject *
_wrap_PyNs3GlobalRouteManagerImpl_BuildGlobalRoutingDatabase(PyNs3GlobalRouteManagerImpl *self)
{
    PyObject *py_retval;
    PyNs3GlobalRouteManagerImpl__PythonHelper *helper_class = dynamic_cast<PyNs3GlobalRouteManagerImpl__PythonHelper*> (self->obj);
    
    (helper_class == NULL)? (self->obj->BuildGlobalRoutingDatabase()) : (self->obj->ns3::GlobalRouteManagerImpl::BuildGlobalRoutingDatabase());
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouteManagerImpl_DebugSPFCalculate(PyNs3GlobalRouteManagerImpl *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *root;
    const char *keywords[] = {"root", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &root)) {
        return NULL;
    }
    self->obj->DebugSPFCalculate(*((PyNs3Ipv4Address *) root)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouteManagerImpl_DeleteGlobalRoutes(PyNs3GlobalRouteManagerImpl *self)
{
    PyObject *py_retval;
    PyNs3GlobalRouteManagerImpl__PythonHelper *helper_class = dynamic_cast<PyNs3GlobalRouteManagerImpl__PythonHelper*> (self->obj);
    
    (helper_class == NULL)? (self->obj->DeleteGlobalRoutes()) : (self->obj->ns3::GlobalRouteManagerImpl::DeleteGlobalRoutes());
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouteManagerImpl_InitializeRoutes(PyNs3GlobalRouteManagerImpl *self)
{
    PyObject *py_retval;
    PyNs3GlobalRouteManagerImpl__PythonHelper *helper_class = dynamic_cast<PyNs3GlobalRouteManagerImpl__PythonHelper*> (self->obj);
    
    (helper_class == NULL)? (self->obj->InitializeRoutes()) : (self->obj->ns3::GlobalRouteManagerImpl::InitializeRoutes());
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3GlobalRouteManagerImpl_methods[] = {
    {(char *) "BuildGlobalRoutingDatabase", (PyCFunction) _wrap_PyNs3GlobalRouteManagerImpl_BuildGlobalRoutingDatabase, METH_NOARGS, NULL },
    {(char *) "DebugSPFCalculate", (PyCFunction) _wrap_PyNs3GlobalRouteManagerImpl_DebugSPFCalculate, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "DeleteGlobalRoutes", (PyCFunction) _wrap_PyNs3GlobalRouteManagerImpl_DeleteGlobalRoutes, METH_NOARGS, NULL },
    {(char *) "InitializeRoutes", (PyCFunction) _wrap_PyNs3GlobalRouteManagerImpl_InitializeRoutes, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3GlobalRouteManagerImpl__tp_clear(PyNs3GlobalRouteManagerImpl *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::GlobalRouteManagerImpl *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3GlobalRouteManagerImpl__tp_traverse(PyNs3GlobalRouteManagerImpl *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3GlobalRouteManagerImpl__PythonHelper).name() )
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3GlobalRouteManagerImpl__tp_dealloc(PyNs3GlobalRouteManagerImpl *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3GlobalRouteManagerImpl_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3GlobalRouteManagerImpl_wrapper_registry.end()) {
        PyNs3GlobalRouteManagerImpl_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3GlobalRouteManagerImpl__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3GlobalRouteManagerImpl__tp_richcompare (PyNs3GlobalRouteManagerImpl *PYBINDGEN_UNUSED(self), PyNs3GlobalRouteManagerImpl *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3GlobalRouteManagerImpl_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3GlobalRouteManagerImpl_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.GlobalRouteManagerImpl",            /* tp_name */
    sizeof(PyNs3GlobalRouteManagerImpl),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3GlobalRouteManagerImpl__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3GlobalRouteManagerImpl__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3GlobalRouteManagerImpl__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3GlobalRouteManagerImpl__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3GlobalRouteManagerImpl_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3GlobalRouteManagerImpl, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3GlobalRouteManagerImpl__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3GlobalRouteManagerLSDB_wrapper_registry;

static int
_wrap_PyNs3GlobalRouteManagerLSDB__tp_init(PyNs3GlobalRouteManagerLSDB *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    self->obj = new ns3::GlobalRouteManagerLSDB();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyNs3GlobalRouteManagerLSDB_Initialize(PyNs3GlobalRouteManagerLSDB *self)
{
    PyObject *py_retval;
    
    self->obj->Initialize();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouteManagerLSDB_GetNumExtLSAs(PyNs3GlobalRouteManagerLSDB *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNumExtLSAs();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}

static PyMethodDef PyNs3GlobalRouteManagerLSDB_methods[] = {
    {(char *) "Initialize", (PyCFunction) _wrap_PyNs3GlobalRouteManagerLSDB_Initialize, METH_NOARGS, NULL },
    {(char *) "GetNumExtLSAs", (PyCFunction) _wrap_PyNs3GlobalRouteManagerLSDB_GetNumExtLSAs, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3GlobalRouteManagerLSDB__tp_dealloc(PyNs3GlobalRouteManagerLSDB *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3GlobalRouteManagerLSDB_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3GlobalRouteManagerLSDB_wrapper_registry.end()) {
        PyNs3GlobalRouteManagerLSDB_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::GlobalRouteManagerLSDB *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3GlobalRouteManagerLSDB__tp_richcompare (PyNs3GlobalRouteManagerLSDB *PYBINDGEN_UNUSED(self), PyNs3GlobalRouteManagerLSDB *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3GlobalRouteManagerLSDB_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3GlobalRouteManagerLSDB_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.GlobalRouteManagerLSDB",            /* tp_name */
    sizeof(PyNs3GlobalRouteManagerLSDB),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3GlobalRouteManagerLSDB__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3GlobalRouteManagerLSDB__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3GlobalRouteManagerLSDB_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3GlobalRouteManagerLSDB__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3GlobalRoutingLSA_wrapper_registry;


static int
_wrap_PyNs3GlobalRoutingLSA__tp_init__0(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::GlobalRoutingLSA();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3GlobalRoutingLSA__tp_init__1(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    ns3::GlobalRoutingLSA::SPFStatus status;
    PyNs3Ipv4Address *linkStateId;
    PyNs3Ipv4Address *advertisingRtr;
    const char *keywords[] = {"status", "linkStateId", "advertisingRtr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iO!O!", (char **) keywords, &status, &PyNs3Ipv4Address_Type, &linkStateId, &PyNs3Ipv4Address_Type, &advertisingRtr)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::GlobalRoutingLSA(status, *((PyNs3Ipv4Address *) linkStateId)->obj, *((PyNs3Ipv4Address *) advertisingRtr)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3GlobalRoutingLSA__tp_init__2(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3GlobalRoutingLSA *lsa;
    const char *keywords[] = {"lsa", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3GlobalRoutingLSA_Type, &lsa)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::GlobalRoutingLSA(*((PyNs3GlobalRoutingLSA *) lsa)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3GlobalRoutingLSA__tp_init(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3GlobalRoutingLSA__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3GlobalRoutingLSA__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3GlobalRoutingLSA__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_SetNetworkLSANetworkMask(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Mask *mask;
    const char *keywords[] = {"mask", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Mask_Type, &mask)) {
        return NULL;
    }
    self->obj->SetNetworkLSANetworkMask(*((PyNs3Ipv4Mask *) mask)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_GetAdvertisingRouter(PyNs3GlobalRoutingLSA *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetAdvertisingRouter();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_GetLinkStateId(PyNs3GlobalRoutingLSA *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetLinkStateId();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_SetNode(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_SetLSType(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::GlobalRoutingLSA::LSType typ;
    const char *keywords[] = {"typ", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &typ)) {
        return NULL;
    }
    self->obj->SetLSType(typ);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_AddAttachedRouter(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3Ipv4Address *addr;
    const char *keywords[] = {"addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr)) {
        return NULL;
    }
    retval = self->obj->AddAttachedRouter(*((PyNs3Ipv4Address *) addr)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_GetNetworkLSANetworkMask(PyNs3GlobalRoutingLSA *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Mask *py_Ipv4Mask;
    
    ns3::Ipv4Mask retval = self->obj->GetNetworkLSANetworkMask();
    py_Ipv4Mask = PyObject_New(PyNs3Ipv4Mask, &PyNs3Ipv4Mask_Type);
    py_Ipv4Mask->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Mask->obj = new ns3::Ipv4Mask(retval);
    PyNs3Ipv4Mask_wrapper_registry[(void *) py_Ipv4Mask->obj] = (PyObject *) py_Ipv4Mask;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Mask);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_GetStatus(PyNs3GlobalRoutingLSA *self)
{
    PyObject *py_retval;
    ns3::GlobalRoutingLSA::SPFStatus retval;
    
    retval = self->obj->GetStatus();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_SetStatus(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::GlobalRoutingLSA::SPFStatus status;
    const char *keywords[] = {"status", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &status)) {
        return NULL;
    }
    self->obj->SetStatus(status);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_GetLSType(PyNs3GlobalRoutingLSA *self)
{
    PyObject *py_retval;
    ns3::GlobalRoutingLSA::LSType retval;
    
    retval = self->obj->GetLSType();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_ClearLinkRecords(PyNs3GlobalRoutingLSA *self)
{
    PyObject *py_retval;
    
    self->obj->ClearLinkRecords();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_IsEmpty(PyNs3GlobalRoutingLSA *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsEmpty();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_GetAttachedRouter(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    PyNs3Ipv4Address *py_Ipv4Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    ns3::Ipv4Address retval = self->obj->GetAttachedRouter(n);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_GetNLinkRecords(PyNs3GlobalRoutingLSA *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNLinkRecords();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_GetNode(PyNs3GlobalRoutingLSA *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3Node *py_Node;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetNode();
    if (!(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Node__PythonHelper).name())
    {
        py_Node = reinterpret_cast< PyNs3Node* >(reinterpret_cast< PyNs3Node__PythonHelper* >(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Node);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Node *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Node = NULL;
        } else {
            py_Node = (PyNs3Node *) wrapper_lookup_iter->second;
            Py_INCREF(py_Node);
        }
    
        if (py_Node == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))), &PyNs3Node_Type);
            py_Node = PyObject_GC_New(PyNs3Node, wrapper_type);
            py_Node->inst_dict = NULL;
            py_Node->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Node *> (ns3::PeekPointer (retval))->Ref();
            py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Node->obj] = (PyObject *) py_Node;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Node);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_CopyLinkRecords(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3GlobalRoutingLSA *lsa;
    const char *keywords[] = {"lsa", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3GlobalRoutingLSA_Type, &lsa)) {
        return NULL;
    }
    self->obj->CopyLinkRecords(*((PyNs3GlobalRoutingLSA *) lsa)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_SetAdvertisingRouter(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *rtr;
    const char *keywords[] = {"rtr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &rtr)) {
        return NULL;
    }
    self->obj->SetAdvertisingRouter(*((PyNs3Ipv4Address *) rtr)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_SetLinkStateId(PyNs3GlobalRoutingLSA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *addr;
    const char *keywords[] = {"addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr)) {
        return NULL;
    }
    self->obj->SetLinkStateId(*((PyNs3Ipv4Address *) addr)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLSA_GetNAttachedRouters(PyNs3GlobalRoutingLSA *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNAttachedRouters();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3GlobalRoutingLSA__copy__(PyNs3GlobalRoutingLSA *self)
{

    PyNs3GlobalRoutingLSA *py_copy;
    py_copy = PyObject_New(PyNs3GlobalRoutingLSA, &PyNs3GlobalRoutingLSA_Type);
    py_copy->obj = new ns3::GlobalRoutingLSA(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3GlobalRoutingLSA_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3GlobalRoutingLSA_methods[] = {
    {(char *) "SetNetworkLSANetworkMask", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_SetNetworkLSANetworkMask, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAdvertisingRouter", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_GetAdvertisingRouter, METH_NOARGS, NULL },
    {(char *) "GetLinkStateId", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_GetLinkStateId, METH_NOARGS, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetLSType", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_SetLSType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddAttachedRouter", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_AddAttachedRouter, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNetworkLSANetworkMask", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_GetNetworkLSANetworkMask, METH_NOARGS, NULL },
    {(char *) "GetStatus", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_GetStatus, METH_NOARGS, NULL },
    {(char *) "SetStatus", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_SetStatus, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLSType", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_GetLSType, METH_NOARGS, NULL },
    {(char *) "ClearLinkRecords", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_ClearLinkRecords, METH_NOARGS, NULL },
    {(char *) "IsEmpty", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_IsEmpty, METH_NOARGS, NULL },
    {(char *) "GetAttachedRouter", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_GetAttachedRouter, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNLinkRecords", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_GetNLinkRecords, METH_NOARGS, NULL },
    {(char *) "GetNode", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_GetNode, METH_NOARGS, NULL },
    {(char *) "CopyLinkRecords", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_CopyLinkRecords, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetAdvertisingRouter", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_SetAdvertisingRouter, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetLinkStateId", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_SetLinkStateId, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNAttachedRouters", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA_GetNAttachedRouters, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3GlobalRoutingLSA__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3GlobalRoutingLSA__tp_dealloc(PyNs3GlobalRoutingLSA *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3GlobalRoutingLSA_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3GlobalRoutingLSA_wrapper_registry.end()) {
        PyNs3GlobalRoutingLSA_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::GlobalRoutingLSA *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyNs3GlobalRoutingLSA__tp_str(PyNs3GlobalRoutingLSA *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyNs3GlobalRoutingLSA__tp_richcompare (PyNs3GlobalRoutingLSA *PYBINDGEN_UNUSED(self), PyNs3GlobalRoutingLSA *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3GlobalRoutingLSA_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3GlobalRoutingLSA_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.GlobalRoutingLSA",            /* tp_name */
    sizeof(PyNs3GlobalRoutingLSA),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3GlobalRoutingLSA__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyNs3GlobalRoutingLSA__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3GlobalRoutingLSA__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3GlobalRoutingLSA_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3GlobalRoutingLSA__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3GlobalRoutingLinkRecord_wrapper_registry;


static int
_wrap_PyNs3GlobalRoutingLinkRecord__tp_init__0(PyNs3GlobalRoutingLinkRecord *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3GlobalRoutingLinkRecord *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3GlobalRoutingLinkRecord_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::GlobalRoutingLinkRecord(*((PyNs3GlobalRoutingLinkRecord *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3GlobalRoutingLinkRecord__tp_init__1(PyNs3GlobalRoutingLinkRecord *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::GlobalRoutingLinkRecord();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3GlobalRoutingLinkRecord__tp_init__2(PyNs3GlobalRoutingLinkRecord *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    ns3::GlobalRoutingLinkRecord::LinkType linkType;
    PyNs3Ipv4Address *linkId;
    PyNs3Ipv4Address *linkData;
    int metric;
    const char *keywords[] = {"linkType", "linkId", "linkData", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iO!O!i", (char **) keywords, &linkType, &PyNs3Ipv4Address_Type, &linkId, &PyNs3Ipv4Address_Type, &linkData, &metric)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (metric > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::GlobalRoutingLinkRecord(linkType, *((PyNs3Ipv4Address *) linkId)->obj, *((PyNs3Ipv4Address *) linkData)->obj, metric);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3GlobalRoutingLinkRecord__tp_init(PyNs3GlobalRoutingLinkRecord *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3GlobalRoutingLinkRecord__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3GlobalRoutingLinkRecord__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3GlobalRoutingLinkRecord__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3GlobalRoutingLinkRecord_SetLinkData(PyNs3GlobalRoutingLinkRecord *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *addr;
    const char *keywords[] = {"addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr)) {
        return NULL;
    }
    self->obj->SetLinkData(*((PyNs3Ipv4Address *) addr)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLinkRecord_SetMetric(PyNs3GlobalRoutingLinkRecord *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int metric;
    const char *keywords[] = {"metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &metric)) {
        return NULL;
    }
    if (metric > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetMetric(metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLinkRecord_SetLinkId(PyNs3GlobalRoutingLinkRecord *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *addr;
    const char *keywords[] = {"addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr)) {
        return NULL;
    }
    self->obj->SetLinkId(*((PyNs3Ipv4Address *) addr)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLinkRecord_GetLinkData(PyNs3GlobalRoutingLinkRecord *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetLinkData();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLinkRecord_GetMetric(PyNs3GlobalRoutingLinkRecord *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetMetric();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLinkRecord_GetLinkId(PyNs3GlobalRoutingLinkRecord *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetLinkId();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLinkRecord_SetLinkType(PyNs3GlobalRoutingLinkRecord *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::GlobalRoutingLinkRecord::LinkType linkType;
    const char *keywords[] = {"linkType", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &linkType)) {
        return NULL;
    }
    self->obj->SetLinkType(linkType);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRoutingLinkRecord_GetLinkType(PyNs3GlobalRoutingLinkRecord *self)
{
    PyObject *py_retval;
    ns3::GlobalRoutingLinkRecord::LinkType retval;
    
    retval = self->obj->GetLinkType();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3GlobalRoutingLinkRecord__copy__(PyNs3GlobalRoutingLinkRecord *self)
{

    PyNs3GlobalRoutingLinkRecord *py_copy;
    py_copy = PyObject_New(PyNs3GlobalRoutingLinkRecord, &PyNs3GlobalRoutingLinkRecord_Type);
    py_copy->obj = new ns3::GlobalRoutingLinkRecord(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3GlobalRoutingLinkRecord_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3GlobalRoutingLinkRecord_methods[] = {
    {(char *) "SetLinkData", (PyCFunction) _wrap_PyNs3GlobalRoutingLinkRecord_SetLinkData, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetMetric", (PyCFunction) _wrap_PyNs3GlobalRoutingLinkRecord_SetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetLinkId", (PyCFunction) _wrap_PyNs3GlobalRoutingLinkRecord_SetLinkId, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLinkData", (PyCFunction) _wrap_PyNs3GlobalRoutingLinkRecord_GetLinkData, METH_NOARGS, NULL },
    {(char *) "GetMetric", (PyCFunction) _wrap_PyNs3GlobalRoutingLinkRecord_GetMetric, METH_NOARGS, NULL },
    {(char *) "GetLinkId", (PyCFunction) _wrap_PyNs3GlobalRoutingLinkRecord_GetLinkId, METH_NOARGS, NULL },
    {(char *) "SetLinkType", (PyCFunction) _wrap_PyNs3GlobalRoutingLinkRecord_SetLinkType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLinkType", (PyCFunction) _wrap_PyNs3GlobalRoutingLinkRecord_GetLinkType, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3GlobalRoutingLinkRecord__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3GlobalRoutingLinkRecord__tp_dealloc(PyNs3GlobalRoutingLinkRecord *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3GlobalRoutingLinkRecord_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3GlobalRoutingLinkRecord_wrapper_registry.end()) {
        PyNs3GlobalRoutingLinkRecord_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::GlobalRoutingLinkRecord *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3GlobalRoutingLinkRecord__tp_richcompare (PyNs3GlobalRoutingLinkRecord *PYBINDGEN_UNUSED(self), PyNs3GlobalRoutingLinkRecord *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3GlobalRoutingLinkRecord_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3GlobalRoutingLinkRecord_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.GlobalRoutingLinkRecord",            /* tp_name */
    sizeof(PyNs3GlobalRoutingLinkRecord),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3GlobalRoutingLinkRecord__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3GlobalRoutingLinkRecord__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3GlobalRoutingLinkRecord_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3GlobalRoutingLinkRecord__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv4AddressGenerator_wrapper_registry;


static int
_wrap_PyNs3Ipv4AddressGenerator__tp_init__0(PyNs3Ipv4AddressGenerator *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4AddressGenerator();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4AddressGenerator__tp_init__1(PyNs3Ipv4AddressGenerator *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4AddressGenerator *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4AddressGenerator_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4AddressGenerator(*((PyNs3Ipv4AddressGenerator *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4AddressGenerator__tp_init(PyNs3Ipv4AddressGenerator *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4AddressGenerator__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4AddressGenerator__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4AddressGenerator_Reset(void)
{
    PyObject *py_retval;
    
    ns3::Ipv4AddressGenerator::Reset();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4AddressGenerator_NextNetwork(PyNs3Ipv4AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Mask *mask;
    const char *keywords[] = {"mask", NULL};
    PyNs3Ipv4Address *py_Ipv4Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Mask_Type, &mask)) {
        return NULL;
    }
    ns3::Ipv4Address retval = ns3::Ipv4AddressGenerator::NextNetwork(*((PyNs3Ipv4Mask *) mask)->obj);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4AddressGenerator_GetAddress(PyNs3Ipv4AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Mask *mask;
    const char *keywords[] = {"mask", NULL};
    PyNs3Ipv4Address *py_Ipv4Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Mask_Type, &mask)) {
        return NULL;
    }
    ns3::Ipv4Address retval = ns3::Ipv4AddressGenerator::GetAddress(*((PyNs3Ipv4Mask *) mask)->obj);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4AddressGenerator_AddAllocated(PyNs3Ipv4AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv4Address *addr;
    const char *keywords[] = {"addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr)) {
        return NULL;
    }
    retval = ns3::Ipv4AddressGenerator::AddAllocated(*((PyNs3Ipv4Address *) addr)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4AddressGenerator_Init(PyNs3Ipv4AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *net;
    PyNs3Ipv4Mask *mask;
    PyNs3Ipv4Address *addr = NULL;
    const char *keywords[] = {"net", "mask", "addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!|O!", (char **) keywords, &PyNs3Ipv4Address_Type, &net, &PyNs3Ipv4Mask_Type, &mask, &PyNs3Ipv4Address_Type, &addr)) {
        return NULL;
    }
    ns3::Ipv4AddressGenerator::Init(*((PyNs3Ipv4Address *) net)->obj, *((PyNs3Ipv4Mask *) mask)->obj, (addr ? (*((PyNs3Ipv4Address *) addr)->obj) : "0.0.0.1"));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4AddressGenerator_InitAddress(PyNs3Ipv4AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *addr;
    PyNs3Ipv4Mask *mask;
    const char *keywords[] = {"addr", "mask", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr, &PyNs3Ipv4Mask_Type, &mask)) {
        return NULL;
    }
    ns3::Ipv4AddressGenerator::InitAddress(*((PyNs3Ipv4Address *) addr)->obj, *((PyNs3Ipv4Mask *) mask)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4AddressGenerator_GetNetwork(PyNs3Ipv4AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Mask *mask;
    const char *keywords[] = {"mask", NULL};
    PyNs3Ipv4Address *py_Ipv4Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Mask_Type, &mask)) {
        return NULL;
    }
    ns3::Ipv4Address retval = ns3::Ipv4AddressGenerator::GetNetwork(*((PyNs3Ipv4Mask *) mask)->obj);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4AddressGenerator_NextAddress(PyNs3Ipv4AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Mask *mask;
    const char *keywords[] = {"mask", NULL};
    PyNs3Ipv4Address *py_Ipv4Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Mask_Type, &mask)) {
        return NULL;
    }
    ns3::Ipv4Address retval = ns3::Ipv4AddressGenerator::NextAddress(*((PyNs3Ipv4Mask *) mask)->obj);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4AddressGenerator_TestMode(void)
{
    PyObject *py_retval;
    
    ns3::Ipv4AddressGenerator::TestMode();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4AddressGenerator__copy__(PyNs3Ipv4AddressGenerator *self)
{

    PyNs3Ipv4AddressGenerator *py_copy;
    py_copy = PyObject_New(PyNs3Ipv4AddressGenerator, &PyNs3Ipv4AddressGenerator_Type);
    py_copy->obj = new ns3::Ipv4AddressGenerator(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv4AddressGenerator_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4AddressGenerator_methods[] = {
    {(char *) "Reset", (PyCFunction) _wrap_PyNs3Ipv4AddressGenerator_Reset, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "NextNetwork", (PyCFunction) _wrap_PyNs3Ipv4AddressGenerator_NextNetwork, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv4AddressGenerator_GetAddress, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "AddAllocated", (PyCFunction) _wrap_PyNs3Ipv4AddressGenerator_AddAllocated, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "Init", (PyCFunction) _wrap_PyNs3Ipv4AddressGenerator_Init, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "InitAddress", (PyCFunction) _wrap_PyNs3Ipv4AddressGenerator_InitAddress, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "GetNetwork", (PyCFunction) _wrap_PyNs3Ipv4AddressGenerator_GetNetwork, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "NextAddress", (PyCFunction) _wrap_PyNs3Ipv4AddressGenerator_NextAddress, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "TestMode", (PyCFunction) _wrap_PyNs3Ipv4AddressGenerator_TestMode, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4AddressGenerator__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv4AddressGenerator__tp_dealloc(PyNs3Ipv4AddressGenerator *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv4AddressGenerator_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv4AddressGenerator_wrapper_registry.end()) {
        PyNs3Ipv4AddressGenerator_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv4AddressGenerator *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4AddressGenerator__tp_richcompare (PyNs3Ipv4AddressGenerator *PYBINDGEN_UNUSED(self), PyNs3Ipv4AddressGenerator *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4AddressGenerator_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4AddressGenerator_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4AddressGenerator",            /* tp_name */
    sizeof(PyNs3Ipv4AddressGenerator),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4AddressGenerator__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4AddressGenerator__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4AddressGenerator_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4AddressGenerator__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv4AddressHelper_wrapper_registry;


static int
_wrap_PyNs3Ipv4AddressHelper__tp_init__0(PyNs3Ipv4AddressHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4AddressHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4AddressHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4AddressHelper(*((PyNs3Ipv4AddressHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4AddressHelper__tp_init__1(PyNs3Ipv4AddressHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4AddressHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4AddressHelper__tp_init__2(PyNs3Ipv4AddressHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4Address *network;
    PyNs3Ipv4Mask *mask;
    PyNs3Ipv4Address *base = NULL;
    const char *keywords[] = {"network", "mask", "base", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!|O!", (char **) keywords, &PyNs3Ipv4Address_Type, &network, &PyNs3Ipv4Mask_Type, &mask, &PyNs3Ipv4Address_Type, &base)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4AddressHelper(*((PyNs3Ipv4Address *) network)->obj, *((PyNs3Ipv4Mask *) mask)->obj, (base ? (*((PyNs3Ipv4Address *) base)->obj) : "0.0.0.1"));
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4AddressHelper__tp_init(PyNs3Ipv4AddressHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Ipv4AddressHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4AddressHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv4AddressHelper__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4AddressHelper_NewAddress(PyNs3Ipv4AddressHelper *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->NewAddress();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4AddressHelper_SetBase(PyNs3Ipv4AddressHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *network;
    PyNs3Ipv4Mask *mask;
    PyNs3Ipv4Address *base = NULL;
    const char *keywords[] = {"network", "mask", "base", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!|O!", (char **) keywords, &PyNs3Ipv4Address_Type, &network, &PyNs3Ipv4Mask_Type, &mask, &PyNs3Ipv4Address_Type, &base)) {
        return NULL;
    }
    self->obj->SetBase(*((PyNs3Ipv4Address *) network)->obj, *((PyNs3Ipv4Mask *) mask)->obj, (base ? (*((PyNs3Ipv4Address *) base)->obj) : "0.0.0.1"));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4AddressHelper_Assign(PyNs3Ipv4AddressHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDeviceContainer *c;
    const char *keywords[] = {"c", NULL};
    PyNs3Ipv4InterfaceContainer *py_Ipv4InterfaceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDeviceContainer_Type, &c)) {
        return NULL;
    }
    ns3::Ipv4InterfaceContainer retval = self->obj->Assign(*((PyNs3NetDeviceContainer *) c)->obj);
    py_Ipv4InterfaceContainer = PyObject_New(PyNs3Ipv4InterfaceContainer, &PyNs3Ipv4InterfaceContainer_Type);
    py_Ipv4InterfaceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4InterfaceContainer->obj = new ns3::Ipv4InterfaceContainer(retval);
    PyNs3Ipv4InterfaceContainer_wrapper_registry[(void *) py_Ipv4InterfaceContainer->obj] = (PyObject *) py_Ipv4InterfaceContainer;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4InterfaceContainer);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4AddressHelper_NewNetwork(PyNs3Ipv4AddressHelper *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->NewNetwork();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4AddressHelper__copy__(PyNs3Ipv4AddressHelper *self)
{

    PyNs3Ipv4AddressHelper *py_copy;
    py_copy = PyObject_New(PyNs3Ipv4AddressHelper, &PyNs3Ipv4AddressHelper_Type);
    py_copy->obj = new ns3::Ipv4AddressHelper(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv4AddressHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4AddressHelper_methods[] = {
    {(char *) "NewAddress", (PyCFunction) _wrap_PyNs3Ipv4AddressHelper_NewAddress, METH_NOARGS, NULL },
    {(char *) "SetBase", (PyCFunction) _wrap_PyNs3Ipv4AddressHelper_SetBase, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Assign", (PyCFunction) _wrap_PyNs3Ipv4AddressHelper_Assign, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NewNetwork", (PyCFunction) _wrap_PyNs3Ipv4AddressHelper_NewNetwork, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4AddressHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv4AddressHelper__tp_dealloc(PyNs3Ipv4AddressHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv4AddressHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv4AddressHelper_wrapper_registry.end()) {
        PyNs3Ipv4AddressHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv4AddressHelper *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4AddressHelper__tp_richcompare (PyNs3Ipv4AddressHelper *PYBINDGEN_UNUSED(self), PyNs3Ipv4AddressHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4AddressHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4AddressHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4AddressHelper",            /* tp_name */
    sizeof(PyNs3Ipv4AddressHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4AddressHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4AddressHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4AddressHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4AddressHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv4EndPoint_wrapper_registry;


static int
_wrap_PyNs3Ipv4EndPoint__tp_init__0(PyNs3Ipv4EndPoint *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4EndPoint *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4EndPoint_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4EndPoint(*((PyNs3Ipv4EndPoint *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4EndPoint__tp_init__1(PyNs3Ipv4EndPoint *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4Address *address;
    int port;
    const char *keywords[] = {"address", "port", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!i", (char **) keywords, &PyNs3Ipv4Address_Type, &address, &port)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (port > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4EndPoint(*((PyNs3Ipv4Address *) address)->obj, port);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4EndPoint__tp_init(PyNs3Ipv4EndPoint *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4EndPoint__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4EndPoint__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_ForwardUp(PyNs3Ipv4EndPoint *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv4Header *header;
    int sport;
    PyNs3Ipv4Interface *incomingInterface;
    ns3::Ipv4Interface *incomingInterface_ptr;
    const char *keywords[] = {"p", "header", "sport", "incomingInterface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!iO!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv4Header_Type, &header, &sport, &PyNs3Ipv4Interface_Type, &incomingInterface)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    if (sport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    incomingInterface_ptr = (incomingInterface ? incomingInterface->obj : NULL);
    self->obj->ForwardUp(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv4Header *) header)->obj, sport, ns3::Ptr< ns3::Ipv4Interface  > (incomingInterface_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_GetPeerPort(PyNs3Ipv4EndPoint *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetPeerPort();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_SetIcmpCallback(PyNs3Ipv4EndPoint *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *callback;
    ns3::Ptr<PythonCallbackImpl1> callback_cb_impl;
    const char *keywords[] = {"callback", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &callback)) {
        return NULL;
    }
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'callback' must be callbale");
        return NULL;
    }
    callback_cb_impl = ns3::Create<PythonCallbackImpl1> (callback);
    self->obj->SetIcmpCallback(ns3::Callback<void, ns3::Ipv4Address, unsigned char, unsigned char, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (callback_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_GetLocalAddress(PyNs3Ipv4EndPoint *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetLocalAddress();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_ForwardIcmp(PyNs3Ipv4EndPoint *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *icmpSource;
    int icmpTtl;
    int icmpType;
    int icmpCode;
    unsigned int icmpInfo;
    const char *keywords[] = {"icmpSource", "icmpTtl", "icmpType", "icmpCode", "icmpInfo", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!iiiI", (char **) keywords, &PyNs3Ipv4Address_Type, &icmpSource, &icmpTtl, &icmpType, &icmpCode, &icmpInfo)) {
        return NULL;
    }
    if (icmpTtl > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (icmpType > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (icmpCode > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->ForwardIcmp(*((PyNs3Ipv4Address *) icmpSource)->obj, icmpTtl, icmpType, icmpCode, icmpInfo);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_SetLocalAddress(PyNs3Ipv4EndPoint *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *address;
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &address)) {
        return NULL;
    }
    self->obj->SetLocalAddress(*((PyNs3Ipv4Address *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_BindToNetDevice(PyNs3Ipv4EndPoint *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *netdevice;
    ns3::NetDevice *netdevice_ptr;
    const char *keywords[] = {"netdevice", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &netdevice)) {
        return NULL;
    }
    netdevice_ptr = (netdevice ? netdevice->obj : NULL);
    self->obj->BindToNetDevice(ns3::Ptr< ns3::NetDevice  > (netdevice_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_SetRxCallback(PyNs3Ipv4EndPoint *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *callback;
    ns3::Ptr<PythonCallbackImpl2> callback_cb_impl;
    const char *keywords[] = {"callback", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &callback)) {
        return NULL;
    }
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'callback' must be callbale");
        return NULL;
    }
    callback_cb_impl = ns3::Create<PythonCallbackImpl2> (callback);
    self->obj->SetRxCallback(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::Ipv4Header, unsigned short, ns3::Ptr<ns3::Ipv4Interface>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (callback_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_GetPeerAddress(PyNs3Ipv4EndPoint *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetPeerAddress();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_SetPeer(PyNs3Ipv4EndPoint *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *address;
    int port;
    const char *keywords[] = {"address", "port", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!i", (char **) keywords, &PyNs3Ipv4Address_Type, &address, &port)) {
        return NULL;
    }
    if (port > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetPeer(*((PyNs3Ipv4Address *) address)->obj, port);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_GetLocalPort(PyNs3Ipv4EndPoint *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetLocalPort();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_SetDestroyCallback(PyNs3Ipv4EndPoint *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *callback;
    ns3::Ptr<PythonCallbackImpl0> callback_cb_impl;
    const char *keywords[] = {"callback", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &callback)) {
        return NULL;
    }
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'callback' must be callbale");
        return NULL;
    }
    callback_cb_impl = ns3::Create<PythonCallbackImpl0> (callback);
    self->obj->SetDestroyCallback(ns3::Callback<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (callback_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4EndPoint_GetBoundNetDevice(PyNs3Ipv4EndPoint *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetBoundNetDevice();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4EndPoint__copy__(PyNs3Ipv4EndPoint *self)
{

    PyNs3Ipv4EndPoint *py_copy;
    py_copy = PyObject_New(PyNs3Ipv4EndPoint, &PyNs3Ipv4EndPoint_Type);
    py_copy->obj = new ns3::Ipv4EndPoint(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv4EndPoint_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4EndPoint_methods[] = {
    {(char *) "ForwardUp", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_ForwardUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetPeerPort", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_GetPeerPort, METH_NOARGS, NULL },
    {(char *) "SetIcmpCallback", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_SetIcmpCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLocalAddress", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_GetLocalAddress, METH_NOARGS, NULL },
    {(char *) "ForwardIcmp", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_ForwardIcmp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetLocalAddress", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_SetLocalAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "BindToNetDevice", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_BindToNetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRxCallback", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_SetRxCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetPeerAddress", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_GetPeerAddress, METH_NOARGS, NULL },
    {(char *) "SetPeer", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_SetPeer, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLocalPort", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_GetLocalPort, METH_NOARGS, NULL },
    {(char *) "SetDestroyCallback", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_SetDestroyCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetBoundNetDevice", (PyCFunction) _wrap_PyNs3Ipv4EndPoint_GetBoundNetDevice, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4EndPoint__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv4EndPoint__tp_dealloc(PyNs3Ipv4EndPoint *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv4EndPoint_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv4EndPoint_wrapper_registry.end()) {
        PyNs3Ipv4EndPoint_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv4EndPoint *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4EndPoint__tp_richcompare (PyNs3Ipv4EndPoint *PYBINDGEN_UNUSED(self), PyNs3Ipv4EndPoint *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4EndPoint_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4EndPoint_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4EndPoint",            /* tp_name */
    sizeof(PyNs3Ipv4EndPoint),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4EndPoint__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4EndPoint__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4EndPoint_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4EndPoint__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv4InterfaceAddress_wrapper_registry;


static int
_wrap_PyNs3Ipv4InterfaceAddress__tp_init__0(PyNs3Ipv4InterfaceAddress *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4InterfaceAddress();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4InterfaceAddress__tp_init__1(PyNs3Ipv4InterfaceAddress *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4Address *local;
    PyNs3Ipv4Mask *mask;
    const char *keywords[] = {"local", "mask", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv4Address_Type, &local, &PyNs3Ipv4Mask_Type, &mask)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4InterfaceAddress(*((PyNs3Ipv4Address *) local)->obj, *((PyNs3Ipv4Mask *) mask)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4InterfaceAddress__tp_init__2(PyNs3Ipv4InterfaceAddress *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4InterfaceAddress *o;
    const char *keywords[] = {"o", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4InterfaceAddress_Type, &o)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4InterfaceAddress(*((PyNs3Ipv4InterfaceAddress *) o)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4InterfaceAddress__tp_init(PyNs3Ipv4InterfaceAddress *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Ipv4InterfaceAddress__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4InterfaceAddress__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv4InterfaceAddress__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceAddress_GetScope(PyNs3Ipv4InterfaceAddress *self)
{
    PyObject *py_retval;
    ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e retval;
    
    retval = self->obj->GetScope();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceAddress_GetBroadcast(PyNs3Ipv4InterfaceAddress *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetBroadcast();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceAddress_GetLocal(PyNs3Ipv4InterfaceAddress *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetLocal();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceAddress_SetPrimary(PyNs3Ipv4InterfaceAddress *self)
{
    PyObject *py_retval;
    
    self->obj->SetPrimary();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceAddress_SetMask(PyNs3Ipv4InterfaceAddress *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Mask *mask;
    const char *keywords[] = {"mask", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Mask_Type, &mask)) {
        return NULL;
    }
    self->obj->SetMask(*((PyNs3Ipv4Mask *) mask)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceAddress_SetLocal(PyNs3Ipv4InterfaceAddress *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *local;
    const char *keywords[] = {"local", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &local)) {
        return NULL;
    }
    self->obj->SetLocal(*((PyNs3Ipv4Address *) local)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceAddress_GetMask(PyNs3Ipv4InterfaceAddress *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Mask *py_Ipv4Mask;
    
    ns3::Ipv4Mask retval = self->obj->GetMask();
    py_Ipv4Mask = PyObject_New(PyNs3Ipv4Mask, &PyNs3Ipv4Mask_Type);
    py_Ipv4Mask->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Mask->obj = new ns3::Ipv4Mask(retval);
    PyNs3Ipv4Mask_wrapper_registry[(void *) py_Ipv4Mask->obj] = (PyObject *) py_Ipv4Mask;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Mask);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceAddress_SetScope(PyNs3Ipv4InterfaceAddress *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e scope;
    const char *keywords[] = {"scope", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &scope)) {
        return NULL;
    }
    self->obj->SetScope(scope);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceAddress_SetBroadcast(PyNs3Ipv4InterfaceAddress *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *broadcast;
    const char *keywords[] = {"broadcast", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &broadcast)) {
        return NULL;
    }
    self->obj->SetBroadcast(*((PyNs3Ipv4Address *) broadcast)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceAddress_SetSecondary(PyNs3Ipv4InterfaceAddress *self)
{
    PyObject *py_retval;
    
    self->obj->SetSecondary();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceAddress_IsSecondary(PyNs3Ipv4InterfaceAddress *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsSecondary();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4InterfaceAddress__copy__(PyNs3Ipv4InterfaceAddress *self)
{

    PyNs3Ipv4InterfaceAddress *py_copy;
    py_copy = PyObject_New(PyNs3Ipv4InterfaceAddress, &PyNs3Ipv4InterfaceAddress_Type);
    py_copy->obj = new ns3::Ipv4InterfaceAddress(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv4InterfaceAddress_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4InterfaceAddress_methods[] = {
    {(char *) "GetScope", (PyCFunction) _wrap_PyNs3Ipv4InterfaceAddress_GetScope, METH_NOARGS, NULL },
    {(char *) "GetBroadcast", (PyCFunction) _wrap_PyNs3Ipv4InterfaceAddress_GetBroadcast, METH_NOARGS, NULL },
    {(char *) "GetLocal", (PyCFunction) _wrap_PyNs3Ipv4InterfaceAddress_GetLocal, METH_NOARGS, NULL },
    {(char *) "SetPrimary", (PyCFunction) _wrap_PyNs3Ipv4InterfaceAddress_SetPrimary, METH_NOARGS, NULL },
    {(char *) "SetMask", (PyCFunction) _wrap_PyNs3Ipv4InterfaceAddress_SetMask, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetLocal", (PyCFunction) _wrap_PyNs3Ipv4InterfaceAddress_SetLocal, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMask", (PyCFunction) _wrap_PyNs3Ipv4InterfaceAddress_GetMask, METH_NOARGS, NULL },
    {(char *) "SetScope", (PyCFunction) _wrap_PyNs3Ipv4InterfaceAddress_SetScope, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetBroadcast", (PyCFunction) _wrap_PyNs3Ipv4InterfaceAddress_SetBroadcast, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetSecondary", (PyCFunction) _wrap_PyNs3Ipv4InterfaceAddress_SetSecondary, METH_NOARGS, NULL },
    {(char *) "IsSecondary", (PyCFunction) _wrap_PyNs3Ipv4InterfaceAddress_IsSecondary, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4InterfaceAddress__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv4InterfaceAddress__tp_dealloc(PyNs3Ipv4InterfaceAddress *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv4InterfaceAddress_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv4InterfaceAddress_wrapper_registry.end()) {
        PyNs3Ipv4InterfaceAddress_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv4InterfaceAddress *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyNs3Ipv4InterfaceAddress__tp_str(PyNs3Ipv4InterfaceAddress *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyNs3Ipv4InterfaceAddress__tp_richcompare (PyNs3Ipv4InterfaceAddress *PYBINDGEN_UNUSED(self), PyNs3Ipv4InterfaceAddress *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4InterfaceAddress_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        if (*self->obj == *other->obj) {
            Py_INCREF(Py_True);
            return Py_True;
        } else {
            Py_INCREF(Py_False);
            return Py_False;
        }
    case Py_NE:
        if (*self->obj != *other->obj) {
            Py_INCREF(Py_True);
            return Py_True;
        } else {
            Py_INCREF(Py_False);
            return Py_False;
        }
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4InterfaceAddress_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4InterfaceAddress",            /* tp_name */
    sizeof(PyNs3Ipv4InterfaceAddress),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4InterfaceAddress__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyNs3Ipv4InterfaceAddress__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4InterfaceAddress__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4InterfaceAddress_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4InterfaceAddress__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv4InterfaceContainer_wrapper_registry;


static int
_wrap_PyNs3Ipv4InterfaceContainer__tp_init__0(PyNs3Ipv4InterfaceContainer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4InterfaceContainer *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4InterfaceContainer_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4InterfaceContainer(*((PyNs3Ipv4InterfaceContainer *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4InterfaceContainer__tp_init__1(PyNs3Ipv4InterfaceContainer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4InterfaceContainer();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4InterfaceContainer__tp_init(PyNs3Ipv4InterfaceContainer *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4InterfaceContainer__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4InterfaceContainer__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}



PyObject *
_wrap_PyNs3Ipv4InterfaceContainer_Add__0(PyNs3Ipv4InterfaceContainer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4InterfaceContainer *other;
    const char *keywords[] = {"other", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4InterfaceContainer_Type, &other)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->Add(*((PyNs3Ipv4InterfaceContainer *) other)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4InterfaceContainer_Add__1(PyNs3Ipv4InterfaceContainer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    unsigned int interface;
    const char *keywords[] = {"ipv4", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3Ipv4_Type, &ipv4, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    self->obj->Add(ns3::Ptr< ns3::Ipv4  > (ipv4_ptr), interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4InterfaceContainer_Add__2(PyNs3Ipv4InterfaceContainer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *ipv4Name;
    Py_ssize_t ipv4Name_len;
    unsigned int interface;
    const char *keywords[] = {"ipv4Name", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#I", (char **) keywords, &ipv4Name, &ipv4Name_len, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->Add(std::string(ipv4Name, ipv4Name_len), interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv4InterfaceContainer_Add(PyNs3Ipv4InterfaceContainer *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Ipv4InterfaceContainer_Add__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4InterfaceContainer_Add__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv4InterfaceContainer_Add__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceContainer_GetN(PyNs3Ipv4InterfaceContainer *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetN();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceContainer_GetAddress(PyNs3Ipv4InterfaceContainer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    unsigned int j = 0;
    const char *keywords[] = {"i", "j", NULL};
    PyNs3Ipv4Address *py_Ipv4Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I|I", (char **) keywords, &i, &j)) {
        return NULL;
    }
    ns3::Ipv4Address retval = self->obj->GetAddress(i, j);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4InterfaceContainer_SetMetric(PyNs3Ipv4InterfaceContainer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    int metric;
    const char *keywords[] = {"i", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "Ii", (char **) keywords, &i, &metric)) {
        return NULL;
    }
    if (metric > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetMetric(i, metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4InterfaceContainer__copy__(PyNs3Ipv4InterfaceContainer *self)
{

    PyNs3Ipv4InterfaceContainer *py_copy;
    py_copy = PyObject_New(PyNs3Ipv4InterfaceContainer, &PyNs3Ipv4InterfaceContainer_Type);
    py_copy->obj = new ns3::Ipv4InterfaceContainer(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv4InterfaceContainer_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4InterfaceContainer_methods[] = {
    {(char *) "Add", (PyCFunction) _wrap_PyNs3Ipv4InterfaceContainer_Add, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetN", (PyCFunction) _wrap_PyNs3Ipv4InterfaceContainer_GetN, METH_NOARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv4InterfaceContainer_GetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetMetric", (PyCFunction) _wrap_PyNs3Ipv4InterfaceContainer_SetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4InterfaceContainer__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv4InterfaceContainer__tp_dealloc(PyNs3Ipv4InterfaceContainer *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv4InterfaceContainer_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv4InterfaceContainer_wrapper_registry.end()) {
        PyNs3Ipv4InterfaceContainer_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv4InterfaceContainer *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4InterfaceContainer__tp_richcompare (PyNs3Ipv4InterfaceContainer *PYBINDGEN_UNUSED(self), PyNs3Ipv4InterfaceContainer *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4InterfaceContainer_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4InterfaceContainer_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4InterfaceContainer",            /* tp_name */
    sizeof(PyNs3Ipv4InterfaceContainer),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4InterfaceContainer__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4InterfaceContainer__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4InterfaceContainer_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4InterfaceContainer__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv4MulticastRoutingTableEntry_wrapper_registry;


static int
_wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_init__0(PyNs3Ipv4MulticastRoutingTableEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4MulticastRoutingTableEntry();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_init__1(PyNs3Ipv4MulticastRoutingTableEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4MulticastRoutingTableEntry *route;
    const char *keywords[] = {"route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4MulticastRoutingTableEntry_Type, &route)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4MulticastRoutingTableEntry(*((PyNs3Ipv4MulticastRoutingTableEntry *) route)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_init__2(PyNs3Ipv4MulticastRoutingTableEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4MulticastRoutingTableEntry *route;
    ns3::Ipv4MulticastRoutingTableEntry *route_ptr;
    const char *keywords[] = {"route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4MulticastRoutingTableEntry_Type, &route)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    route_ptr = (route ? route->obj : NULL);
    self->obj = new ns3::Ipv4MulticastRoutingTableEntry(route_ptr);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_init(PyNs3Ipv4MulticastRoutingTableEntry *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoutingTableEntry_GetOutputInterface(PyNs3Ipv4MulticastRoutingTableEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->GetOutputInterface(n);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoutingTableEntry_GetOrigin(PyNs3Ipv4MulticastRoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetOrigin();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoutingTableEntry_GetInputInterface(PyNs3Ipv4MulticastRoutingTableEntry *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetInputInterface();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoutingTableEntry_CreateMulticastRoute(PyNs3Ipv4MulticastRoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *origin;
    PyNs3Ipv4Address *group;
    unsigned int inputInterface;
    std::vector< unsigned int > outputInterfaces_value;
    const char *keywords[] = {"origin", "group", "inputInterface", "outputInterfaces", NULL};
    PyNs3Ipv4MulticastRoutingTableEntry *py_Ipv4MulticastRoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!IO&", (char **) keywords, &PyNs3Ipv4Address_Type, &origin, &PyNs3Ipv4Address_Type, &group, &inputInterface, _wrap_convert_py2c__std__vector__lt___unsigned_int___gt__, &outputInterfaces_value)) {
        return NULL;
    }
    ns3::Ipv4MulticastRoutingTableEntry retval = ns3::Ipv4MulticastRoutingTableEntry::CreateMulticastRoute(*((PyNs3Ipv4Address *) origin)->obj, *((PyNs3Ipv4Address *) group)->obj, inputInterface, outputInterfaces_value);
    py_Ipv4MulticastRoutingTableEntry = PyObject_New(PyNs3Ipv4MulticastRoutingTableEntry, &PyNs3Ipv4MulticastRoutingTableEntry_Type);
    py_Ipv4MulticastRoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4MulticastRoutingTableEntry->obj = new ns3::Ipv4MulticastRoutingTableEntry(retval);
    PyNs3Ipv4MulticastRoutingTableEntry_wrapper_registry[(void *) py_Ipv4MulticastRoutingTableEntry->obj] = (PyObject *) py_Ipv4MulticastRoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4MulticastRoutingTableEntry);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoutingTableEntry_GetNOutputInterfaces(PyNs3Ipv4MulticastRoutingTableEntry *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNOutputInterfaces();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoutingTableEntry_GetOutputInterfaces(PyNs3Ipv4MulticastRoutingTableEntry *self)
{
    PyObject *py_retval;
    std::vector< unsigned int > retval;
    Pystd__vector__lt___unsigned_int___gt__ *py_std__vector__lt___unsigned_int___gt__;
    
    retval = self->obj->GetOutputInterfaces();
    py_std__vector__lt___unsigned_int___gt__ = PyObject_New(Pystd__vector__lt___unsigned_int___gt__, &Pystd__vector__lt___unsigned_int___gt___Type);
    py_std__vector__lt___unsigned_int___gt__->obj = new std::vector< unsigned int >(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__vector__lt___unsigned_int___gt__);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoutingTableEntry_GetGroup(PyNs3Ipv4MulticastRoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetGroup();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4MulticastRoutingTableEntry__copy__(PyNs3Ipv4MulticastRoutingTableEntry *self)
{

    PyNs3Ipv4MulticastRoutingTableEntry *py_copy;
    py_copy = PyObject_New(PyNs3Ipv4MulticastRoutingTableEntry, &PyNs3Ipv4MulticastRoutingTableEntry_Type);
    py_copy->obj = new ns3::Ipv4MulticastRoutingTableEntry(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv4MulticastRoutingTableEntry_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4MulticastRoutingTableEntry_methods[] = {
    {(char *) "GetOutputInterface", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoutingTableEntry_GetOutputInterface, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOrigin", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoutingTableEntry_GetOrigin, METH_NOARGS, NULL },
    {(char *) "GetInputInterface", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoutingTableEntry_GetInputInterface, METH_NOARGS, NULL },
    {(char *) "CreateMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoutingTableEntry_CreateMulticastRoute, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "GetNOutputInterfaces", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoutingTableEntry_GetNOutputInterfaces, METH_NOARGS, NULL },
    {(char *) "GetOutputInterfaces", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoutingTableEntry_GetOutputInterfaces, METH_NOARGS, NULL },
    {(char *) "GetGroup", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoutingTableEntry_GetGroup, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoutingTableEntry__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_dealloc(PyNs3Ipv4MulticastRoutingTableEntry *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv4MulticastRoutingTableEntry_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv4MulticastRoutingTableEntry_wrapper_registry.end()) {
        PyNs3Ipv4MulticastRoutingTableEntry_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv4MulticastRoutingTableEntry *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_str(PyNs3Ipv4MulticastRoutingTableEntry *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_richcompare (PyNs3Ipv4MulticastRoutingTableEntry *PYBINDGEN_UNUSED(self), PyNs3Ipv4MulticastRoutingTableEntry *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4MulticastRoutingTableEntry_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4MulticastRoutingTableEntry_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4MulticastRoutingTableEntry",            /* tp_name */
    sizeof(PyNs3Ipv4MulticastRoutingTableEntry),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4MulticastRoutingTableEntry_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4MulticastRoutingTableEntry__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv4RoutingHelper_wrapper_registry;

static int
_wrap_PyNs3Ipv4RoutingHelper__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'Ipv4RoutingHelper' cannot be constructed (have pure virtual methods but no helper class)");
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4RoutingHelper_PrintRoutingTableAllEvery(PyNs3Ipv4RoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Time *printInterval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"printInterval", "stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Time_Type, &printInterval, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTableAllEvery(*((PyNs3Time *) printInterval)->obj, ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingHelper_PrintRoutingTableAllAt(PyNs3Ipv4RoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Time *printTime;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"printTime", "stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Time_Type, &printTime, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTableAllAt(*((PyNs3Time *) printTime)->obj, ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingHelper_Create(PyNs3Ipv4RoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4RoutingProtocol > retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    PyNs3Ipv4RoutingProtocol *py_Ipv4RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    retval = self->obj->Create(ns3::Ptr< ns3::Node  > (node_ptr));
    if (!(const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv4RoutingProtocol = NULL;
    } else {
        py_Ipv4RoutingProtocol = (PyNs3Ipv4RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4RoutingProtocol);
    }
    
    if (py_Ipv4RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4RoutingProtocol_Type);
        py_Ipv4RoutingProtocol = PyObject_GC_New(PyNs3Ipv4RoutingProtocol, wrapper_type);
        py_Ipv4RoutingProtocol->inst_dict = NULL;
        py_Ipv4RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4RoutingProtocol->obj = const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4RoutingProtocol->obj] = (PyObject *) py_Ipv4RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingProtocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingHelper_PrintRoutingTableEvery(PyNs3Ipv4RoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Time *printInterval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"printInterval", "node", "stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3Time_Type, &printInterval, &PyNs3Node_Type, &node, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTableEvery(*((PyNs3Time *) printInterval)->obj, ns3::Ptr< ns3::Node  > (node_ptr), ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingHelper_PrintRoutingTableAt(PyNs3Ipv4RoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Time *printTime;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"printTime", "node", "stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3Time_Type, &printTime, &PyNs3Node_Type, &node, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTableAt(*((PyNs3Time *) printTime)->obj, ns3::Ptr< ns3::Node  > (node_ptr), ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3Ipv4RoutingHelper_methods[] = {
    {(char *) "PrintRoutingTableAllEvery", (PyCFunction) _wrap_PyNs3Ipv4RoutingHelper_PrintRoutingTableAllEvery, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTableAllAt", (PyCFunction) _wrap_PyNs3Ipv4RoutingHelper_PrintRoutingTableAllAt, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Create", (PyCFunction) _wrap_PyNs3Ipv4RoutingHelper_Create, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTableEvery", (PyCFunction) _wrap_PyNs3Ipv4RoutingHelper_PrintRoutingTableEvery, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTableAt", (PyCFunction) _wrap_PyNs3Ipv4RoutingHelper_PrintRoutingTableAt, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4RoutingHelper__tp_clear(PyNs3Ipv4RoutingHelper *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv4RoutingHelper *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv4RoutingHelper__tp_traverse(PyNs3Ipv4RoutingHelper *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv4RoutingHelper__tp_dealloc(PyNs3Ipv4RoutingHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv4RoutingHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv4RoutingHelper_wrapper_registry.end()) {
        PyNs3Ipv4RoutingHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4RoutingHelper__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4RoutingHelper__tp_richcompare (PyNs3Ipv4RoutingHelper *PYBINDGEN_UNUSED(self), PyNs3Ipv4RoutingHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4RoutingHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4RoutingHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4RoutingHelper",            /* tp_name */
    sizeof(PyNs3Ipv4RoutingHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4RoutingHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4RoutingHelper__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4RoutingHelper__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4RoutingHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4RoutingHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4RoutingHelper, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4RoutingHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv4RoutingTableEntry_wrapper_registry;


static int
_wrap_PyNs3Ipv4RoutingTableEntry__tp_init__0(PyNs3Ipv4RoutingTableEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4RoutingTableEntry();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4RoutingTableEntry__tp_init__1(PyNs3Ipv4RoutingTableEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4RoutingTableEntry *route;
    const char *keywords[] = {"route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4RoutingTableEntry_Type, &route)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4RoutingTableEntry(*((PyNs3Ipv4RoutingTableEntry *) route)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4RoutingTableEntry__tp_init__2(PyNs3Ipv4RoutingTableEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4RoutingTableEntry *route;
    ns3::Ipv4RoutingTableEntry *route_ptr;
    const char *keywords[] = {"route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4RoutingTableEntry_Type, &route)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    route_ptr = (route ? route->obj : NULL);
    self->obj = new ns3::Ipv4RoutingTableEntry(route_ptr);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4RoutingTableEntry__tp_init(PyNs3Ipv4RoutingTableEntry *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Ipv4RoutingTableEntry__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4RoutingTableEntry__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv4RoutingTableEntry__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_IsNetwork(PyNs3Ipv4RoutingTableEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsNetwork();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_IsGateway(PyNs3Ipv4RoutingTableEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsGateway();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_GetGateway(PyNs3Ipv4RoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetGateway();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_IsHost(PyNs3Ipv4RoutingTableEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsHost();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_GetDestNetwork(PyNs3Ipv4RoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetDestNetwork();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_CreateNetworkRouteTo__0(PyNs3Ipv4RoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *network;
    PyNs3Ipv4Mask *networkMask;
    PyNs3Ipv4Address *nextHop;
    unsigned int interface;
    const char *keywords[] = {"network", "networkMask", "nextHop", "interface", NULL};
    PyNs3Ipv4RoutingTableEntry *py_Ipv4RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &network, &PyNs3Ipv4Mask_Type, &networkMask, &PyNs3Ipv4Address_Type, &nextHop, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv4RoutingTableEntry retval = ns3::Ipv4RoutingTableEntry::CreateNetworkRouteTo(*((PyNs3Ipv4Address *) network)->obj, *((PyNs3Ipv4Mask *) networkMask)->obj, *((PyNs3Ipv4Address *) nextHop)->obj, interface);
    py_Ipv4RoutingTableEntry = PyObject_New(PyNs3Ipv4RoutingTableEntry, &PyNs3Ipv4RoutingTableEntry_Type);
    py_Ipv4RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4RoutingTableEntry->obj = new ns3::Ipv4RoutingTableEntry(retval);
    PyNs3Ipv4RoutingTableEntry_wrapper_registry[(void *) py_Ipv4RoutingTableEntry->obj] = (PyObject *) py_Ipv4RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingTableEntry);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_CreateNetworkRouteTo__1(PyNs3Ipv4RoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *network;
    PyNs3Ipv4Mask *networkMask;
    unsigned int interface;
    const char *keywords[] = {"network", "networkMask", "interface", NULL};
    PyNs3Ipv4RoutingTableEntry *py_Ipv4RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &network, &PyNs3Ipv4Mask_Type, &networkMask, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv4RoutingTableEntry retval = ns3::Ipv4RoutingTableEntry::CreateNetworkRouteTo(*((PyNs3Ipv4Address *) network)->obj, *((PyNs3Ipv4Mask *) networkMask)->obj, interface);
    py_Ipv4RoutingTableEntry = PyObject_New(PyNs3Ipv4RoutingTableEntry, &PyNs3Ipv4RoutingTableEntry_Type);
    py_Ipv4RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4RoutingTableEntry->obj = new ns3::Ipv4RoutingTableEntry(retval);
    PyNs3Ipv4RoutingTableEntry_wrapper_registry[(void *) py_Ipv4RoutingTableEntry->obj] = (PyObject *) py_Ipv4RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingTableEntry);
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv4RoutingTableEntry_CreateNetworkRouteTo(PyNs3Ipv4RoutingTableEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4RoutingTableEntry_CreateNetworkRouteTo__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4RoutingTableEntry_CreateNetworkRouteTo__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_GetDestNetworkMask(PyNs3Ipv4RoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Mask *py_Ipv4Mask;
    
    ns3::Ipv4Mask retval = self->obj->GetDestNetworkMask();
    py_Ipv4Mask = PyObject_New(PyNs3Ipv4Mask, &PyNs3Ipv4Mask_Type);
    py_Ipv4Mask->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Mask->obj = new ns3::Ipv4Mask(retval);
    PyNs3Ipv4Mask_wrapper_registry[(void *) py_Ipv4Mask->obj] = (PyObject *) py_Ipv4Mask;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Mask);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_GetInterface(PyNs3Ipv4RoutingTableEntry *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetInterface();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_CreateHostRouteTo__0(PyNs3Ipv4RoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *dest;
    PyNs3Ipv4Address *nextHop;
    unsigned int interface;
    const char *keywords[] = {"dest", "nextHop", "interface", NULL};
    PyNs3Ipv4RoutingTableEntry *py_Ipv4RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &dest, &PyNs3Ipv4Address_Type, &nextHop, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv4RoutingTableEntry retval = ns3::Ipv4RoutingTableEntry::CreateHostRouteTo(*((PyNs3Ipv4Address *) dest)->obj, *((PyNs3Ipv4Address *) nextHop)->obj, interface);
    py_Ipv4RoutingTableEntry = PyObject_New(PyNs3Ipv4RoutingTableEntry, &PyNs3Ipv4RoutingTableEntry_Type);
    py_Ipv4RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4RoutingTableEntry->obj = new ns3::Ipv4RoutingTableEntry(retval);
    PyNs3Ipv4RoutingTableEntry_wrapper_registry[(void *) py_Ipv4RoutingTableEntry->obj] = (PyObject *) py_Ipv4RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingTableEntry);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_CreateHostRouteTo__1(PyNs3Ipv4RoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *dest;
    unsigned int interface;
    const char *keywords[] = {"dest", "interface", NULL};
    PyNs3Ipv4RoutingTableEntry *py_Ipv4RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &dest, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv4RoutingTableEntry retval = ns3::Ipv4RoutingTableEntry::CreateHostRouteTo(*((PyNs3Ipv4Address *) dest)->obj, interface);
    py_Ipv4RoutingTableEntry = PyObject_New(PyNs3Ipv4RoutingTableEntry, &PyNs3Ipv4RoutingTableEntry_Type);
    py_Ipv4RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4RoutingTableEntry->obj = new ns3::Ipv4RoutingTableEntry(retval);
    PyNs3Ipv4RoutingTableEntry_wrapper_registry[(void *) py_Ipv4RoutingTableEntry->obj] = (PyObject *) py_Ipv4RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingTableEntry);
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv4RoutingTableEntry_CreateHostRouteTo(PyNs3Ipv4RoutingTableEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4RoutingTableEntry_CreateHostRouteTo__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4RoutingTableEntry_CreateHostRouteTo__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_CreateDefaultRoute(PyNs3Ipv4RoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *nextHop;
    unsigned int interface;
    const char *keywords[] = {"nextHop", "interface", NULL};
    PyNs3Ipv4RoutingTableEntry *py_Ipv4RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &nextHop, &interface)) {
        return NULL;
    }
    ns3::Ipv4RoutingTableEntry retval = ns3::Ipv4RoutingTableEntry::CreateDefaultRoute(*((PyNs3Ipv4Address *) nextHop)->obj, interface);
    py_Ipv4RoutingTableEntry = PyObject_New(PyNs3Ipv4RoutingTableEntry, &PyNs3Ipv4RoutingTableEntry_Type);
    py_Ipv4RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4RoutingTableEntry->obj = new ns3::Ipv4RoutingTableEntry(retval);
    PyNs3Ipv4RoutingTableEntry_wrapper_registry[(void *) py_Ipv4RoutingTableEntry->obj] = (PyObject *) py_Ipv4RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingTableEntry);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_IsDefault(PyNs3Ipv4RoutingTableEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsDefault();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry_GetDest(PyNs3Ipv4RoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetDest();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4RoutingTableEntry__copy__(PyNs3Ipv4RoutingTableEntry *self)
{

    PyNs3Ipv4RoutingTableEntry *py_copy;
    py_copy = PyObject_New(PyNs3Ipv4RoutingTableEntry, &PyNs3Ipv4RoutingTableEntry_Type);
    py_copy->obj = new ns3::Ipv4RoutingTableEntry(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv4RoutingTableEntry_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4RoutingTableEntry_methods[] = {
    {(char *) "IsNetwork", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry_IsNetwork, METH_NOARGS, NULL },
    {(char *) "IsGateway", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry_IsGateway, METH_NOARGS, NULL },
    {(char *) "GetGateway", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry_GetGateway, METH_NOARGS, NULL },
    {(char *) "IsHost", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry_IsHost, METH_NOARGS, NULL },
    {(char *) "GetDestNetwork", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry_GetDestNetwork, METH_NOARGS, NULL },
    {(char *) "CreateNetworkRouteTo", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry_CreateNetworkRouteTo, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "GetDestNetworkMask", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry_GetDestNetworkMask, METH_NOARGS, NULL },
    {(char *) "GetInterface", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry_GetInterface, METH_NOARGS, NULL },
    {(char *) "CreateHostRouteTo", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry_CreateHostRouteTo, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "CreateDefaultRoute", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry_CreateDefaultRoute, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "IsDefault", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry_IsDefault, METH_NOARGS, NULL },
    {(char *) "GetDest", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry_GetDest, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4RoutingTableEntry__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv4RoutingTableEntry__tp_dealloc(PyNs3Ipv4RoutingTableEntry *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv4RoutingTableEntry_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv4RoutingTableEntry_wrapper_registry.end()) {
        PyNs3Ipv4RoutingTableEntry_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv4RoutingTableEntry *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyNs3Ipv4RoutingTableEntry__tp_str(PyNs3Ipv4RoutingTableEntry *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyNs3Ipv4RoutingTableEntry__tp_richcompare (PyNs3Ipv4RoutingTableEntry *PYBINDGEN_UNUSED(self), PyNs3Ipv4RoutingTableEntry *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4RoutingTableEntry_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4RoutingTableEntry_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4RoutingTableEntry",            /* tp_name */
    sizeof(PyNs3Ipv4RoutingTableEntry),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4RoutingTableEntry__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyNs3Ipv4RoutingTableEntry__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4RoutingTableEntry__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4RoutingTableEntry_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4RoutingTableEntry__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv4StaticRoutingHelper__tp_init__0(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4StaticRoutingHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4StaticRoutingHelper__tp_init__1(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4StaticRoutingHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4StaticRoutingHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4StaticRoutingHelper(*((PyNs3Ipv4StaticRoutingHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4StaticRoutingHelper__tp_init(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4StaticRoutingHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4StaticRoutingHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}



PyObject *
_wrap_PyNs3Ipv4StaticRoutingHelper_AddMulticastRoute__0(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Node *n;
    ns3::Node *n_ptr;
    PyNs3Ipv4Address *source;
    PyNs3Ipv4Address *group;
    PyNs3NetDevice *input;
    ns3::NetDevice *input_ptr;
    PyNs3NetDeviceContainer *output;
    const char *keywords[] = {"n", "source", "group", "input", "output", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!O!O!", (char **) keywords, &PyNs3Node_Type, &n, &PyNs3Ipv4Address_Type, &source, &PyNs3Ipv4Address_Type, &group, &PyNs3NetDevice_Type, &input, &PyNs3NetDeviceContainer_Type, &output)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    n_ptr = (n ? n->obj : NULL);
    input_ptr = (input ? input->obj : NULL);
    self->obj->AddMulticastRoute(ns3::Ptr< ns3::Node  > (n_ptr), *((PyNs3Ipv4Address *) source)->obj, *((PyNs3Ipv4Address *) group)->obj, ns3::Ptr< ns3::NetDevice  > (input_ptr), *((PyNs3NetDeviceContainer *) output)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4StaticRoutingHelper_AddMulticastRoute__1(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *n;
    Py_ssize_t n_len;
    PyNs3Ipv4Address *source;
    PyNs3Ipv4Address *group;
    PyNs3NetDevice *input;
    ns3::NetDevice *input_ptr;
    PyNs3NetDeviceContainer *output;
    const char *keywords[] = {"n", "source", "group", "input", "output", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!O!O!O!", (char **) keywords, &n, &n_len, &PyNs3Ipv4Address_Type, &source, &PyNs3Ipv4Address_Type, &group, &PyNs3NetDevice_Type, &input, &PyNs3NetDeviceContainer_Type, &output)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    input_ptr = (input ? input->obj : NULL);
    self->obj->AddMulticastRoute(std::string(n, n_len), *((PyNs3Ipv4Address *) source)->obj, *((PyNs3Ipv4Address *) group)->obj, ns3::Ptr< ns3::NetDevice  > (input_ptr), *((PyNs3NetDeviceContainer *) output)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4StaticRoutingHelper_AddMulticastRoute__2(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Node *n;
    ns3::Node *n_ptr;
    PyNs3Ipv4Address *source;
    PyNs3Ipv4Address *group;
    const char *inputName;
    Py_ssize_t inputName_len;
    PyNs3NetDeviceContainer *output;
    const char *keywords[] = {"n", "source", "group", "inputName", "output", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!s#O!", (char **) keywords, &PyNs3Node_Type, &n, &PyNs3Ipv4Address_Type, &source, &PyNs3Ipv4Address_Type, &group, &inputName, &inputName_len, &PyNs3NetDeviceContainer_Type, &output)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    n_ptr = (n ? n->obj : NULL);
    self->obj->AddMulticastRoute(ns3::Ptr< ns3::Node  > (n_ptr), *((PyNs3Ipv4Address *) source)->obj, *((PyNs3Ipv4Address *) group)->obj, std::string(inputName, inputName_len), *((PyNs3NetDeviceContainer *) output)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4StaticRoutingHelper_AddMulticastRoute__3(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *nName;
    Py_ssize_t nName_len;
    PyNs3Ipv4Address *source;
    PyNs3Ipv4Address *group;
    const char *inputName;
    Py_ssize_t inputName_len;
    PyNs3NetDeviceContainer *output;
    const char *keywords[] = {"nName", "source", "group", "inputName", "output", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!O!s#O!", (char **) keywords, &nName, &nName_len, &PyNs3Ipv4Address_Type, &source, &PyNs3Ipv4Address_Type, &group, &inputName, &inputName_len, &PyNs3NetDeviceContainer_Type, &output)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddMulticastRoute(std::string(nName, nName_len), *((PyNs3Ipv4Address *) source)->obj, *((PyNs3Ipv4Address *) group)->obj, std::string(inputName, inputName_len), *((PyNs3NetDeviceContainer *) output)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv4StaticRoutingHelper_AddMulticastRoute(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[4] = {0,};
    retval = _wrap_PyNs3Ipv4StaticRoutingHelper_AddMulticastRoute__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4StaticRoutingHelper_AddMulticastRoute__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv4StaticRoutingHelper_AddMulticastRoute__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv4StaticRoutingHelper_AddMulticastRoute__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    error_list = PyList_New(4);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv4StaticRoutingHelper_Create(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4RoutingProtocol > retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    PyNs3Ipv4RoutingProtocol *py_Ipv4RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    retval = self->obj->Create(ns3::Ptr< ns3::Node  > (node_ptr));
    if (!(const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv4RoutingProtocol = NULL;
    } else {
        py_Ipv4RoutingProtocol = (PyNs3Ipv4RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4RoutingProtocol);
    }
    
    if (py_Ipv4RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4RoutingProtocol_Type);
        py_Ipv4RoutingProtocol = PyObject_GC_New(PyNs3Ipv4RoutingProtocol, wrapper_type);
        py_Ipv4RoutingProtocol->inst_dict = NULL;
        py_Ipv4RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4RoutingProtocol->obj = const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4RoutingProtocol->obj] = (PyObject *) py_Ipv4RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingProtocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRoutingHelper_GetStaticRouting(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4StaticRouting > retval;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    const char *keywords[] = {"ipv4", NULL};
    PyNs3Ipv4StaticRouting *py_Ipv4StaticRouting;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4_Type, &ipv4)) {
        return NULL;
    }
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    retval = self->obj->GetStaticRouting(ns3::Ptr< ns3::Ipv4  > (ipv4_ptr));
    if (!(const_cast<ns3::Ipv4StaticRouting *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4StaticRouting *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv4StaticRouting = NULL;
    } else {
        py_Ipv4StaticRouting = (PyNs3Ipv4StaticRouting *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4StaticRouting);
    }
    
    if (py_Ipv4StaticRouting == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4StaticRouting *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4StaticRouting_Type);
        py_Ipv4StaticRouting = PyObject_GC_New(PyNs3Ipv4StaticRouting, wrapper_type);
        py_Ipv4StaticRouting->inst_dict = NULL;
        py_Ipv4StaticRouting->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4StaticRouting *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4StaticRouting->obj = const_cast<ns3::Ipv4StaticRouting *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4StaticRouting->obj] = (PyObject *) py_Ipv4StaticRouting;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4StaticRouting);
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv4StaticRoutingHelper_SetDefaultMulticastRoute__0(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Node *n;
    ns3::Node *n_ptr;
    PyNs3NetDevice *nd;
    ns3::NetDevice *nd_ptr;
    const char *keywords[] = {"n", "nd", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Node_Type, &n, &PyNs3NetDevice_Type, &nd)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    n_ptr = (n ? n->obj : NULL);
    nd_ptr = (nd ? nd->obj : NULL);
    self->obj->SetDefaultMulticastRoute(ns3::Ptr< ns3::Node  > (n_ptr), ns3::Ptr< ns3::NetDevice  > (nd_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4StaticRoutingHelper_SetDefaultMulticastRoute__1(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Node *n;
    ns3::Node *n_ptr;
    const char *ndName;
    Py_ssize_t ndName_len;
    const char *keywords[] = {"n", "ndName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#", (char **) keywords, &PyNs3Node_Type, &n, &ndName, &ndName_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    n_ptr = (n ? n->obj : NULL);
    self->obj->SetDefaultMulticastRoute(ns3::Ptr< ns3::Node  > (n_ptr), std::string(ndName, ndName_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4StaticRoutingHelper_SetDefaultMulticastRoute__2(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *nName;
    Py_ssize_t nName_len;
    PyNs3NetDevice *nd;
    ns3::NetDevice *nd_ptr;
    const char *keywords[] = {"nName", "nd", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &nName, &nName_len, &PyNs3NetDevice_Type, &nd)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    nd_ptr = (nd ? nd->obj : NULL);
    self->obj->SetDefaultMulticastRoute(std::string(nName, nName_len), ns3::Ptr< ns3::NetDevice  > (nd_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4StaticRoutingHelper_SetDefaultMulticastRoute__3(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *nName;
    Py_ssize_t nName_len;
    const char *ndName;
    Py_ssize_t ndName_len;
    const char *keywords[] = {"nName", "ndName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#", (char **) keywords, &nName, &nName_len, &ndName, &ndName_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->SetDefaultMulticastRoute(std::string(nName, nName_len), std::string(ndName, ndName_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv4StaticRoutingHelper_SetDefaultMulticastRoute(PyNs3Ipv4StaticRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[4] = {0,};
    retval = _wrap_PyNs3Ipv4StaticRoutingHelper_SetDefaultMulticastRoute__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4StaticRoutingHelper_SetDefaultMulticastRoute__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv4StaticRoutingHelper_SetDefaultMulticastRoute__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv4StaticRoutingHelper_SetDefaultMulticastRoute__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    error_list = PyList_New(4);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


static PyObject*
_wrap_PyNs3Ipv4StaticRoutingHelper__copy__(PyNs3Ipv4StaticRoutingHelper *self)
{

    PyNs3Ipv4StaticRoutingHelper *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv4StaticRoutingHelper, &PyNs3Ipv4StaticRoutingHelper_Type);
    py_copy->obj = new ns3::Ipv4StaticRoutingHelper(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv4RoutingHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4StaticRoutingHelper_methods[] = {
    {(char *) "AddMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv4StaticRoutingHelper_AddMulticastRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Create", (PyCFunction) _wrap_PyNs3Ipv4StaticRoutingHelper_Create, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetStaticRouting", (PyCFunction) _wrap_PyNs3Ipv4StaticRoutingHelper_GetStaticRouting, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDefaultMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv4StaticRoutingHelper_SetDefaultMulticastRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4StaticRoutingHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4StaticRoutingHelper__tp_clear(PyNs3Ipv4StaticRoutingHelper *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv4StaticRoutingHelper *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv4StaticRoutingHelper__tp_traverse(PyNs3Ipv4StaticRoutingHelper *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv4StaticRoutingHelper__tp_dealloc(PyNs3Ipv4StaticRoutingHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv4RoutingHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv4RoutingHelper_wrapper_registry.end()) {
        PyNs3Ipv4RoutingHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4StaticRoutingHelper__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4StaticRoutingHelper__tp_richcompare (PyNs3Ipv4StaticRoutingHelper *PYBINDGEN_UNUSED(self), PyNs3Ipv4StaticRoutingHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4StaticRoutingHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4StaticRoutingHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4StaticRoutingHelper",            /* tp_name */
    sizeof(PyNs3Ipv4StaticRoutingHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4StaticRoutingHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4StaticRoutingHelper__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4StaticRoutingHelper__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4StaticRoutingHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4StaticRoutingHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4StaticRoutingHelper, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4StaticRoutingHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv6AddressGenerator_wrapper_registry;


static int
_wrap_PyNs3Ipv6AddressGenerator__tp_init__0(PyNs3Ipv6AddressGenerator *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6AddressGenerator();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6AddressGenerator__tp_init__1(PyNs3Ipv6AddressGenerator *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6AddressGenerator *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6AddressGenerator_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6AddressGenerator(*((PyNs3Ipv6AddressGenerator *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6AddressGenerator__tp_init(PyNs3Ipv6AddressGenerator *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6AddressGenerator__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6AddressGenerator__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6AddressGenerator_Reset(void)
{
    PyObject *py_retval;
    
    ns3::Ipv6AddressGenerator::Reset();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6AddressGenerator_NextNetwork(PyNs3Ipv6AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Prefix *prefix;
    const char *keywords[] = {"prefix", NULL};
    PyNs3Ipv6Address *py_Ipv6Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Prefix_Type, &prefix)) {
        return NULL;
    }
    ns3::Ipv6Address retval = ns3::Ipv6AddressGenerator::NextNetwork(*((PyNs3Ipv6Prefix *) prefix)->obj);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6AddressGenerator_GetAddress(PyNs3Ipv6AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Prefix *prefix;
    const char *keywords[] = {"prefix", NULL};
    PyNs3Ipv6Address *py_Ipv6Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Prefix_Type, &prefix)) {
        return NULL;
    }
    ns3::Ipv6Address retval = ns3::Ipv6AddressGenerator::GetAddress(*((PyNs3Ipv6Prefix *) prefix)->obj);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6AddressGenerator_AddAllocated(PyNs3Ipv6AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv6Address *addr;
    const char *keywords[] = {"addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &addr)) {
        return NULL;
    }
    retval = ns3::Ipv6AddressGenerator::AddAllocated(*((PyNs3Ipv6Address *) addr)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6AddressGenerator_Init(PyNs3Ipv6AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *net;
    PyNs3Ipv6Prefix *prefix;
    PyNs3Ipv6Address *interfaceId = NULL;
    const char *keywords[] = {"net", "prefix", "interfaceId", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!|O!", (char **) keywords, &PyNs3Ipv6Address_Type, &net, &PyNs3Ipv6Prefix_Type, &prefix, &PyNs3Ipv6Address_Type, &interfaceId)) {
        return NULL;
    }
    ns3::Ipv6AddressGenerator::Init(*((PyNs3Ipv6Address *) net)->obj, *((PyNs3Ipv6Prefix *) prefix)->obj, (interfaceId ? (*((PyNs3Ipv6Address *) interfaceId)->obj) : "::1"));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6AddressGenerator_InitAddress(PyNs3Ipv6AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *interfaceId;
    PyNs3Ipv6Prefix *prefix;
    const char *keywords[] = {"interfaceId", "prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv6Address_Type, &interfaceId, &PyNs3Ipv6Prefix_Type, &prefix)) {
        return NULL;
    }
    ns3::Ipv6AddressGenerator::InitAddress(*((PyNs3Ipv6Address *) interfaceId)->obj, *((PyNs3Ipv6Prefix *) prefix)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6AddressGenerator_GetNetwork(PyNs3Ipv6AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Prefix *prefix;
    const char *keywords[] = {"prefix", NULL};
    PyNs3Ipv6Address *py_Ipv6Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Prefix_Type, &prefix)) {
        return NULL;
    }
    ns3::Ipv6Address retval = ns3::Ipv6AddressGenerator::GetNetwork(*((PyNs3Ipv6Prefix *) prefix)->obj);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6AddressGenerator_NextAddress(PyNs3Ipv6AddressGenerator *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Prefix *prefix;
    const char *keywords[] = {"prefix", NULL};
    PyNs3Ipv6Address *py_Ipv6Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Prefix_Type, &prefix)) {
        return NULL;
    }
    ns3::Ipv6Address retval = ns3::Ipv6AddressGenerator::NextAddress(*((PyNs3Ipv6Prefix *) prefix)->obj);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6AddressGenerator_TestMode(void)
{
    PyObject *py_retval;
    
    ns3::Ipv6AddressGenerator::TestMode();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6AddressGenerator__copy__(PyNs3Ipv6AddressGenerator *self)
{

    PyNs3Ipv6AddressGenerator *py_copy;
    py_copy = PyObject_New(PyNs3Ipv6AddressGenerator, &PyNs3Ipv6AddressGenerator_Type);
    py_copy->obj = new ns3::Ipv6AddressGenerator(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv6AddressGenerator_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6AddressGenerator_methods[] = {
    {(char *) "Reset", (PyCFunction) _wrap_PyNs3Ipv6AddressGenerator_Reset, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "NextNetwork", (PyCFunction) _wrap_PyNs3Ipv6AddressGenerator_NextNetwork, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv6AddressGenerator_GetAddress, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "AddAllocated", (PyCFunction) _wrap_PyNs3Ipv6AddressGenerator_AddAllocated, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "Init", (PyCFunction) _wrap_PyNs3Ipv6AddressGenerator_Init, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "InitAddress", (PyCFunction) _wrap_PyNs3Ipv6AddressGenerator_InitAddress, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "GetNetwork", (PyCFunction) _wrap_PyNs3Ipv6AddressGenerator_GetNetwork, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "NextAddress", (PyCFunction) _wrap_PyNs3Ipv6AddressGenerator_NextAddress, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "TestMode", (PyCFunction) _wrap_PyNs3Ipv6AddressGenerator_TestMode, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6AddressGenerator__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv6AddressGenerator__tp_dealloc(PyNs3Ipv6AddressGenerator *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv6AddressGenerator_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv6AddressGenerator_wrapper_registry.end()) {
        PyNs3Ipv6AddressGenerator_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv6AddressGenerator *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6AddressGenerator__tp_richcompare (PyNs3Ipv6AddressGenerator *PYBINDGEN_UNUSED(self), PyNs3Ipv6AddressGenerator *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6AddressGenerator_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6AddressGenerator_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6AddressGenerator",            /* tp_name */
    sizeof(PyNs3Ipv6AddressGenerator),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6AddressGenerator__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6AddressGenerator__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6AddressGenerator_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6AddressGenerator__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv6AddressHelper_wrapper_registry;


static int
_wrap_PyNs3Ipv6AddressHelper__tp_init__0(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6AddressHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6AddressHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6AddressHelper(*((PyNs3Ipv6AddressHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6AddressHelper__tp_init__1(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6AddressHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6AddressHelper__tp_init__2(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6Address *network;
    PyNs3Ipv6Prefix *prefix;
    PyNs3Ipv6Address *base = NULL;
    const char *keywords[] = {"network", "prefix", "base", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!|O!", (char **) keywords, &PyNs3Ipv6Address_Type, &network, &PyNs3Ipv6Prefix_Type, &prefix, &PyNs3Ipv6Address_Type, &base)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6AddressHelper(*((PyNs3Ipv6Address *) network)->obj, *((PyNs3Ipv6Prefix *) prefix)->obj, (base ? (*((PyNs3Ipv6Address *) base)->obj) : ns3::Ipv6Address(((const char*)"::1"))));
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6AddressHelper__tp_init(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Ipv6AddressHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6AddressHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv6AddressHelper__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}



PyObject *
_wrap_PyNs3Ipv6AddressHelper_NewAddress__0(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyObject *addr;
    ns3::Address addr2;
    const char *keywords[] = {"addr", NULL};
    PyNs3Ipv6Address *py_Ipv6Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &addr)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (PyObject_IsInstance(addr, (PyObject*) &PyNs3Address_Type)) {
        addr2 = *((PyNs3Address *) addr)->obj;
    } else if (PyObject_IsInstance(addr, (PyObject*) &PyNs3Ipv4Address_Type)) {
        addr2 = *((PyNs3Ipv4Address *) addr)->obj;
    } else if (PyObject_IsInstance(addr, (PyObject*) &PyNs3Ipv6Address_Type)) {
        addr2 = *((PyNs3Ipv6Address *) addr)->obj;
    } else if (PyObject_IsInstance(addr, (PyObject*) &PyNs3Mac48Address_Type)) {
        addr2 = *((PyNs3Mac48Address *) addr)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", addr->ob_type->tp_name);
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv6Address retval = self->obj->NewAddress(addr2);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6AddressHelper_NewAddress__1(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    PyNs3Ipv6Address *py_Ipv6Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv6Address retval = self->obj->NewAddress();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv6AddressHelper_NewAddress(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6AddressHelper_NewAddress__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6AddressHelper_NewAddress__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv6AddressHelper_SetBase(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *network;
    PyNs3Ipv6Prefix *prefix;
    PyNs3Ipv6Address *base = NULL;
    const char *keywords[] = {"network", "prefix", "base", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!|O!", (char **) keywords, &PyNs3Ipv6Address_Type, &network, &PyNs3Ipv6Prefix_Type, &prefix, &PyNs3Ipv6Address_Type, &base)) {
        return NULL;
    }
    self->obj->SetBase(*((PyNs3Ipv6Address *) network)->obj, *((PyNs3Ipv6Prefix *) prefix)->obj, (base ? (*((PyNs3Ipv6Address *) base)->obj) : ns3::Ipv6Address(((const char*)"::1"))));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6AddressHelper_AssignWithoutAddress(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDeviceContainer *c;
    const char *keywords[] = {"c", NULL};
    PyNs3Ipv6InterfaceContainer *py_Ipv6InterfaceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDeviceContainer_Type, &c)) {
        return NULL;
    }
    ns3::Ipv6InterfaceContainer retval = self->obj->AssignWithoutAddress(*((PyNs3NetDeviceContainer *) c)->obj);
    py_Ipv6InterfaceContainer = PyObject_New(PyNs3Ipv6InterfaceContainer, &PyNs3Ipv6InterfaceContainer_Type);
    py_Ipv6InterfaceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6InterfaceContainer->obj = new ns3::Ipv6InterfaceContainer(retval);
    PyNs3Ipv6InterfaceContainer_wrapper_registry[(void *) py_Ipv6InterfaceContainer->obj] = (PyObject *) py_Ipv6InterfaceContainer;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6InterfaceContainer);
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv6AddressHelper_Assign__0(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3NetDeviceContainer *c;
    const char *keywords[] = {"c", NULL};
    PyNs3Ipv6InterfaceContainer *py_Ipv6InterfaceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDeviceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv6InterfaceContainer retval = self->obj->Assign(*((PyNs3NetDeviceContainer *) c)->obj);
    py_Ipv6InterfaceContainer = PyObject_New(PyNs3Ipv6InterfaceContainer, &PyNs3Ipv6InterfaceContainer_Type);
    py_Ipv6InterfaceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6InterfaceContainer->obj = new ns3::Ipv6InterfaceContainer(retval);
    PyNs3Ipv6InterfaceContainer_wrapper_registry[(void *) py_Ipv6InterfaceContainer->obj] = (PyObject *) py_Ipv6InterfaceContainer;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6InterfaceContainer);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6AddressHelper_Assign__1(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3NetDeviceContainer *c;
    std::vector< bool > withConfiguration_value;
    const char *keywords[] = {"c", "withConfiguration", NULL};
    PyNs3Ipv6InterfaceContainer *py_Ipv6InterfaceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O&", (char **) keywords, &PyNs3NetDeviceContainer_Type, &c, _wrap_convert_py2c__std__vector__lt___bool___gt__, &withConfiguration_value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv6InterfaceContainer retval = self->obj->Assign(*((PyNs3NetDeviceContainer *) c)->obj, withConfiguration_value);
    py_Ipv6InterfaceContainer = PyObject_New(PyNs3Ipv6InterfaceContainer, &PyNs3Ipv6InterfaceContainer_Type);
    py_Ipv6InterfaceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6InterfaceContainer->obj = new ns3::Ipv6InterfaceContainer(retval);
    PyNs3Ipv6InterfaceContainer_wrapper_registry[(void *) py_Ipv6InterfaceContainer->obj] = (PyObject *) py_Ipv6InterfaceContainer;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6InterfaceContainer);
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv6AddressHelper_Assign(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6AddressHelper_Assign__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6AddressHelper_Assign__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}



PyObject *
_wrap_PyNs3Ipv6AddressHelper_NewNetwork__0(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *network;
    PyNs3Ipv6Prefix *prefix;
    const char *keywords[] = {"network", "prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv6Address_Type, &network, &PyNs3Ipv6Prefix_Type, &prefix)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (PyErr_Warn(PyExc_DeprecationWarning, (char *) "Deprecated")) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->NewNetwork(*((PyNs3Ipv6Address *) network)->obj, *((PyNs3Ipv6Prefix *) prefix)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6AddressHelper_NewNetwork__1(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->NewNetwork();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv6AddressHelper_NewNetwork(PyNs3Ipv6AddressHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6AddressHelper_NewNetwork__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6AddressHelper_NewNetwork__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


static PyObject*
_wrap_PyNs3Ipv6AddressHelper__copy__(PyNs3Ipv6AddressHelper *self)
{

    PyNs3Ipv6AddressHelper *py_copy;
    py_copy = PyObject_New(PyNs3Ipv6AddressHelper, &PyNs3Ipv6AddressHelper_Type);
    py_copy->obj = new ns3::Ipv6AddressHelper(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv6AddressHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6AddressHelper_methods[] = {
    {(char *) "NewAddress", (PyCFunction) _wrap_PyNs3Ipv6AddressHelper_NewAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetBase", (PyCFunction) _wrap_PyNs3Ipv6AddressHelper_SetBase, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AssignWithoutAddress", (PyCFunction) _wrap_PyNs3Ipv6AddressHelper_AssignWithoutAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Assign", (PyCFunction) _wrap_PyNs3Ipv6AddressHelper_Assign, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NewNetwork", (PyCFunction) _wrap_PyNs3Ipv6AddressHelper_NewNetwork, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6AddressHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv6AddressHelper__tp_dealloc(PyNs3Ipv6AddressHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv6AddressHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv6AddressHelper_wrapper_registry.end()) {
        PyNs3Ipv6AddressHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv6AddressHelper *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6AddressHelper__tp_richcompare (PyNs3Ipv6AddressHelper *PYBINDGEN_UNUSED(self), PyNs3Ipv6AddressHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6AddressHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6AddressHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6AddressHelper",            /* tp_name */
    sizeof(PyNs3Ipv6AddressHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6AddressHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6AddressHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6AddressHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6AddressHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv6InterfaceAddress_wrapper_registry;


static int
_wrap_PyNs3Ipv6InterfaceAddress__tp_init__0(PyNs3Ipv6InterfaceAddress *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6InterfaceAddress();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6InterfaceAddress__tp_init__1(PyNs3Ipv6InterfaceAddress *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6Address *address;
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &address)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6InterfaceAddress(*((PyNs3Ipv6Address *) address)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6InterfaceAddress__tp_init__2(PyNs3Ipv6InterfaceAddress *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6Address *address;
    PyNs3Ipv6Prefix *prefix;
    const char *keywords[] = {"address", "prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv6Address_Type, &address, &PyNs3Ipv6Prefix_Type, &prefix)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6InterfaceAddress(*((PyNs3Ipv6Address *) address)->obj, *((PyNs3Ipv6Prefix *) prefix)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6InterfaceAddress__tp_init__3(PyNs3Ipv6InterfaceAddress *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6InterfaceAddress *o;
    const char *keywords[] = {"o", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6InterfaceAddress_Type, &o)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6InterfaceAddress(*((PyNs3Ipv6InterfaceAddress *) o)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6InterfaceAddress__tp_init(PyNs3Ipv6InterfaceAddress *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[4] = {0,};
    retval = _wrap_PyNs3Ipv6InterfaceAddress__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6InterfaceAddress__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv6InterfaceAddress__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv6InterfaceAddress__tp_init__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    error_list = PyList_New(4);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceAddress_GetScope(PyNs3Ipv6InterfaceAddress *self)
{
    PyObject *py_retval;
    ns3::Ipv6InterfaceAddress::Scope_e retval;
    
    retval = self->obj->GetScope();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceAddress_GetState(PyNs3Ipv6InterfaceAddress *self)
{
    PyObject *py_retval;
    ns3::Ipv6InterfaceAddress::State_e retval;
    
    retval = self->obj->GetState();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceAddress_SetNsDadUid(PyNs3Ipv6InterfaceAddress *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int uid;
    const char *keywords[] = {"uid", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &uid)) {
        return NULL;
    }
    self->obj->SetNsDadUid(uid);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceAddress_GetAddress(PyNs3Ipv6InterfaceAddress *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetAddress();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceAddress_GetPrefix(PyNs3Ipv6InterfaceAddress *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Prefix *py_Ipv6Prefix;
    
    ns3::Ipv6Prefix retval = self->obj->GetPrefix();
    py_Ipv6Prefix = PyObject_New(PyNs3Ipv6Prefix, &PyNs3Ipv6Prefix_Type);
    py_Ipv6Prefix->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Prefix->obj = new ns3::Ipv6Prefix(retval);
    PyNs3Ipv6Prefix_wrapper_registry[(void *) py_Ipv6Prefix->obj] = (PyObject *) py_Ipv6Prefix;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Prefix);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceAddress_SetScope(PyNs3Ipv6InterfaceAddress *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ipv6InterfaceAddress::Scope_e scope;
    const char *keywords[] = {"scope", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &scope)) {
        return NULL;
    }
    self->obj->SetScope(scope);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceAddress_GetNsDadUid(PyNs3Ipv6InterfaceAddress *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNsDadUid();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceAddress_SetAddress(PyNs3Ipv6InterfaceAddress *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *address;
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &address)) {
        return NULL;
    }
    self->obj->SetAddress(*((PyNs3Ipv6Address *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceAddress_SetState(PyNs3Ipv6InterfaceAddress *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ipv6InterfaceAddress::State_e state;
    const char *keywords[] = {"state", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &state)) {
        return NULL;
    }
    self->obj->SetState(state);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6InterfaceAddress__copy__(PyNs3Ipv6InterfaceAddress *self)
{

    PyNs3Ipv6InterfaceAddress *py_copy;
    py_copy = PyObject_New(PyNs3Ipv6InterfaceAddress, &PyNs3Ipv6InterfaceAddress_Type);
    py_copy->obj = new ns3::Ipv6InterfaceAddress(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv6InterfaceAddress_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6InterfaceAddress_methods[] = {
    {(char *) "GetScope", (PyCFunction) _wrap_PyNs3Ipv6InterfaceAddress_GetScope, METH_NOARGS, NULL },
    {(char *) "GetState", (PyCFunction) _wrap_PyNs3Ipv6InterfaceAddress_GetState, METH_NOARGS, NULL },
    {(char *) "SetNsDadUid", (PyCFunction) _wrap_PyNs3Ipv6InterfaceAddress_SetNsDadUid, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv6InterfaceAddress_GetAddress, METH_NOARGS, NULL },
    {(char *) "GetPrefix", (PyCFunction) _wrap_PyNs3Ipv6InterfaceAddress_GetPrefix, METH_NOARGS, NULL },
    {(char *) "SetScope", (PyCFunction) _wrap_PyNs3Ipv6InterfaceAddress_SetScope, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNsDadUid", (PyCFunction) _wrap_PyNs3Ipv6InterfaceAddress_GetNsDadUid, METH_NOARGS, NULL },
    {(char *) "SetAddress", (PyCFunction) _wrap_PyNs3Ipv6InterfaceAddress_SetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetState", (PyCFunction) _wrap_PyNs3Ipv6InterfaceAddress_SetState, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6InterfaceAddress__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv6InterfaceAddress__tp_dealloc(PyNs3Ipv6InterfaceAddress *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv6InterfaceAddress_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv6InterfaceAddress_wrapper_registry.end()) {
        PyNs3Ipv6InterfaceAddress_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv6InterfaceAddress *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyNs3Ipv6InterfaceAddress__tp_str(PyNs3Ipv6InterfaceAddress *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyNs3Ipv6InterfaceAddress__tp_richcompare (PyNs3Ipv6InterfaceAddress *PYBINDGEN_UNUSED(self), PyNs3Ipv6InterfaceAddress *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6InterfaceAddress_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        if (*self->obj == *other->obj) {
            Py_INCREF(Py_True);
            return Py_True;
        } else {
            Py_INCREF(Py_False);
            return Py_False;
        }
    case Py_NE:
        if (*self->obj != *other->obj) {
            Py_INCREF(Py_True);
            return Py_True;
        } else {
            Py_INCREF(Py_False);
            return Py_False;
        }
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6InterfaceAddress_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6InterfaceAddress",            /* tp_name */
    sizeof(PyNs3Ipv6InterfaceAddress),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6InterfaceAddress__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyNs3Ipv6InterfaceAddress__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6InterfaceAddress__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6InterfaceAddress_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6InterfaceAddress__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv6InterfaceContainer_wrapper_registry;


static int
_wrap_PyNs3Ipv6InterfaceContainer__tp_init__0(PyNs3Ipv6InterfaceContainer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6InterfaceContainer *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6InterfaceContainer_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6InterfaceContainer(*((PyNs3Ipv6InterfaceContainer *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6InterfaceContainer__tp_init__1(PyNs3Ipv6InterfaceContainer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6InterfaceContainer();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6InterfaceContainer__tp_init(PyNs3Ipv6InterfaceContainer *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6InterfaceContainer__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6InterfaceContainer__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceContainer_GetInterfaceIndex(PyNs3Ipv6InterfaceContainer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = self->obj->GetInterfaceIndex(i);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceContainer_GetN(PyNs3Ipv6InterfaceContainer *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetN();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceContainer_GetAddress(PyNs3Ipv6InterfaceContainer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    unsigned int j;
    const char *keywords[] = {"i", "j", NULL};
    PyNs3Ipv6Address *py_Ipv6Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &i, &j)) {
        return NULL;
    }
    ns3::Ipv6Address retval = self->obj->GetAddress(i, j);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv6InterfaceContainer_Add__0(PyNs3Ipv6InterfaceContainer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    unsigned int interface;
    const char *keywords[] = {"ipv6", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3Ipv6_Type, &ipv6, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    self->obj->Add(ns3::Ptr< ns3::Ipv6  > (ipv6_ptr), interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6InterfaceContainer_Add__1(PyNs3Ipv6InterfaceContainer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6InterfaceContainer *c;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->Add(*((PyNs3Ipv6InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6InterfaceContainer_Add__2(PyNs3Ipv6InterfaceContainer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *ipv6Name;
    Py_ssize_t ipv6Name_len;
    unsigned int interface;
    const char *keywords[] = {"ipv6Name", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#I", (char **) keywords, &ipv6Name, &ipv6Name_len, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->Add(std::string(ipv6Name, ipv6Name_len), interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv6InterfaceContainer_Add(PyNs3Ipv6InterfaceContainer *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Ipv6InterfaceContainer_Add__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6InterfaceContainer_Add__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv6InterfaceContainer_Add__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceContainer_SetRouter(PyNs3Ipv6InterfaceContainer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    bool router;
    PyObject *py_router;
    const char *keywords[] = {"i", "router", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO", (char **) keywords, &i, &py_router)) {
        return NULL;
    }
    router = (bool) PyObject_IsTrue(py_router);
    self->obj->SetRouter(i, router);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6InterfaceContainer_SetDefaultRoute(PyNs3Ipv6InterfaceContainer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    unsigned int router;
    const char *keywords[] = {"i", "router", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &i, &router)) {
        return NULL;
    }
    self->obj->SetDefaultRoute(i, router);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6InterfaceContainer__copy__(PyNs3Ipv6InterfaceContainer *self)
{

    PyNs3Ipv6InterfaceContainer *py_copy;
    py_copy = PyObject_New(PyNs3Ipv6InterfaceContainer, &PyNs3Ipv6InterfaceContainer_Type);
    py_copy->obj = new ns3::Ipv6InterfaceContainer(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv6InterfaceContainer_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6InterfaceContainer_methods[] = {
    {(char *) "GetInterfaceIndex", (PyCFunction) _wrap_PyNs3Ipv6InterfaceContainer_GetInterfaceIndex, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetN", (PyCFunction) _wrap_PyNs3Ipv6InterfaceContainer_GetN, METH_NOARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv6InterfaceContainer_GetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Add", (PyCFunction) _wrap_PyNs3Ipv6InterfaceContainer_Add, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRouter", (PyCFunction) _wrap_PyNs3Ipv6InterfaceContainer_SetRouter, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDefaultRoute", (PyCFunction) _wrap_PyNs3Ipv6InterfaceContainer_SetDefaultRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6InterfaceContainer__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv6InterfaceContainer__tp_dealloc(PyNs3Ipv6InterfaceContainer *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv6InterfaceContainer_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv6InterfaceContainer_wrapper_registry.end()) {
        PyNs3Ipv6InterfaceContainer_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv6InterfaceContainer *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6InterfaceContainer__tp_richcompare (PyNs3Ipv6InterfaceContainer *PYBINDGEN_UNUSED(self), PyNs3Ipv6InterfaceContainer *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6InterfaceContainer_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6InterfaceContainer_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6InterfaceContainer",            /* tp_name */
    sizeof(PyNs3Ipv6InterfaceContainer),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6InterfaceContainer__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6InterfaceContainer__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6InterfaceContainer_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6InterfaceContainer__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv6MulticastRoutingTableEntry_wrapper_registry;


static int
_wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_init__0(PyNs3Ipv6MulticastRoutingTableEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6MulticastRoutingTableEntry();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_init__1(PyNs3Ipv6MulticastRoutingTableEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6MulticastRoutingTableEntry *route;
    const char *keywords[] = {"route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6MulticastRoutingTableEntry_Type, &route)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6MulticastRoutingTableEntry(*((PyNs3Ipv6MulticastRoutingTableEntry *) route)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_init__2(PyNs3Ipv6MulticastRoutingTableEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6MulticastRoutingTableEntry *route;
    ns3::Ipv6MulticastRoutingTableEntry *route_ptr;
    const char *keywords[] = {"route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6MulticastRoutingTableEntry_Type, &route)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    route_ptr = (route ? route->obj : NULL);
    self->obj = new ns3::Ipv6MulticastRoutingTableEntry(route_ptr);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_init(PyNs3Ipv6MulticastRoutingTableEntry *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoutingTableEntry_GetOutputInterface(PyNs3Ipv6MulticastRoutingTableEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    unsigned int n;
    const char *keywords[] = {"n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &n)) {
        return NULL;
    }
    retval = self->obj->GetOutputInterface(n);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoutingTableEntry_GetOrigin(PyNs3Ipv6MulticastRoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetOrigin();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoutingTableEntry_GetInputInterface(PyNs3Ipv6MulticastRoutingTableEntry *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetInputInterface();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoutingTableEntry_CreateMulticastRoute(PyNs3Ipv6MulticastRoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *origin;
    PyNs3Ipv6Address *group;
    unsigned int inputInterface;
    std::vector< unsigned int > outputInterfaces_value;
    const char *keywords[] = {"origin", "group", "inputInterface", "outputInterfaces", NULL};
    PyNs3Ipv6MulticastRoutingTableEntry *py_Ipv6MulticastRoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!IO&", (char **) keywords, &PyNs3Ipv6Address_Type, &origin, &PyNs3Ipv6Address_Type, &group, &inputInterface, _wrap_convert_py2c__std__vector__lt___unsigned_int___gt__, &outputInterfaces_value)) {
        return NULL;
    }
    ns3::Ipv6MulticastRoutingTableEntry retval = ns3::Ipv6MulticastRoutingTableEntry::CreateMulticastRoute(*((PyNs3Ipv6Address *) origin)->obj, *((PyNs3Ipv6Address *) group)->obj, inputInterface, outputInterfaces_value);
    py_Ipv6MulticastRoutingTableEntry = PyObject_New(PyNs3Ipv6MulticastRoutingTableEntry, &PyNs3Ipv6MulticastRoutingTableEntry_Type);
    py_Ipv6MulticastRoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6MulticastRoutingTableEntry->obj = new ns3::Ipv6MulticastRoutingTableEntry(retval);
    PyNs3Ipv6MulticastRoutingTableEntry_wrapper_registry[(void *) py_Ipv6MulticastRoutingTableEntry->obj] = (PyObject *) py_Ipv6MulticastRoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6MulticastRoutingTableEntry);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoutingTableEntry_GetNOutputInterfaces(PyNs3Ipv6MulticastRoutingTableEntry *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNOutputInterfaces();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoutingTableEntry_GetOutputInterfaces(PyNs3Ipv6MulticastRoutingTableEntry *self)
{
    PyObject *py_retval;
    std::vector< unsigned int > retval;
    Pystd__vector__lt___unsigned_int___gt__ *py_std__vector__lt___unsigned_int___gt__;
    
    retval = self->obj->GetOutputInterfaces();
    py_std__vector__lt___unsigned_int___gt__ = PyObject_New(Pystd__vector__lt___unsigned_int___gt__, &Pystd__vector__lt___unsigned_int___gt___Type);
    py_std__vector__lt___unsigned_int___gt__->obj = new std::vector< unsigned int >(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__vector__lt___unsigned_int___gt__);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoutingTableEntry_GetGroup(PyNs3Ipv6MulticastRoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetGroup();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6MulticastRoutingTableEntry__copy__(PyNs3Ipv6MulticastRoutingTableEntry *self)
{

    PyNs3Ipv6MulticastRoutingTableEntry *py_copy;
    py_copy = PyObject_New(PyNs3Ipv6MulticastRoutingTableEntry, &PyNs3Ipv6MulticastRoutingTableEntry_Type);
    py_copy->obj = new ns3::Ipv6MulticastRoutingTableEntry(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv6MulticastRoutingTableEntry_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6MulticastRoutingTableEntry_methods[] = {
    {(char *) "GetOutputInterface", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoutingTableEntry_GetOutputInterface, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOrigin", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoutingTableEntry_GetOrigin, METH_NOARGS, NULL },
    {(char *) "GetInputInterface", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoutingTableEntry_GetInputInterface, METH_NOARGS, NULL },
    {(char *) "CreateMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoutingTableEntry_CreateMulticastRoute, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "GetNOutputInterfaces", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoutingTableEntry_GetNOutputInterfaces, METH_NOARGS, NULL },
    {(char *) "GetOutputInterfaces", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoutingTableEntry_GetOutputInterfaces, METH_NOARGS, NULL },
    {(char *) "GetGroup", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoutingTableEntry_GetGroup, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoutingTableEntry__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_dealloc(PyNs3Ipv6MulticastRoutingTableEntry *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv6MulticastRoutingTableEntry_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv6MulticastRoutingTableEntry_wrapper_registry.end()) {
        PyNs3Ipv6MulticastRoutingTableEntry_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv6MulticastRoutingTableEntry *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_str(PyNs3Ipv6MulticastRoutingTableEntry *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_richcompare (PyNs3Ipv6MulticastRoutingTableEntry *PYBINDGEN_UNUSED(self), PyNs3Ipv6MulticastRoutingTableEntry *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6MulticastRoutingTableEntry_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6MulticastRoutingTableEntry_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6MulticastRoutingTableEntry",            /* tp_name */
    sizeof(PyNs3Ipv6MulticastRoutingTableEntry),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6MulticastRoutingTableEntry_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6MulticastRoutingTableEntry__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv6RoutingHelper_wrapper_registry;

static int
_wrap_PyNs3Ipv6RoutingHelper__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'Ipv6RoutingHelper' cannot be constructed (have pure virtual methods but no helper class)");
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6RoutingHelper_PrintRoutingTableAllEvery(PyNs3Ipv6RoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Time *printInterval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"printInterval", "stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Time_Type, &printInterval, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTableAllEvery(*((PyNs3Time *) printInterval)->obj, ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingHelper_PrintRoutingTableAllAt(PyNs3Ipv6RoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Time *printTime;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"printTime", "stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Time_Type, &printTime, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTableAllAt(*((PyNs3Time *) printTime)->obj, ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingHelper_Create(PyNs3Ipv6RoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6RoutingProtocol > retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    PyNs3Ipv6RoutingProtocol *py_Ipv6RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    retval = self->obj->Create(ns3::Ptr< ns3::Node  > (node_ptr));
    if (!(const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv6RoutingProtocol = NULL;
    } else {
        py_Ipv6RoutingProtocol = (PyNs3Ipv6RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6RoutingProtocol);
    }
    
    if (py_Ipv6RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6RoutingProtocol_Type);
        py_Ipv6RoutingProtocol = PyObject_GC_New(PyNs3Ipv6RoutingProtocol, wrapper_type);
        py_Ipv6RoutingProtocol->inst_dict = NULL;
        py_Ipv6RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv6RoutingProtocol->obj = const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6RoutingProtocol->obj] = (PyObject *) py_Ipv6RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingProtocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingHelper_PrintRoutingTableEvery(PyNs3Ipv6RoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Time *printInterval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"printInterval", "node", "stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3Time_Type, &printInterval, &PyNs3Node_Type, &node, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTableEvery(*((PyNs3Time *) printInterval)->obj, ns3::Ptr< ns3::Node  > (node_ptr), ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingHelper_PrintRoutingTableAt(PyNs3Ipv6RoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Time *printTime;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"printTime", "node", "stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3Time_Type, &printTime, &PyNs3Node_Type, &node, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTableAt(*((PyNs3Time *) printTime)->obj, ns3::Ptr< ns3::Node  > (node_ptr), ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3Ipv6RoutingHelper_methods[] = {
    {(char *) "PrintRoutingTableAllEvery", (PyCFunction) _wrap_PyNs3Ipv6RoutingHelper_PrintRoutingTableAllEvery, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTableAllAt", (PyCFunction) _wrap_PyNs3Ipv6RoutingHelper_PrintRoutingTableAllAt, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Create", (PyCFunction) _wrap_PyNs3Ipv6RoutingHelper_Create, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTableEvery", (PyCFunction) _wrap_PyNs3Ipv6RoutingHelper_PrintRoutingTableEvery, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTableAt", (PyCFunction) _wrap_PyNs3Ipv6RoutingHelper_PrintRoutingTableAt, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6RoutingHelper__tp_clear(PyNs3Ipv6RoutingHelper *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6RoutingHelper *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6RoutingHelper__tp_traverse(PyNs3Ipv6RoutingHelper *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6RoutingHelper__tp_dealloc(PyNs3Ipv6RoutingHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv6RoutingHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv6RoutingHelper_wrapper_registry.end()) {
        PyNs3Ipv6RoutingHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6RoutingHelper__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6RoutingHelper__tp_richcompare (PyNs3Ipv6RoutingHelper *PYBINDGEN_UNUSED(self), PyNs3Ipv6RoutingHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6RoutingHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6RoutingHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6RoutingHelper",            /* tp_name */
    sizeof(PyNs3Ipv6RoutingHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6RoutingHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6RoutingHelper__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6RoutingHelper__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6RoutingHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6RoutingHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6RoutingHelper, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6RoutingHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv6RoutingTableEntry_wrapper_registry;


static int
_wrap_PyNs3Ipv6RoutingTableEntry__tp_init__0(PyNs3Ipv6RoutingTableEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6RoutingTableEntry();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6RoutingTableEntry__tp_init__1(PyNs3Ipv6RoutingTableEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6RoutingTableEntry *route;
    const char *keywords[] = {"route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6RoutingTableEntry_Type, &route)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6RoutingTableEntry(*((PyNs3Ipv6RoutingTableEntry *) route)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6RoutingTableEntry__tp_init__2(PyNs3Ipv6RoutingTableEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6RoutingTableEntry *route;
    ns3::Ipv6RoutingTableEntry *route_ptr;
    const char *keywords[] = {"route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6RoutingTableEntry_Type, &route)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    route_ptr = (route ? route->obj : NULL);
    self->obj = new ns3::Ipv6RoutingTableEntry(route_ptr);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6RoutingTableEntry__tp_init(PyNs3Ipv6RoutingTableEntry *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Ipv6RoutingTableEntry__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6RoutingTableEntry__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv6RoutingTableEntry__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_GetDestNetworkPrefix(PyNs3Ipv6RoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Prefix *py_Ipv6Prefix;
    
    ns3::Ipv6Prefix retval = self->obj->GetDestNetworkPrefix();
    py_Ipv6Prefix = PyObject_New(PyNs3Ipv6Prefix, &PyNs3Ipv6Prefix_Type);
    py_Ipv6Prefix->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Prefix->obj = new ns3::Ipv6Prefix(retval);
    PyNs3Ipv6Prefix_wrapper_registry[(void *) py_Ipv6Prefix->obj] = (PyObject *) py_Ipv6Prefix;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Prefix);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_IsNetwork(PyNs3Ipv6RoutingTableEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsNetwork();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_GetPrefixToUse(PyNs3Ipv6RoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetPrefixToUse();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_IsGateway(PyNs3Ipv6RoutingTableEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsGateway();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_GetGateway(PyNs3Ipv6RoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetGateway();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_SetPrefixToUse(PyNs3Ipv6RoutingTableEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *prefix;
    const char *keywords[] = {"prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &prefix)) {
        return NULL;
    }
    self->obj->SetPrefixToUse(*((PyNs3Ipv6Address *) prefix)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_GetDestNetwork(PyNs3Ipv6RoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetDestNetwork();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_CreateNetworkRouteTo__0(PyNs3Ipv6RoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *network;
    PyNs3Ipv6Prefix *networkPrefix;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    const char *keywords[] = {"network", "networkPrefix", "nextHop", "interface", NULL};
    PyNs3Ipv6RoutingTableEntry *py_Ipv6RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!I", (char **) keywords, &PyNs3Ipv6Address_Type, &network, &PyNs3Ipv6Prefix_Type, &networkPrefix, &PyNs3Ipv6Address_Type, &nextHop, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv6RoutingTableEntry retval = ns3::Ipv6RoutingTableEntry::CreateNetworkRouteTo(*((PyNs3Ipv6Address *) network)->obj, *((PyNs3Ipv6Prefix *) networkPrefix)->obj, *((PyNs3Ipv6Address *) nextHop)->obj, interface);
    py_Ipv6RoutingTableEntry = PyObject_New(PyNs3Ipv6RoutingTableEntry, &PyNs3Ipv6RoutingTableEntry_Type);
    py_Ipv6RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6RoutingTableEntry->obj = new ns3::Ipv6RoutingTableEntry(retval);
    PyNs3Ipv6RoutingTableEntry_wrapper_registry[(void *) py_Ipv6RoutingTableEntry->obj] = (PyObject *) py_Ipv6RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingTableEntry);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_CreateNetworkRouteTo__1(PyNs3Ipv6RoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *network;
    PyNs3Ipv6Prefix *networkPrefix;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    PyNs3Ipv6Address *prefixToUse;
    const char *keywords[] = {"network", "networkPrefix", "nextHop", "interface", "prefixToUse", NULL};
    PyNs3Ipv6RoutingTableEntry *py_Ipv6RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!IO!", (char **) keywords, &PyNs3Ipv6Address_Type, &network, &PyNs3Ipv6Prefix_Type, &networkPrefix, &PyNs3Ipv6Address_Type, &nextHop, &interface, &PyNs3Ipv6Address_Type, &prefixToUse)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv6RoutingTableEntry retval = ns3::Ipv6RoutingTableEntry::CreateNetworkRouteTo(*((PyNs3Ipv6Address *) network)->obj, *((PyNs3Ipv6Prefix *) networkPrefix)->obj, *((PyNs3Ipv6Address *) nextHop)->obj, interface, *((PyNs3Ipv6Address *) prefixToUse)->obj);
    py_Ipv6RoutingTableEntry = PyObject_New(PyNs3Ipv6RoutingTableEntry, &PyNs3Ipv6RoutingTableEntry_Type);
    py_Ipv6RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6RoutingTableEntry->obj = new ns3::Ipv6RoutingTableEntry(retval);
    PyNs3Ipv6RoutingTableEntry_wrapper_registry[(void *) py_Ipv6RoutingTableEntry->obj] = (PyObject *) py_Ipv6RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingTableEntry);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_CreateNetworkRouteTo__2(PyNs3Ipv6RoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *network;
    PyNs3Ipv6Prefix *networkPrefix;
    unsigned int interface;
    const char *keywords[] = {"network", "networkPrefix", "interface", NULL};
    PyNs3Ipv6RoutingTableEntry *py_Ipv6RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PyNs3Ipv6Address_Type, &network, &PyNs3Ipv6Prefix_Type, &networkPrefix, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv6RoutingTableEntry retval = ns3::Ipv6RoutingTableEntry::CreateNetworkRouteTo(*((PyNs3Ipv6Address *) network)->obj, *((PyNs3Ipv6Prefix *) networkPrefix)->obj, interface);
    py_Ipv6RoutingTableEntry = PyObject_New(PyNs3Ipv6RoutingTableEntry, &PyNs3Ipv6RoutingTableEntry_Type);
    py_Ipv6RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6RoutingTableEntry->obj = new ns3::Ipv6RoutingTableEntry(retval);
    PyNs3Ipv6RoutingTableEntry_wrapper_registry[(void *) py_Ipv6RoutingTableEntry->obj] = (PyObject *) py_Ipv6RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingTableEntry);
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv6RoutingTableEntry_CreateNetworkRouteTo(PyNs3Ipv6RoutingTableEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Ipv6RoutingTableEntry_CreateNetworkRouteTo__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6RoutingTableEntry_CreateNetworkRouteTo__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv6RoutingTableEntry_CreateNetworkRouteTo__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_IsHost(PyNs3Ipv6RoutingTableEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsHost();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_GetInterface(PyNs3Ipv6RoutingTableEntry *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetInterface();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_CreateHostRouteTo__0(PyNs3Ipv6RoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dest;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    PyNs3Ipv6Address *prefixToUse = NULL;
    const char *keywords[] = {"dest", "nextHop", "interface", "prefixToUse", NULL};
    PyNs3Ipv6RoutingTableEntry *py_Ipv6RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I|O!", (char **) keywords, &PyNs3Ipv6Address_Type, &dest, &PyNs3Ipv6Address_Type, &nextHop, &interface, &PyNs3Ipv6Address_Type, &prefixToUse)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv6RoutingTableEntry retval = ns3::Ipv6RoutingTableEntry::CreateHostRouteTo(*((PyNs3Ipv6Address *) dest)->obj, *((PyNs3Ipv6Address *) nextHop)->obj, interface, (prefixToUse ? (*((PyNs3Ipv6Address *) prefixToUse)->obj) : ns3::Ipv6Address()));
    py_Ipv6RoutingTableEntry = PyObject_New(PyNs3Ipv6RoutingTableEntry, &PyNs3Ipv6RoutingTableEntry_Type);
    py_Ipv6RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6RoutingTableEntry->obj = new ns3::Ipv6RoutingTableEntry(retval);
    PyNs3Ipv6RoutingTableEntry_wrapper_registry[(void *) py_Ipv6RoutingTableEntry->obj] = (PyObject *) py_Ipv6RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingTableEntry);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_CreateHostRouteTo__1(PyNs3Ipv6RoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dest;
    unsigned int interface;
    const char *keywords[] = {"dest", "interface", NULL};
    PyNs3Ipv6RoutingTableEntry *py_Ipv6RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3Ipv6Address_Type, &dest, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Ipv6RoutingTableEntry retval = ns3::Ipv6RoutingTableEntry::CreateHostRouteTo(*((PyNs3Ipv6Address *) dest)->obj, interface);
    py_Ipv6RoutingTableEntry = PyObject_New(PyNs3Ipv6RoutingTableEntry, &PyNs3Ipv6RoutingTableEntry_Type);
    py_Ipv6RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6RoutingTableEntry->obj = new ns3::Ipv6RoutingTableEntry(retval);
    PyNs3Ipv6RoutingTableEntry_wrapper_registry[(void *) py_Ipv6RoutingTableEntry->obj] = (PyObject *) py_Ipv6RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingTableEntry);
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv6RoutingTableEntry_CreateHostRouteTo(PyNs3Ipv6RoutingTableEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6RoutingTableEntry_CreateHostRouteTo__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6RoutingTableEntry_CreateHostRouteTo__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_CreateDefaultRoute(PyNs3Ipv6RoutingTableEntry *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    const char *keywords[] = {"nextHop", "interface", NULL};
    PyNs3Ipv6RoutingTableEntry *py_Ipv6RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3Ipv6Address_Type, &nextHop, &interface)) {
        return NULL;
    }
    ns3::Ipv6RoutingTableEntry retval = ns3::Ipv6RoutingTableEntry::CreateDefaultRoute(*((PyNs3Ipv6Address *) nextHop)->obj, interface);
    py_Ipv6RoutingTableEntry = PyObject_New(PyNs3Ipv6RoutingTableEntry, &PyNs3Ipv6RoutingTableEntry_Type);
    py_Ipv6RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6RoutingTableEntry->obj = new ns3::Ipv6RoutingTableEntry(retval);
    PyNs3Ipv6RoutingTableEntry_wrapper_registry[(void *) py_Ipv6RoutingTableEntry->obj] = (PyObject *) py_Ipv6RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingTableEntry);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_IsDefault(PyNs3Ipv6RoutingTableEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsDefault();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry_GetDest(PyNs3Ipv6RoutingTableEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetDest();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6RoutingTableEntry__copy__(PyNs3Ipv6RoutingTableEntry *self)
{

    PyNs3Ipv6RoutingTableEntry *py_copy;
    py_copy = PyObject_New(PyNs3Ipv6RoutingTableEntry, &PyNs3Ipv6RoutingTableEntry_Type);
    py_copy->obj = new ns3::Ipv6RoutingTableEntry(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv6RoutingTableEntry_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6RoutingTableEntry_methods[] = {
    {(char *) "GetDestNetworkPrefix", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_GetDestNetworkPrefix, METH_NOARGS, NULL },
    {(char *) "IsNetwork", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_IsNetwork, METH_NOARGS, NULL },
    {(char *) "GetPrefixToUse", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_GetPrefixToUse, METH_NOARGS, NULL },
    {(char *) "IsGateway", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_IsGateway, METH_NOARGS, NULL },
    {(char *) "GetGateway", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_GetGateway, METH_NOARGS, NULL },
    {(char *) "SetPrefixToUse", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_SetPrefixToUse, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDestNetwork", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_GetDestNetwork, METH_NOARGS, NULL },
    {(char *) "CreateNetworkRouteTo", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_CreateNetworkRouteTo, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "IsHost", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_IsHost, METH_NOARGS, NULL },
    {(char *) "GetInterface", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_GetInterface, METH_NOARGS, NULL },
    {(char *) "CreateHostRouteTo", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_CreateHostRouteTo, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "CreateDefaultRoute", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_CreateDefaultRoute, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "IsDefault", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_IsDefault, METH_NOARGS, NULL },
    {(char *) "GetDest", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry_GetDest, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6RoutingTableEntry__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv6RoutingTableEntry__tp_dealloc(PyNs3Ipv6RoutingTableEntry *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv6RoutingTableEntry_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv6RoutingTableEntry_wrapper_registry.end()) {
        PyNs3Ipv6RoutingTableEntry_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv6RoutingTableEntry *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyNs3Ipv6RoutingTableEntry__tp_str(PyNs3Ipv6RoutingTableEntry *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyNs3Ipv6RoutingTableEntry__tp_richcompare (PyNs3Ipv6RoutingTableEntry *PYBINDGEN_UNUSED(self), PyNs3Ipv6RoutingTableEntry *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6RoutingTableEntry_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6RoutingTableEntry_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6RoutingTableEntry",            /* tp_name */
    sizeof(PyNs3Ipv6RoutingTableEntry),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6RoutingTableEntry__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyNs3Ipv6RoutingTableEntry__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6RoutingTableEntry__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6RoutingTableEntry_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6RoutingTableEntry__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6StaticRoutingHelper__tp_init__0(PyNs3Ipv6StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6StaticRoutingHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6StaticRoutingHelper__tp_init__1(PyNs3Ipv6StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6StaticRoutingHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6StaticRoutingHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6StaticRoutingHelper(*((PyNs3Ipv6StaticRoutingHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6StaticRoutingHelper__tp_init(PyNs3Ipv6StaticRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6StaticRoutingHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6StaticRoutingHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}



PyObject *
_wrap_PyNs3Ipv6StaticRoutingHelper_AddMulticastRoute__0(PyNs3Ipv6StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Node *n;
    ns3::Node *n_ptr;
    PyNs3Ipv6Address *source;
    PyNs3Ipv6Address *group;
    PyNs3NetDevice *input;
    ns3::NetDevice *input_ptr;
    PyNs3NetDeviceContainer *output;
    const char *keywords[] = {"n", "source", "group", "input", "output", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!O!O!", (char **) keywords, &PyNs3Node_Type, &n, &PyNs3Ipv6Address_Type, &source, &PyNs3Ipv6Address_Type, &group, &PyNs3NetDevice_Type, &input, &PyNs3NetDeviceContainer_Type, &output)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    n_ptr = (n ? n->obj : NULL);
    input_ptr = (input ? input->obj : NULL);
    self->obj->AddMulticastRoute(ns3::Ptr< ns3::Node  > (n_ptr), *((PyNs3Ipv6Address *) source)->obj, *((PyNs3Ipv6Address *) group)->obj, ns3::Ptr< ns3::NetDevice  > (input_ptr), *((PyNs3NetDeviceContainer *) output)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6StaticRoutingHelper_AddMulticastRoute__1(PyNs3Ipv6StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *n;
    Py_ssize_t n_len;
    PyNs3Ipv6Address *source;
    PyNs3Ipv6Address *group;
    PyNs3NetDevice *input;
    ns3::NetDevice *input_ptr;
    PyNs3NetDeviceContainer *output;
    const char *keywords[] = {"n", "source", "group", "input", "output", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!O!O!O!", (char **) keywords, &n, &n_len, &PyNs3Ipv6Address_Type, &source, &PyNs3Ipv6Address_Type, &group, &PyNs3NetDevice_Type, &input, &PyNs3NetDeviceContainer_Type, &output)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    input_ptr = (input ? input->obj : NULL);
    self->obj->AddMulticastRoute(std::string(n, n_len), *((PyNs3Ipv6Address *) source)->obj, *((PyNs3Ipv6Address *) group)->obj, ns3::Ptr< ns3::NetDevice  > (input_ptr), *((PyNs3NetDeviceContainer *) output)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6StaticRoutingHelper_AddMulticastRoute__2(PyNs3Ipv6StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Node *n;
    ns3::Node *n_ptr;
    PyNs3Ipv6Address *source;
    PyNs3Ipv6Address *group;
    const char *inputName;
    Py_ssize_t inputName_len;
    PyNs3NetDeviceContainer *output;
    const char *keywords[] = {"n", "source", "group", "inputName", "output", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!s#O!", (char **) keywords, &PyNs3Node_Type, &n, &PyNs3Ipv6Address_Type, &source, &PyNs3Ipv6Address_Type, &group, &inputName, &inputName_len, &PyNs3NetDeviceContainer_Type, &output)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    n_ptr = (n ? n->obj : NULL);
    self->obj->AddMulticastRoute(ns3::Ptr< ns3::Node  > (n_ptr), *((PyNs3Ipv6Address *) source)->obj, *((PyNs3Ipv6Address *) group)->obj, std::string(inputName, inputName_len), *((PyNs3NetDeviceContainer *) output)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6StaticRoutingHelper_AddMulticastRoute__3(PyNs3Ipv6StaticRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *nName;
    Py_ssize_t nName_len;
    PyNs3Ipv6Address *source;
    PyNs3Ipv6Address *group;
    const char *inputName;
    Py_ssize_t inputName_len;
    PyNs3NetDeviceContainer *output;
    const char *keywords[] = {"nName", "source", "group", "inputName", "output", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!O!s#O!", (char **) keywords, &nName, &nName_len, &PyNs3Ipv6Address_Type, &source, &PyNs3Ipv6Address_Type, &group, &inputName, &inputName_len, &PyNs3NetDeviceContainer_Type, &output)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddMulticastRoute(std::string(nName, nName_len), *((PyNs3Ipv6Address *) source)->obj, *((PyNs3Ipv6Address *) group)->obj, std::string(inputName, inputName_len), *((PyNs3NetDeviceContainer *) output)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv6StaticRoutingHelper_AddMulticastRoute(PyNs3Ipv6StaticRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[4] = {0,};
    retval = _wrap_PyNs3Ipv6StaticRoutingHelper_AddMulticastRoute__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6StaticRoutingHelper_AddMulticastRoute__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv6StaticRoutingHelper_AddMulticastRoute__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv6StaticRoutingHelper_AddMulticastRoute__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    error_list = PyList_New(4);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv6StaticRoutingHelper_Create(PyNs3Ipv6StaticRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6RoutingProtocol > retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    PyNs3Ipv6RoutingProtocol *py_Ipv6RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    retval = self->obj->Create(ns3::Ptr< ns3::Node  > (node_ptr));
    if (!(const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv6RoutingProtocol = NULL;
    } else {
        py_Ipv6RoutingProtocol = (PyNs3Ipv6RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6RoutingProtocol);
    }
    
    if (py_Ipv6RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6RoutingProtocol_Type);
        py_Ipv6RoutingProtocol = PyObject_GC_New(PyNs3Ipv6RoutingProtocol, wrapper_type);
        py_Ipv6RoutingProtocol->inst_dict = NULL;
        py_Ipv6RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv6RoutingProtocol->obj = const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6RoutingProtocol->obj] = (PyObject *) py_Ipv6RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingProtocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRoutingHelper_GetStaticRouting(PyNs3Ipv6StaticRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6StaticRouting > retval;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    const char *keywords[] = {"ipv6", NULL};
    PyNs3Ipv6StaticRouting *py_Ipv6StaticRouting;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6_Type, &ipv6)) {
        return NULL;
    }
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    retval = self->obj->GetStaticRouting(ns3::Ptr< ns3::Ipv6  > (ipv6_ptr));
    if (!(const_cast<ns3::Ipv6StaticRouting *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6StaticRouting *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv6StaticRouting = NULL;
    } else {
        py_Ipv6StaticRouting = (PyNs3Ipv6StaticRouting *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6StaticRouting);
    }
    
    if (py_Ipv6StaticRouting == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6StaticRouting *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6StaticRouting_Type);
        py_Ipv6StaticRouting = PyObject_GC_New(PyNs3Ipv6StaticRouting, wrapper_type);
        py_Ipv6StaticRouting->inst_dict = NULL;
        py_Ipv6StaticRouting->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6StaticRouting *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv6StaticRouting->obj = const_cast<ns3::Ipv6StaticRouting *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6StaticRouting->obj] = (PyObject *) py_Ipv6StaticRouting;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6StaticRouting);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6StaticRoutingHelper__copy__(PyNs3Ipv6StaticRoutingHelper *self)
{

    PyNs3Ipv6StaticRoutingHelper *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6StaticRoutingHelper, &PyNs3Ipv6StaticRoutingHelper_Type);
    py_copy->obj = new ns3::Ipv6StaticRoutingHelper(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv6RoutingHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6StaticRoutingHelper_methods[] = {
    {(char *) "AddMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv6StaticRoutingHelper_AddMulticastRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Create", (PyCFunction) _wrap_PyNs3Ipv6StaticRoutingHelper_Create, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetStaticRouting", (PyCFunction) _wrap_PyNs3Ipv6StaticRoutingHelper_GetStaticRouting, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6StaticRoutingHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6StaticRoutingHelper__tp_clear(PyNs3Ipv6StaticRoutingHelper *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6StaticRoutingHelper *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6StaticRoutingHelper__tp_traverse(PyNs3Ipv6StaticRoutingHelper *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6StaticRoutingHelper__tp_dealloc(PyNs3Ipv6StaticRoutingHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv6RoutingHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv6RoutingHelper_wrapper_registry.end()) {
        PyNs3Ipv6RoutingHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6StaticRoutingHelper__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6StaticRoutingHelper__tp_richcompare (PyNs3Ipv6StaticRoutingHelper *PYBINDGEN_UNUSED(self), PyNs3Ipv6StaticRoutingHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6StaticRoutingHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6StaticRoutingHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6StaticRoutingHelper",            /* tp_name */
    sizeof(PyNs3Ipv6StaticRoutingHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6StaticRoutingHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6StaticRoutingHelper__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6StaticRoutingHelper__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6StaticRoutingHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6StaticRoutingHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6StaticRoutingHelper, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6StaticRoutingHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3OptionField_wrapper_registry;


static int
_wrap_PyNs3OptionField__tp_init__0(PyNs3OptionField *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3OptionField *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3OptionField_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::OptionField(*((PyNs3OptionField *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3OptionField__tp_init__1(PyNs3OptionField *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    unsigned int optionsOffset;
    const char *keywords[] = {"optionsOffset", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &optionsOffset)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::OptionField(optionsOffset);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3OptionField__tp_init(PyNs3OptionField *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3OptionField__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3OptionField__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3OptionField_AddOption(PyNs3OptionField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6OptionHeader *option;
    const char *keywords[] = {"option", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6OptionHeader_Type, &option)) {
        return NULL;
    }
    self->obj->AddOption(*((PyNs3Ipv6OptionHeader *) option)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3OptionField_Deserialize(PyNs3OptionField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    unsigned int length;
    const char *keywords[] = {"start", "length", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3BufferIterator_Type, &start, &length)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj, length);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3OptionField_Serialize(PyNs3OptionField *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3OptionField_GetOptionBuffer(PyNs3OptionField *self)
{
    PyObject *py_retval;
    PyNs3Buffer *py_Buffer;
    
    ns3::Buffer retval = self->obj->GetOptionBuffer();
    py_Buffer = PyObject_New(PyNs3Buffer, &PyNs3Buffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new ns3::Buffer(retval);
    PyNs3Buffer_wrapper_registry[(void *) py_Buffer->obj] = (PyObject *) py_Buffer;
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}


PyObject *
_wrap_PyNs3OptionField_GetOptionsOffset(PyNs3OptionField *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetOptionsOffset();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3OptionField_GetSerializedSize(PyNs3OptionField *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3OptionField__copy__(PyNs3OptionField *self)
{

    PyNs3OptionField *py_copy;
    py_copy = PyObject_New(PyNs3OptionField, &PyNs3OptionField_Type);
    py_copy->obj = new ns3::OptionField(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3OptionField_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3OptionField_methods[] = {
    {(char *) "AddOption", (PyCFunction) _wrap_PyNs3OptionField_AddOption, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3OptionField_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3OptionField_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOptionBuffer", (PyCFunction) _wrap_PyNs3OptionField_GetOptionBuffer, METH_NOARGS, NULL },
    {(char *) "GetOptionsOffset", (PyCFunction) _wrap_PyNs3OptionField_GetOptionsOffset, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3OptionField_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3OptionField__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3OptionField__tp_dealloc(PyNs3OptionField *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3OptionField_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3OptionField_wrapper_registry.end()) {
        PyNs3OptionField_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::OptionField *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3OptionField__tp_richcompare (PyNs3OptionField *PYBINDGEN_UNUSED(self), PyNs3OptionField *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3OptionField_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3OptionField_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.OptionField",            /* tp_name */
    sizeof(PyNs3OptionField),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3OptionField__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3OptionField__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3OptionField_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3OptionField__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3PcapHelperForIpv4_wrapper_registry;

void
PyNs3PcapHelperForIpv4__PythonHelper::EnablePcapIpv4Internal(std::string prefix, ns3::Ptr< ns3::Ipv4 > ipv4, uint32_t interface, bool explicitFilename)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::PcapHelperForIpv4 *self_obj_before;
    PyObject *py_retval;
    const char *prefix_ptr;
    Py_ssize_t prefix_len;
    PyNs3Ipv4 *py_Ipv4;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "EnablePcapIpv4Internal"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3PcapHelperForIpv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3PcapHelperForIpv4* >(m_pyself)->obj = (ns3::PcapHelperForIpv4*) this;
    prefix_ptr = (prefix).c_str();
    prefix_len = (prefix).size();
    if (typeid(*(const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4)))).name() == typeid(PyNs3Ipv4__PythonHelper).name())
    {
        py_Ipv4 = (PyNs3Ipv4*) (((PyNs3Ipv4__PythonHelper*) const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4)))->m_pyself);
        py_Ipv4->obj = const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4));
        Py_INCREF(py_Ipv4);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Ipv4 = NULL;
        } else {
            py_Ipv4 = (PyNs3Ipv4 *) wrapper_lookup_iter->second;
            Py_INCREF(py_Ipv4);
        }
    
        if (py_Ipv4 == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4))), &PyNs3Ipv4_Type);
            py_Ipv4 = PyObject_GC_New(PyNs3Ipv4, wrapper_type);
            py_Ipv4->inst_dict = NULL;
            py_Ipv4->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4))->Ref();
            py_Ipv4->obj = const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4->obj] = (PyObject *) py_Ipv4;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "EnablePcapIpv4Internal", (char *) "s#NNN", prefix_ptr, prefix_len, py_Ipv4, PyLong_FromUnsignedLong(interface), PyBool_FromLong(explicitFilename));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3PcapHelperForIpv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3PcapHelperForIpv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3PcapHelperForIpv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3PcapHelperForIpv4__tp_init__0(PyNs3PcapHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3PcapHelperForIpv4 *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PcapHelperForIpv4_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3PcapHelperForIpv4_Type)
    {
        self->obj = new PyNs3PcapHelperForIpv4__PythonHelper(*((PyNs3PcapHelperForIpv4 *) arg0)->obj);
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3PcapHelperForIpv4__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'PcapHelperForIpv4' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3PcapHelperForIpv4__tp_init__1(PyNs3PcapHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3PcapHelperForIpv4_Type)
    {
        self->obj = new PyNs3PcapHelperForIpv4__PythonHelper();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3PcapHelperForIpv4__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'PcapHelperForIpv4' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3PcapHelperForIpv4__tp_init(PyNs3PcapHelperForIpv4 *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3PcapHelperForIpv4__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3PcapHelperForIpv4__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4All(PyNs3PcapHelperForIpv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *keywords[] = {"prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &prefix, &prefix_len)) {
        return NULL;
    }
    self->obj->EnablePcapIpv4All(std::string(prefix, prefix_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4Internal(PyNs3PcapHelperForIpv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"prefix", "ipv4", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!IO", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv4_Type, &ipv4, &interface, &py_explicitFilename)) {
        return NULL;
    }
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnablePcapIpv4Internal(std::string(prefix, prefix_len), ns3::Ptr< ns3::Ipv4  > (ipv4_ptr), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4__0(PyNs3PcapHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv4", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!I|O", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv4_Type, &ipv4, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnablePcapIpv4(std::string(prefix, prefix_len), ns3::Ptr< ns3::Ipv4  > (ipv4_ptr), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4__1(PyNs3PcapHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *ipv4Name;
    Py_ssize_t ipv4Name_len;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv4Name", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#I|O", (char **) keywords, &prefix, &prefix_len, &ipv4Name, &ipv4Name_len, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnablePcapIpv4(std::string(prefix, prefix_len), std::string(ipv4Name, ipv4Name_len), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4__2(PyNs3PcapHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv4InterfaceContainer *c;
    const char *keywords[] = {"prefix", "c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv4InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnablePcapIpv4(std::string(prefix, prefix_len), *((PyNs3Ipv4InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4__3(PyNs3PcapHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3NodeContainer *n;
    const char *keywords[] = {"prefix", "n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3NodeContainer_Type, &n)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnablePcapIpv4(std::string(prefix, prefix_len), *((PyNs3NodeContainer *) n)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4__4(PyNs3PcapHelperForIpv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    unsigned int nodeid;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"prefix", "nodeid", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#IIO", (char **) keywords, &prefix, &prefix_len, &nodeid, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnablePcapIpv4(std::string(prefix, prefix_len), nodeid, interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4(PyNs3PcapHelperForIpv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[5] = {0,};
    retval = _wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    retval = _wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4__4(self, args, kwargs, &exceptions[4]);
    if (!exceptions[4]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        return retval;
    }
    error_list = PyList_New(5);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyList_SET_ITEM(error_list, 4, PyObject_Str(exceptions[4]));
    Py_DECREF(exceptions[4]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}

static PyMethodDef PyNs3PcapHelperForIpv4_methods[] = {
    {(char *) "EnablePcapIpv4All", (PyCFunction) _wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4All, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnablePcapIpv4Internal", (PyCFunction) _wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4Internal, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnablePcapIpv4", (PyCFunction) _wrap_PyNs3PcapHelperForIpv4_EnablePcapIpv4, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3PcapHelperForIpv4__tp_clear(PyNs3PcapHelperForIpv4 *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::PcapHelperForIpv4 *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3PcapHelperForIpv4__tp_traverse(PyNs3PcapHelperForIpv4 *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3PcapHelperForIpv4__PythonHelper).name() )
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3PcapHelperForIpv4__tp_dealloc(PyNs3PcapHelperForIpv4 *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3PcapHelperForIpv4_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3PcapHelperForIpv4_wrapper_registry.end()) {
        PyNs3PcapHelperForIpv4_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3PcapHelperForIpv4__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3PcapHelperForIpv4__tp_richcompare (PyNs3PcapHelperForIpv4 *PYBINDGEN_UNUSED(self), PyNs3PcapHelperForIpv4 *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3PcapHelperForIpv4_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3PcapHelperForIpv4_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.PcapHelperForIpv4",            /* tp_name */
    sizeof(PyNs3PcapHelperForIpv4),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3PcapHelperForIpv4__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3PcapHelperForIpv4__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3PcapHelperForIpv4__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3PcapHelperForIpv4__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3PcapHelperForIpv4_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3PcapHelperForIpv4, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3PcapHelperForIpv4__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3PcapHelperForIpv6_wrapper_registry;

void
PyNs3PcapHelperForIpv6__PythonHelper::EnablePcapIpv6Internal(std::string prefix, ns3::Ptr< ns3::Ipv6 > ipv6, uint32_t interface, bool explicitFilename)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::PcapHelperForIpv6 *self_obj_before;
    PyObject *py_retval;
    const char *prefix_ptr;
    Py_ssize_t prefix_len;
    PyNs3Ipv6 *py_Ipv6;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "EnablePcapIpv6Internal"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3PcapHelperForIpv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3PcapHelperForIpv6* >(m_pyself)->obj = (ns3::PcapHelperForIpv6*) this;
    prefix_ptr = (prefix).c_str();
    prefix_len = (prefix).size();
    if (typeid(*(const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6)))).name() == typeid(PyNs3Ipv6__PythonHelper).name())
    {
        py_Ipv6 = (PyNs3Ipv6*) (((PyNs3Ipv6__PythonHelper*) const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6)))->m_pyself);
        py_Ipv6->obj = const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6));
        Py_INCREF(py_Ipv6);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Ipv6 = NULL;
        } else {
            py_Ipv6 = (PyNs3Ipv6 *) wrapper_lookup_iter->second;
            Py_INCREF(py_Ipv6);
        }
    
        if (py_Ipv6 == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6))), &PyNs3Ipv6_Type);
            py_Ipv6 = PyObject_GC_New(PyNs3Ipv6, wrapper_type);
            py_Ipv6->inst_dict = NULL;
            py_Ipv6->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6))->Ref();
            py_Ipv6->obj = const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6->obj] = (PyObject *) py_Ipv6;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "EnablePcapIpv6Internal", (char *) "s#NNN", prefix_ptr, prefix_len, py_Ipv6, PyLong_FromUnsignedLong(interface), PyBool_FromLong(explicitFilename));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3PcapHelperForIpv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3PcapHelperForIpv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3PcapHelperForIpv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3PcapHelperForIpv6__tp_init__0(PyNs3PcapHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3PcapHelperForIpv6 *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PcapHelperForIpv6_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3PcapHelperForIpv6_Type)
    {
        self->obj = new PyNs3PcapHelperForIpv6__PythonHelper(*((PyNs3PcapHelperForIpv6 *) arg0)->obj);
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3PcapHelperForIpv6__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'PcapHelperForIpv6' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3PcapHelperForIpv6__tp_init__1(PyNs3PcapHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3PcapHelperForIpv6_Type)
    {
        self->obj = new PyNs3PcapHelperForIpv6__PythonHelper();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3PcapHelperForIpv6__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'PcapHelperForIpv6' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3PcapHelperForIpv6__tp_init(PyNs3PcapHelperForIpv6 *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3PcapHelperForIpv6__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3PcapHelperForIpv6__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}



PyObject *
_wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6__0(PyNs3PcapHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv6", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!I|O", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv6_Type, &ipv6, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnablePcapIpv6(std::string(prefix, prefix_len), ns3::Ptr< ns3::Ipv6  > (ipv6_ptr), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6__1(PyNs3PcapHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *ipv6Name;
    Py_ssize_t ipv6Name_len;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv6Name", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#I|O", (char **) keywords, &prefix, &prefix_len, &ipv6Name, &ipv6Name_len, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnablePcapIpv6(std::string(prefix, prefix_len), std::string(ipv6Name, ipv6Name_len), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6__2(PyNs3PcapHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv6InterfaceContainer *c;
    const char *keywords[] = {"prefix", "c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv6InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnablePcapIpv6(std::string(prefix, prefix_len), *((PyNs3Ipv6InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6__3(PyNs3PcapHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3NodeContainer *n;
    const char *keywords[] = {"prefix", "n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3NodeContainer_Type, &n)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnablePcapIpv6(std::string(prefix, prefix_len), *((PyNs3NodeContainer *) n)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6__4(PyNs3PcapHelperForIpv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    unsigned int nodeid;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"prefix", "nodeid", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#IIO", (char **) keywords, &prefix, &prefix_len, &nodeid, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnablePcapIpv6(std::string(prefix, prefix_len), nodeid, interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6(PyNs3PcapHelperForIpv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[5] = {0,};
    retval = _wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    retval = _wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6__4(self, args, kwargs, &exceptions[4]);
    if (!exceptions[4]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        return retval;
    }
    error_list = PyList_New(5);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyList_SET_ITEM(error_list, 4, PyObject_Str(exceptions[4]));
    Py_DECREF(exceptions[4]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6All(PyNs3PcapHelperForIpv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *keywords[] = {"prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &prefix, &prefix_len)) {
        return NULL;
    }
    self->obj->EnablePcapIpv6All(std::string(prefix, prefix_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6Internal(PyNs3PcapHelperForIpv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"prefix", "ipv6", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!IO", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv6_Type, &ipv6, &interface, &py_explicitFilename)) {
        return NULL;
    }
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnablePcapIpv6Internal(std::string(prefix, prefix_len), ns3::Ptr< ns3::Ipv6  > (ipv6_ptr), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3PcapHelperForIpv6_methods[] = {
    {(char *) "EnablePcapIpv6", (PyCFunction) _wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnablePcapIpv6All", (PyCFunction) _wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6All, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnablePcapIpv6Internal", (PyCFunction) _wrap_PyNs3PcapHelperForIpv6_EnablePcapIpv6Internal, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3PcapHelperForIpv6__tp_clear(PyNs3PcapHelperForIpv6 *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::PcapHelperForIpv6 *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3PcapHelperForIpv6__tp_traverse(PyNs3PcapHelperForIpv6 *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3PcapHelperForIpv6__PythonHelper).name() )
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3PcapHelperForIpv6__tp_dealloc(PyNs3PcapHelperForIpv6 *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3PcapHelperForIpv6_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3PcapHelperForIpv6_wrapper_registry.end()) {
        PyNs3PcapHelperForIpv6_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3PcapHelperForIpv6__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3PcapHelperForIpv6__tp_richcompare (PyNs3PcapHelperForIpv6 *PYBINDGEN_UNUSED(self), PyNs3PcapHelperForIpv6 *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3PcapHelperForIpv6_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3PcapHelperForIpv6_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.PcapHelperForIpv6",            /* tp_name */
    sizeof(PyNs3PcapHelperForIpv6),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3PcapHelperForIpv6__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3PcapHelperForIpv6__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3PcapHelperForIpv6__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3PcapHelperForIpv6__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3PcapHelperForIpv6_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3PcapHelperForIpv6, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3PcapHelperForIpv6__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3SPFVertex_wrapper_registry;

static int
_wrap_PyNs3SPFVertex__tp_init(PyNs3SPFVertex *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    self->obj = new ns3::SPFVertex();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyNs3SPFVertex_SetVertexProcessed(PyNs3SPFVertex *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool value;
    PyObject *py_value;
    const char *keywords[] = {"value", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_value)) {
        return NULL;
    }
    value = (bool) PyObject_IsTrue(py_value);
    self->obj->SetVertexProcessed(value);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_SetVertexType(PyNs3SPFVertex *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::SPFVertex::VertexType type;
    const char *keywords[] = {"type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &type)) {
        return NULL;
    }
    self->obj->SetVertexType(type);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_InheritAllRootExitDirections(PyNs3SPFVertex *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SPFVertex *vertex;
    ns3::SPFVertex *vertex_ptr;
    const char *keywords[] = {"vertex", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SPFVertex_Type, &vertex)) {
        return NULL;
    }
    vertex_ptr = (vertex ? vertex->obj : NULL);
    self->obj->InheritAllRootExitDirections(vertex_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_SetVertexId(PyNs3SPFVertex *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *id;
    const char *keywords[] = {"id", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &id)) {
        return NULL;
    }
    self->obj->SetVertexId(*((PyNs3Ipv4Address *) id)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_MergeParent(PyNs3SPFVertex *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SPFVertex *v;
    ns3::SPFVertex *v_ptr;
    const char *keywords[] = {"v", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SPFVertex_Type, &v)) {
        return NULL;
    }
    v_ptr = (v ? v->obj : NULL);
    self->obj->MergeParent(v_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_GetNChildren(PyNs3SPFVertex *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNChildren();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_GetVertexType(PyNs3SPFVertex *self)
{
    PyObject *py_retval;
    ns3::SPFVertex::VertexType retval;
    
    retval = self->obj->GetVertexType();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_GetVertexId(PyNs3SPFVertex *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetVertexId();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_SetRootExitDirection(PyNs3SPFVertex *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *nextHop;
    int32_t id = ns3::SPF_INFINITY;
    const char *keywords[] = {"nextHop", "id", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!|i", (char **) keywords, &PyNs3Ipv4Address_Type, &nextHop, &id)) {
        return NULL;
    }
    self->obj->SetRootExitDirection(*((PyNs3Ipv4Address *) nextHop)->obj, id);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_MergeRootExitDirections(PyNs3SPFVertex *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SPFVertex *vertex;
    ns3::SPFVertex *vertex_ptr;
    const char *keywords[] = {"vertex", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SPFVertex_Type, &vertex)) {
        return NULL;
    }
    vertex_ptr = (vertex ? vertex->obj : NULL);
    self->obj->MergeRootExitDirections(vertex_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_SetDistanceFromRoot(PyNs3SPFVertex *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int distance;
    const char *keywords[] = {"distance", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &distance)) {
        return NULL;
    }
    self->obj->SetDistanceFromRoot(distance);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_ClearVertexProcessed(PyNs3SPFVertex *self)
{
    PyObject *py_retval;
    
    self->obj->ClearVertexProcessed();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_GetNRootExitDirections(PyNs3SPFVertex *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNRootExitDirections();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_GetDistanceFromRoot(PyNs3SPFVertex *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetDistanceFromRoot();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3SPFVertex_IsVertexProcessed(PyNs3SPFVertex *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsVertexProcessed();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

static PyMethodDef PyNs3SPFVertex_methods[] = {
    {(char *) "SetVertexProcessed", (PyCFunction) _wrap_PyNs3SPFVertex_SetVertexProcessed, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetVertexType", (PyCFunction) _wrap_PyNs3SPFVertex_SetVertexType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "InheritAllRootExitDirections", (PyCFunction) _wrap_PyNs3SPFVertex_InheritAllRootExitDirections, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetVertexId", (PyCFunction) _wrap_PyNs3SPFVertex_SetVertexId, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "MergeParent", (PyCFunction) _wrap_PyNs3SPFVertex_MergeParent, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNChildren", (PyCFunction) _wrap_PyNs3SPFVertex_GetNChildren, METH_NOARGS, NULL },
    {(char *) "GetVertexType", (PyCFunction) _wrap_PyNs3SPFVertex_GetVertexType, METH_NOARGS, NULL },
    {(char *) "GetVertexId", (PyCFunction) _wrap_PyNs3SPFVertex_GetVertexId, METH_NOARGS, NULL },
    {(char *) "SetRootExitDirection", (PyCFunction) _wrap_PyNs3SPFVertex_SetRootExitDirection, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "MergeRootExitDirections", (PyCFunction) _wrap_PyNs3SPFVertex_MergeRootExitDirections, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDistanceFromRoot", (PyCFunction) _wrap_PyNs3SPFVertex_SetDistanceFromRoot, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "ClearVertexProcessed", (PyCFunction) _wrap_PyNs3SPFVertex_ClearVertexProcessed, METH_NOARGS, NULL },
    {(char *) "GetNRootExitDirections", (PyCFunction) _wrap_PyNs3SPFVertex_GetNRootExitDirections, METH_NOARGS, NULL },
    {(char *) "GetDistanceFromRoot", (PyCFunction) _wrap_PyNs3SPFVertex_GetDistanceFromRoot, METH_NOARGS, NULL },
    {(char *) "IsVertexProcessed", (PyCFunction) _wrap_PyNs3SPFVertex_IsVertexProcessed, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SPFVertex__tp_dealloc(PyNs3SPFVertex *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3SPFVertex_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3SPFVertex_wrapper_registry.end()) {
        PyNs3SPFVertex_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::SPFVertex *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SPFVertex__tp_richcompare (PyNs3SPFVertex *PYBINDGEN_UNUSED(self), PyNs3SPFVertex *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SPFVertex_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SPFVertex_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.SPFVertex",            /* tp_name */
    sizeof(PyNs3SPFVertex),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SPFVertex__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SPFVertex__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SPFVertex_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SPFVertex__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv4DestinationUnreachable__tp_init__0(PyNs3Icmpv4DestinationUnreachable *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv4DestinationUnreachable *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv4DestinationUnreachable_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv4DestinationUnreachable(*((PyNs3Icmpv4DestinationUnreachable *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv4DestinationUnreachable__tp_init__1(PyNs3Icmpv4DestinationUnreachable *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv4DestinationUnreachable();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv4DestinationUnreachable__tp_init(PyNs3Icmpv4DestinationUnreachable *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv4DestinationUnreachable__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv4DestinationUnreachable__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv4DestinationUnreachable_GetNextHopMtu(PyNs3Icmpv4DestinationUnreachable *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetNextHopMtu();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4DestinationUnreachable_GetHeader(PyNs3Icmpv4DestinationUnreachable *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Header *py_Ipv4Header;
    
    ns3::Ipv4Header retval = self->obj->GetHeader();
    py_Ipv4Header = PyObject_GC_New(PyNs3Ipv4Header, &PyNs3Ipv4Header_Type);
    py_Ipv4Header->inst_dict = NULL;
    py_Ipv4Header->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Header->obj = new ns3::Ipv4Header(retval);
    PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4Header->obj] = (PyObject *) py_Ipv4Header;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Header);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4DestinationUnreachable_SetNextHopMtu(PyNs3Icmpv4DestinationUnreachable *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int mtu;
    const char *keywords[] = {"mtu", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &mtu)) {
        return NULL;
    }
    if (mtu > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetNextHopMtu(mtu);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4DestinationUnreachable_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv4DestinationUnreachable::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4DestinationUnreachable_SetHeader(PyNs3Icmpv4DestinationUnreachable *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Header *header;
    const char *keywords[] = {"header", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Header_Type, &header)) {
        return NULL;
    }
    self->obj->SetHeader(*((PyNs3Ipv4Header *) header)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4DestinationUnreachable_SetData(PyNs3Icmpv4DestinationUnreachable *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *data;
    ns3::Packet *data_ptr;
    const char *keywords[] = {"data", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &data)) {
        return NULL;
    }
    data_ptr = (data ? data->obj : NULL);
    self->obj->SetData(ns3::Ptr< ns3::Packet  > (data_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv4DestinationUnreachable__copy__(PyNs3Icmpv4DestinationUnreachable *self)
{

    PyNs3Icmpv4DestinationUnreachable *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv4DestinationUnreachable, &PyNs3Icmpv4DestinationUnreachable_Type);
    py_copy->obj = new ns3::Icmpv4DestinationUnreachable(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv4DestinationUnreachable_methods[] = {
    {(char *) "GetNextHopMtu", (PyCFunction) _wrap_PyNs3Icmpv4DestinationUnreachable_GetNextHopMtu, METH_NOARGS, NULL },
    {(char *) "GetHeader", (PyCFunction) _wrap_PyNs3Icmpv4DestinationUnreachable_GetHeader, METH_NOARGS, NULL },
    {(char *) "SetNextHopMtu", (PyCFunction) _wrap_PyNs3Icmpv4DestinationUnreachable_SetNextHopMtu, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv4DestinationUnreachable_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "SetHeader", (PyCFunction) _wrap_PyNs3Icmpv4DestinationUnreachable_SetHeader, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetData", (PyCFunction) _wrap_PyNs3Icmpv4DestinationUnreachable_SetData, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv4DestinationUnreachable__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv4DestinationUnreachable__tp_clear(PyNs3Icmpv4DestinationUnreachable *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv4DestinationUnreachable *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv4DestinationUnreachable__tp_traverse(PyNs3Icmpv4DestinationUnreachable *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv4DestinationUnreachable__tp_dealloc(PyNs3Icmpv4DestinationUnreachable *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv4DestinationUnreachable__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv4DestinationUnreachable__tp_richcompare (PyNs3Icmpv4DestinationUnreachable *PYBINDGEN_UNUSED(self), PyNs3Icmpv4DestinationUnreachable *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv4DestinationUnreachable_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv4DestinationUnreachable_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv4DestinationUnreachable",            /* tp_name */
    sizeof(PyNs3Icmpv4DestinationUnreachable),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv4DestinationUnreachable__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv4DestinationUnreachable__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv4DestinationUnreachable__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv4DestinationUnreachable__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv4DestinationUnreachable_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv4DestinationUnreachable, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv4DestinationUnreachable__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv4Echo__tp_init__0(PyNs3Icmpv4Echo *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv4Echo *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv4Echo_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv4Echo(*((PyNs3Icmpv4Echo *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv4Echo__tp_init__1(PyNs3Icmpv4Echo *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv4Echo();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv4Echo__tp_init(PyNs3Icmpv4Echo *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv4Echo__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv4Echo__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv4Echo_GetDataSize(PyNs3Icmpv4Echo *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetDataSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Echo_GetSequenceNumber(PyNs3Icmpv4Echo *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetSequenceNumber();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Echo_Deserialize(PyNs3Icmpv4Echo *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Echo_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv4Echo::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Echo_Serialize(PyNs3Icmpv4Echo *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Echo_GetSerializedSize(PyNs3Icmpv4Echo *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Echo_GetInstanceTypeId(PyNs3Icmpv4Echo *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Echo_GetIdentifier(PyNs3Icmpv4Echo *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetIdentifier();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Echo_SetSequenceNumber(PyNs3Icmpv4Echo *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int seq;
    const char *keywords[] = {"seq", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &seq)) {
        return NULL;
    }
    if (seq > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetSequenceNumber(seq);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Echo_SetIdentifier(PyNs3Icmpv4Echo *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int id;
    const char *keywords[] = {"id", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &id)) {
        return NULL;
    }
    if (id > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetIdentifier(id);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Echo_SetData(PyNs3Icmpv4Echo *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *data;
    ns3::Packet *data_ptr;
    const char *keywords[] = {"data", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &data)) {
        return NULL;
    }
    data_ptr = (data ? data->obj : NULL);
    self->obj->SetData(ns3::Ptr< ns3::Packet  > (data_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv4Echo__copy__(PyNs3Icmpv4Echo *self)
{

    PyNs3Icmpv4Echo *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv4Echo, &PyNs3Icmpv4Echo_Type);
    py_copy->obj = new ns3::Icmpv4Echo(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv4Echo_methods[] = {
    {(char *) "GetDataSize", (PyCFunction) _wrap_PyNs3Icmpv4Echo_GetDataSize, METH_NOARGS, NULL },
    {(char *) "GetSequenceNumber", (PyCFunction) _wrap_PyNs3Icmpv4Echo_GetSequenceNumber, METH_NOARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv4Echo_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv4Echo_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv4Echo_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv4Echo_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv4Echo_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetIdentifier", (PyCFunction) _wrap_PyNs3Icmpv4Echo_GetIdentifier, METH_NOARGS, NULL },
    {(char *) "SetSequenceNumber", (PyCFunction) _wrap_PyNs3Icmpv4Echo_SetSequenceNumber, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetIdentifier", (PyCFunction) _wrap_PyNs3Icmpv4Echo_SetIdentifier, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetData", (PyCFunction) _wrap_PyNs3Icmpv4Echo_SetData, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv4Echo__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv4Echo__tp_clear(PyNs3Icmpv4Echo *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv4Echo *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv4Echo__tp_traverse(PyNs3Icmpv4Echo *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv4Echo__tp_dealloc(PyNs3Icmpv4Echo *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv4Echo__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv4Echo__tp_richcompare (PyNs3Icmpv4Echo *PYBINDGEN_UNUSED(self), PyNs3Icmpv4Echo *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv4Echo_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv4Echo_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv4Echo",            /* tp_name */
    sizeof(PyNs3Icmpv4Echo),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv4Echo__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv4Echo__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv4Echo__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv4Echo__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv4Echo_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv4Echo, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv4Echo__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv4Header__tp_init__0(PyNs3Icmpv4Header *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv4Header *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv4Header_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv4Header(*((PyNs3Icmpv4Header *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv4Header__tp_init__1(PyNs3Icmpv4Header *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv4Header();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv4Header__tp_init(PyNs3Icmpv4Header *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv4Header__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv4Header__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv4Header_SetCode(PyNs3Icmpv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int code;
    const char *keywords[] = {"code", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &code)) {
        return NULL;
    }
    if (code > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetCode(code);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Header_Serialize(PyNs3Icmpv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Header_GetCode(PyNs3Icmpv4Header *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetCode();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Header_Deserialize(PyNs3Icmpv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Header_EnableChecksum(PyNs3Icmpv4Header *self)
{
    PyObject *py_retval;
    
    self->obj->EnableChecksum();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Header_GetType(PyNs3Icmpv4Header *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetType();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Header_GetInstanceTypeId(PyNs3Icmpv4Header *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Header_GetSerializedSize(PyNs3Icmpv4Header *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Header_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv4Header::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4Header_SetType(PyNs3Icmpv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int type;
    const char *keywords[] = {"type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &type)) {
        return NULL;
    }
    if (type > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetType(type);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv4Header__copy__(PyNs3Icmpv4Header *self)
{

    PyNs3Icmpv4Header *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv4Header, &PyNs3Icmpv4Header_Type);
    py_copy->obj = new ns3::Icmpv4Header(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv4Header_methods[] = {
    {(char *) "SetCode", (PyCFunction) _wrap_PyNs3Icmpv4Header_SetCode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv4Header_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetCode", (PyCFunction) _wrap_PyNs3Icmpv4Header_GetCode, METH_NOARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv4Header_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnableChecksum", (PyCFunction) _wrap_PyNs3Icmpv4Header_EnableChecksum, METH_NOARGS, NULL },
    {(char *) "GetType", (PyCFunction) _wrap_PyNs3Icmpv4Header_GetType, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv4Header_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv4Header_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv4Header_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "SetType", (PyCFunction) _wrap_PyNs3Icmpv4Header_SetType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv4Header__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv4Header__tp_clear(PyNs3Icmpv4Header *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv4Header *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv4Header__tp_traverse(PyNs3Icmpv4Header *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv4Header__tp_dealloc(PyNs3Icmpv4Header *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv4Header__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv4Header__tp_richcompare (PyNs3Icmpv4Header *PYBINDGEN_UNUSED(self), PyNs3Icmpv4Header *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv4Header_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv4Header_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv4Header",            /* tp_name */
    sizeof(PyNs3Icmpv4Header),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv4Header__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv4Header__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv4Header__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv4Header__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv4Header_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv4Header, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv4Header__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv4TimeExceeded__tp_init__0(PyNs3Icmpv4TimeExceeded *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv4TimeExceeded *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv4TimeExceeded_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv4TimeExceeded(*((PyNs3Icmpv4TimeExceeded *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv4TimeExceeded__tp_init__1(PyNs3Icmpv4TimeExceeded *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv4TimeExceeded();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv4TimeExceeded__tp_init(PyNs3Icmpv4TimeExceeded *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv4TimeExceeded__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv4TimeExceeded__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv4TimeExceeded_Deserialize(PyNs3Icmpv4TimeExceeded *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4TimeExceeded_GetHeader(PyNs3Icmpv4TimeExceeded *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Header *py_Ipv4Header;
    
    ns3::Ipv4Header retval = self->obj->GetHeader();
    py_Ipv4Header = PyObject_GC_New(PyNs3Ipv4Header, &PyNs3Ipv4Header_Type);
    py_Ipv4Header->inst_dict = NULL;
    py_Ipv4Header->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Header->obj = new ns3::Ipv4Header(retval);
    PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4Header->obj] = (PyObject *) py_Ipv4Header;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Header);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4TimeExceeded_Serialize(PyNs3Icmpv4TimeExceeded *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4TimeExceeded_GetInstanceTypeId(PyNs3Icmpv4TimeExceeded *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4TimeExceeded_GetSerializedSize(PyNs3Icmpv4TimeExceeded *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4TimeExceeded_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv4TimeExceeded::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4TimeExceeded_SetHeader(PyNs3Icmpv4TimeExceeded *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Header *header;
    const char *keywords[] = {"header", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Header_Type, &header)) {
        return NULL;
    }
    self->obj->SetHeader(*((PyNs3Ipv4Header *) header)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4TimeExceeded_SetData(PyNs3Icmpv4TimeExceeded *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *data;
    ns3::Packet *data_ptr;
    const char *keywords[] = {"data", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &data)) {
        return NULL;
    }
    data_ptr = (data ? data->obj : NULL);
    self->obj->SetData(ns3::Ptr< ns3::Packet  > (data_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv4TimeExceeded__copy__(PyNs3Icmpv4TimeExceeded *self)
{

    PyNs3Icmpv4TimeExceeded *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv4TimeExceeded, &PyNs3Icmpv4TimeExceeded_Type);
    py_copy->obj = new ns3::Icmpv4TimeExceeded(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv4TimeExceeded_methods[] = {
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv4TimeExceeded_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetHeader", (PyCFunction) _wrap_PyNs3Icmpv4TimeExceeded_GetHeader, METH_NOARGS, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv4TimeExceeded_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv4TimeExceeded_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv4TimeExceeded_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv4TimeExceeded_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "SetHeader", (PyCFunction) _wrap_PyNs3Icmpv4TimeExceeded_SetHeader, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetData", (PyCFunction) _wrap_PyNs3Icmpv4TimeExceeded_SetData, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv4TimeExceeded__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv4TimeExceeded__tp_clear(PyNs3Icmpv4TimeExceeded *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv4TimeExceeded *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv4TimeExceeded__tp_traverse(PyNs3Icmpv4TimeExceeded *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv4TimeExceeded__tp_dealloc(PyNs3Icmpv4TimeExceeded *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv4TimeExceeded__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv4TimeExceeded__tp_richcompare (PyNs3Icmpv4TimeExceeded *PYBINDGEN_UNUSED(self), PyNs3Icmpv4TimeExceeded *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv4TimeExceeded_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv4TimeExceeded_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv4TimeExceeded",            /* tp_name */
    sizeof(PyNs3Icmpv4TimeExceeded),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv4TimeExceeded__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv4TimeExceeded__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv4TimeExceeded__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv4TimeExceeded__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv4TimeExceeded_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv4TimeExceeded, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv4TimeExceeded__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6Header__tp_init__0(PyNs3Icmpv6Header *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6Header *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6Header_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6Header(*((PyNs3Icmpv6Header *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6Header__tp_init__1(PyNs3Icmpv6Header *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6Header();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6Header__tp_init(PyNs3Icmpv6Header *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6Header__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6Header__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6Header_SetCode(PyNs3Icmpv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int code;
    const char *keywords[] = {"code", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &code)) {
        return NULL;
    }
    if (code > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetCode(code);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Header_Serialize(PyNs3Icmpv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Header_GetCode(PyNs3Icmpv6Header *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetCode();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Header_GetChecksum(PyNs3Icmpv6Header *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetChecksum();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Header_Deserialize(PyNs3Icmpv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Header_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6Header::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Header_GetType(PyNs3Icmpv6Header *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetType();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Header_SetChecksum(PyNs3Icmpv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int checksum;
    const char *keywords[] = {"checksum", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &checksum)) {
        return NULL;
    }
    if (checksum > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetChecksum(checksum);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Header_GetInstanceTypeId(PyNs3Icmpv6Header *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Header_GetSerializedSize(PyNs3Icmpv6Header *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Header_CalculatePseudoHeaderChecksum(PyNs3Icmpv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    int length;
    int protocol;
    const char *keywords[] = {"src", "dst", "length", "protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!ii", (char **) keywords, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &length, &protocol)) {
        return NULL;
    }
    if (length > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (protocol > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->CalculatePseudoHeaderChecksum(*((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, length, protocol);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Header_SetType(PyNs3Icmpv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int type;
    const char *keywords[] = {"type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &type)) {
        return NULL;
    }
    if (type > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetType(type);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6Header__copy__(PyNs3Icmpv6Header *self)
{

    PyNs3Icmpv6Header *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6Header, &PyNs3Icmpv6Header_Type);
    py_copy->obj = new ns3::Icmpv6Header(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6Header_methods[] = {
    {(char *) "SetCode", (PyCFunction) _wrap_PyNs3Icmpv6Header_SetCode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6Header_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetCode", (PyCFunction) _wrap_PyNs3Icmpv6Header_GetCode, METH_NOARGS, NULL },
    {(char *) "GetChecksum", (PyCFunction) _wrap_PyNs3Icmpv6Header_GetChecksum, METH_NOARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6Header_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6Header_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetType", (PyCFunction) _wrap_PyNs3Icmpv6Header_GetType, METH_NOARGS, NULL },
    {(char *) "SetChecksum", (PyCFunction) _wrap_PyNs3Icmpv6Header_SetChecksum, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6Header_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6Header_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "CalculatePseudoHeaderChecksum", (PyCFunction) _wrap_PyNs3Icmpv6Header_CalculatePseudoHeaderChecksum, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetType", (PyCFunction) _wrap_PyNs3Icmpv6Header_SetType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6Header__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6Header__tp_clear(PyNs3Icmpv6Header *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6Header *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6Header__tp_traverse(PyNs3Icmpv6Header *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6Header__tp_dealloc(PyNs3Icmpv6Header *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6Header__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6Header__tp_richcompare (PyNs3Icmpv6Header *PYBINDGEN_UNUSED(self), PyNs3Icmpv6Header *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6Header_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6Header_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6Header",            /* tp_name */
    sizeof(PyNs3Icmpv6Header),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6Header__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6Header__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6Header__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6Header__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6Header_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6Header, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6Header__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6NA__tp_init__0(PyNs3Icmpv6NA *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6NA *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6NA_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6NA(*((PyNs3Icmpv6NA *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6NA__tp_init__1(PyNs3Icmpv6NA *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6NA();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6NA__tp_init(PyNs3Icmpv6NA *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6NA__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6NA__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6NA_GetFlagO(PyNs3Icmpv6NA *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->GetFlagO();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_GetReserved(PyNs3Icmpv6NA *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetReserved();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_SetFlagO(PyNs3Icmpv6NA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool o;
    PyObject *py_o;
    const char *keywords[] = {"o", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_o)) {
        return NULL;
    }
    o = (bool) PyObject_IsTrue(py_o);
    self->obj->SetFlagO(o);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_Deserialize(PyNs3Icmpv6NA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_SetReserved(PyNs3Icmpv6NA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int reserved;
    const char *keywords[] = {"reserved", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &reserved)) {
        return NULL;
    }
    self->obj->SetReserved(reserved);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_SetIpv6Target(PyNs3Icmpv6NA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *target;
    const char *keywords[] = {"target", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &target)) {
        return NULL;
    }
    self->obj->SetIpv6Target(*((PyNs3Ipv6Address *) target)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6NA::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_Serialize(PyNs3Icmpv6NA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_SetFlagR(PyNs3Icmpv6NA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool r;
    PyObject *py_r;
    const char *keywords[] = {"r", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_r)) {
        return NULL;
    }
    r = (bool) PyObject_IsTrue(py_r);
    self->obj->SetFlagR(r);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_GetIpv6Target(PyNs3Icmpv6NA *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetIpv6Target();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_GetInstanceTypeId(PyNs3Icmpv6NA *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_GetSerializedSize(PyNs3Icmpv6NA *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_SetFlagS(PyNs3Icmpv6NA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool s;
    PyObject *py_s;
    const char *keywords[] = {"s", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_s)) {
        return NULL;
    }
    s = (bool) PyObject_IsTrue(py_s);
    self->obj->SetFlagS(s);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_GetFlagR(PyNs3Icmpv6NA *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->GetFlagR();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NA_GetFlagS(PyNs3Icmpv6NA *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->GetFlagS();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6NA__copy__(PyNs3Icmpv6NA *self)
{

    PyNs3Icmpv6NA *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6NA, &PyNs3Icmpv6NA_Type);
    py_copy->obj = new ns3::Icmpv6NA(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6NA_methods[] = {
    {(char *) "GetFlagO", (PyCFunction) _wrap_PyNs3Icmpv6NA_GetFlagO, METH_NOARGS, NULL },
    {(char *) "GetReserved", (PyCFunction) _wrap_PyNs3Icmpv6NA_GetReserved, METH_NOARGS, NULL },
    {(char *) "SetFlagO", (PyCFunction) _wrap_PyNs3Icmpv6NA_SetFlagO, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6NA_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetReserved", (PyCFunction) _wrap_PyNs3Icmpv6NA_SetReserved, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetIpv6Target", (PyCFunction) _wrap_PyNs3Icmpv6NA_SetIpv6Target, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6NA_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6NA_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetFlagR", (PyCFunction) _wrap_PyNs3Icmpv6NA_SetFlagR, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetIpv6Target", (PyCFunction) _wrap_PyNs3Icmpv6NA_GetIpv6Target, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6NA_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6NA_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetFlagS", (PyCFunction) _wrap_PyNs3Icmpv6NA_SetFlagS, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetFlagR", (PyCFunction) _wrap_PyNs3Icmpv6NA_GetFlagR, METH_NOARGS, NULL },
    {(char *) "GetFlagS", (PyCFunction) _wrap_PyNs3Icmpv6NA_GetFlagS, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6NA__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6NA__tp_clear(PyNs3Icmpv6NA *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6NA *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6NA__tp_traverse(PyNs3Icmpv6NA *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6NA__tp_dealloc(PyNs3Icmpv6NA *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6NA__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6NA__tp_richcompare (PyNs3Icmpv6NA *PYBINDGEN_UNUSED(self), PyNs3Icmpv6NA *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6NA_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6NA_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6NA",            /* tp_name */
    sizeof(PyNs3Icmpv6NA),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6NA__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6NA__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6NA__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6NA__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6NA_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6NA, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6NA__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6NS__tp_init__0(PyNs3Icmpv6NS *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6NS *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6NS_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6NS(*((PyNs3Icmpv6NS *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6NS__tp_init__1(PyNs3Icmpv6NS *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6Address *target;
    const char *keywords[] = {"target", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &target)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6NS(*((PyNs3Ipv6Address *) target)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6NS__tp_init__2(PyNs3Icmpv6NS *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6NS();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6NS__tp_init(PyNs3Icmpv6NS *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Icmpv6NS__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6NS__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6NS__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6NS_GetReserved(PyNs3Icmpv6NS *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetReserved();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NS_Deserialize(PyNs3Icmpv6NS *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NS_SetReserved(PyNs3Icmpv6NS *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int reserved;
    const char *keywords[] = {"reserved", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &reserved)) {
        return NULL;
    }
    self->obj->SetReserved(reserved);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NS_SetIpv6Target(PyNs3Icmpv6NS *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *target;
    const char *keywords[] = {"target", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &target)) {
        return NULL;
    }
    self->obj->SetIpv6Target(*((PyNs3Ipv6Address *) target)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NS_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6NS::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NS_Serialize(PyNs3Icmpv6NS *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NS_GetIpv6Target(PyNs3Icmpv6NS *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetIpv6Target();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NS_GetInstanceTypeId(PyNs3Icmpv6NS *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6NS_GetSerializedSize(PyNs3Icmpv6NS *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6NS__copy__(PyNs3Icmpv6NS *self)
{

    PyNs3Icmpv6NS *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6NS, &PyNs3Icmpv6NS_Type);
    py_copy->obj = new ns3::Icmpv6NS(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6NS_methods[] = {
    {(char *) "GetReserved", (PyCFunction) _wrap_PyNs3Icmpv6NS_GetReserved, METH_NOARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6NS_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetReserved", (PyCFunction) _wrap_PyNs3Icmpv6NS_SetReserved, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetIpv6Target", (PyCFunction) _wrap_PyNs3Icmpv6NS_SetIpv6Target, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6NS_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6NS_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetIpv6Target", (PyCFunction) _wrap_PyNs3Icmpv6NS_GetIpv6Target, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6NS_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6NS_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6NS__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6NS__tp_clear(PyNs3Icmpv6NS *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6NS *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6NS__tp_traverse(PyNs3Icmpv6NS *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6NS__tp_dealloc(PyNs3Icmpv6NS *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6NS__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6NS__tp_richcompare (PyNs3Icmpv6NS *PYBINDGEN_UNUSED(self), PyNs3Icmpv6NS *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6NS_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6NS_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6NS",            /* tp_name */
    sizeof(PyNs3Icmpv6NS),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6NS__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6NS__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6NS__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6NS__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6NS_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6NS, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6NS__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6OptionHeader__tp_init__0(PyNs3Icmpv6OptionHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6OptionHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6OptionHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionHeader(*((PyNs3Icmpv6OptionHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6OptionHeader__tp_init__1(PyNs3Icmpv6OptionHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6OptionHeader__tp_init(PyNs3Icmpv6OptionHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6OptionHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6OptionHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6OptionHeader_Serialize(PyNs3Icmpv6OptionHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionHeader_Deserialize(PyNs3Icmpv6OptionHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionHeader_GetLength(PyNs3Icmpv6OptionHeader *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetLength();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6OptionHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionHeader_GetType(PyNs3Icmpv6OptionHeader *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetType();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionHeader_GetInstanceTypeId(PyNs3Icmpv6OptionHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionHeader_GetSerializedSize(PyNs3Icmpv6OptionHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionHeader_SetLength(PyNs3Icmpv6OptionHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int len;
    const char *keywords[] = {"len", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &len)) {
        return NULL;
    }
    if (len > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetLength(len);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionHeader_SetType(PyNs3Icmpv6OptionHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int type;
    const char *keywords[] = {"type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &type)) {
        return NULL;
    }
    if (type > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetType(type);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6OptionHeader__copy__(PyNs3Icmpv6OptionHeader *self)
{

    PyNs3Icmpv6OptionHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6OptionHeader, &PyNs3Icmpv6OptionHeader_Type);
    py_copy->obj = new ns3::Icmpv6OptionHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6OptionHeader_methods[] = {
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6OptionHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6OptionHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLength", (PyCFunction) _wrap_PyNs3Icmpv6OptionHeader_GetLength, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6OptionHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetType", (PyCFunction) _wrap_PyNs3Icmpv6OptionHeader_GetType, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6OptionHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6OptionHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetLength", (PyCFunction) _wrap_PyNs3Icmpv6OptionHeader_SetLength, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetType", (PyCFunction) _wrap_PyNs3Icmpv6OptionHeader_SetType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6OptionHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6OptionHeader__tp_clear(PyNs3Icmpv6OptionHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6OptionHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6OptionHeader__tp_traverse(PyNs3Icmpv6OptionHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6OptionHeader__tp_dealloc(PyNs3Icmpv6OptionHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6OptionHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6OptionHeader__tp_richcompare (PyNs3Icmpv6OptionHeader *PYBINDGEN_UNUSED(self), PyNs3Icmpv6OptionHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6OptionHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6OptionHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6OptionHeader",            /* tp_name */
    sizeof(PyNs3Icmpv6OptionHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6OptionHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6OptionHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6OptionHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6OptionHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6OptionHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6OptionHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6OptionHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_init__0(PyNs3Icmpv6OptionLinkLayerAddress *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6OptionLinkLayerAddress *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6OptionLinkLayerAddress_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionLinkLayerAddress(*((PyNs3Icmpv6OptionLinkLayerAddress *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_init__1(PyNs3Icmpv6OptionLinkLayerAddress *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    bool source;
    PyObject *py_source;
    const char *keywords[] = {"source", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_source)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    source = (bool) PyObject_IsTrue(py_source);
    self->obj = new ns3::Icmpv6OptionLinkLayerAddress(source);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_init__2(PyNs3Icmpv6OptionLinkLayerAddress *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    bool source;
    PyObject *py_source;
    PyObject *addr;
    ns3::Address addr2;
    const char *keywords[] = {"source", "addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OO", (char **) keywords, &py_source, &addr)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    source = (bool) PyObject_IsTrue(py_source);
    if (PyObject_IsInstance(addr, (PyObject*) &PyNs3Address_Type)) {
        addr2 = *((PyNs3Address *) addr)->obj;
    } else if (PyObject_IsInstance(addr, (PyObject*) &PyNs3Ipv4Address_Type)) {
        addr2 = *((PyNs3Ipv4Address *) addr)->obj;
    } else if (PyObject_IsInstance(addr, (PyObject*) &PyNs3Ipv6Address_Type)) {
        addr2 = *((PyNs3Ipv6Address *) addr)->obj;
    } else if (PyObject_IsInstance(addr, (PyObject*) &PyNs3Mac48Address_Type)) {
        addr2 = *((PyNs3Mac48Address *) addr)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", addr->ob_type->tp_name);
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionLinkLayerAddress(source, addr2);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_init__3(PyNs3Icmpv6OptionLinkLayerAddress *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionLinkLayerAddress();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_init(PyNs3Icmpv6OptionLinkLayerAddress *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[4] = {0,};
    retval = _wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_init__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    error_list = PyList_New(4);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6OptionLinkLayerAddress_Deserialize(PyNs3Icmpv6OptionLinkLayerAddress *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionLinkLayerAddress_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6OptionLinkLayerAddress::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionLinkLayerAddress_Serialize(PyNs3Icmpv6OptionLinkLayerAddress *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionLinkLayerAddress_GetAddress(PyNs3Icmpv6OptionLinkLayerAddress *self)
{
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    ns3::Address retval = self->obj->GetAddress();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionLinkLayerAddress_GetInstanceTypeId(PyNs3Icmpv6OptionLinkLayerAddress *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionLinkLayerAddress_GetSerializedSize(PyNs3Icmpv6OptionLinkLayerAddress *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionLinkLayerAddress_SetAddress(PyNs3Icmpv6OptionLinkLayerAddress *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *addr;
    ns3::Address addr2;
    const char *keywords[] = {"addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &addr)) {
        return NULL;
    }
    if (PyObject_IsInstance(addr, (PyObject*) &PyNs3Address_Type)) {
        addr2 = *((PyNs3Address *) addr)->obj;
    } else if (PyObject_IsInstance(addr, (PyObject*) &PyNs3Ipv4Address_Type)) {
        addr2 = *((PyNs3Ipv4Address *) addr)->obj;
    } else if (PyObject_IsInstance(addr, (PyObject*) &PyNs3Ipv6Address_Type)) {
        addr2 = *((PyNs3Ipv6Address *) addr)->obj;
    } else if (PyObject_IsInstance(addr, (PyObject*) &PyNs3Mac48Address_Type)) {
        addr2 = *((PyNs3Mac48Address *) addr)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", addr->ob_type->tp_name);
        return NULL;
    }
    self->obj->SetAddress(addr2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6OptionLinkLayerAddress__copy__(PyNs3Icmpv6OptionLinkLayerAddress *self)
{

    PyNs3Icmpv6OptionLinkLayerAddress *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6OptionLinkLayerAddress, &PyNs3Icmpv6OptionLinkLayerAddress_Type);
    py_copy->obj = new ns3::Icmpv6OptionLinkLayerAddress(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6OptionLinkLayerAddress_methods[] = {
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6OptionLinkLayerAddress_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6OptionLinkLayerAddress_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6OptionLinkLayerAddress_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Icmpv6OptionLinkLayerAddress_GetAddress, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6OptionLinkLayerAddress_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6OptionLinkLayerAddress_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetAddress", (PyCFunction) _wrap_PyNs3Icmpv6OptionLinkLayerAddress_SetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6OptionLinkLayerAddress__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6OptionLinkLayerAddress__tp_clear(PyNs3Icmpv6OptionLinkLayerAddress *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6OptionLinkLayerAddress *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6OptionLinkLayerAddress__tp_traverse(PyNs3Icmpv6OptionLinkLayerAddress *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_dealloc(PyNs3Icmpv6OptionLinkLayerAddress *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6OptionLinkLayerAddress__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_richcompare (PyNs3Icmpv6OptionLinkLayerAddress *PYBINDGEN_UNUSED(self), PyNs3Icmpv6OptionLinkLayerAddress *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6OptionLinkLayerAddress_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6OptionLinkLayerAddress_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6OptionLinkLayerAddress",            /* tp_name */
    sizeof(PyNs3Icmpv6OptionLinkLayerAddress),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6OptionLinkLayerAddress__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6OptionLinkLayerAddress__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6OptionLinkLayerAddress_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6OptionLinkLayerAddress, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6OptionLinkLayerAddress__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6OptionMtu__tp_init__0(PyNs3Icmpv6OptionMtu *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6OptionMtu *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6OptionMtu_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionMtu(*((PyNs3Icmpv6OptionMtu *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6OptionMtu__tp_init__1(PyNs3Icmpv6OptionMtu *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionMtu();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6OptionMtu__tp_init__2(PyNs3Icmpv6OptionMtu *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    unsigned int mtu;
    const char *keywords[] = {"mtu", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &mtu)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionMtu(mtu);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6OptionMtu__tp_init(PyNs3Icmpv6OptionMtu *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Icmpv6OptionMtu__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6OptionMtu__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6OptionMtu__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6OptionMtu_GetReserved(PyNs3Icmpv6OptionMtu *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetReserved();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionMtu_Deserialize(PyNs3Icmpv6OptionMtu *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionMtu_SetReserved(PyNs3Icmpv6OptionMtu *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int reserved;
    const char *keywords[] = {"reserved", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &reserved)) {
        return NULL;
    }
    if (reserved > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetReserved(reserved);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionMtu_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6OptionMtu::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionMtu_Serialize(PyNs3Icmpv6OptionMtu *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionMtu_GetMtu(PyNs3Icmpv6OptionMtu *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetMtu();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionMtu_GetInstanceTypeId(PyNs3Icmpv6OptionMtu *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionMtu_GetSerializedSize(PyNs3Icmpv6OptionMtu *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionMtu_SetMtu(PyNs3Icmpv6OptionMtu *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int mtu;
    const char *keywords[] = {"mtu", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &mtu)) {
        return NULL;
    }
    self->obj->SetMtu(mtu);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6OptionMtu__copy__(PyNs3Icmpv6OptionMtu *self)
{

    PyNs3Icmpv6OptionMtu *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6OptionMtu, &PyNs3Icmpv6OptionMtu_Type);
    py_copy->obj = new ns3::Icmpv6OptionMtu(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6OptionMtu_methods[] = {
    {(char *) "GetReserved", (PyCFunction) _wrap_PyNs3Icmpv6OptionMtu_GetReserved, METH_NOARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6OptionMtu_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetReserved", (PyCFunction) _wrap_PyNs3Icmpv6OptionMtu_SetReserved, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6OptionMtu_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6OptionMtu_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMtu", (PyCFunction) _wrap_PyNs3Icmpv6OptionMtu_GetMtu, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6OptionMtu_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6OptionMtu_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetMtu", (PyCFunction) _wrap_PyNs3Icmpv6OptionMtu_SetMtu, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6OptionMtu__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6OptionMtu__tp_clear(PyNs3Icmpv6OptionMtu *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6OptionMtu *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6OptionMtu__tp_traverse(PyNs3Icmpv6OptionMtu *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6OptionMtu__tp_dealloc(PyNs3Icmpv6OptionMtu *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6OptionMtu__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6OptionMtu__tp_richcompare (PyNs3Icmpv6OptionMtu *PYBINDGEN_UNUSED(self), PyNs3Icmpv6OptionMtu *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6OptionMtu_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6OptionMtu_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6OptionMtu",            /* tp_name */
    sizeof(PyNs3Icmpv6OptionMtu),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6OptionMtu__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6OptionMtu__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6OptionMtu__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6OptionMtu__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6OptionMtu_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6OptionMtu, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6OptionMtu__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6OptionPrefixInformation__tp_init__0(PyNs3Icmpv6OptionPrefixInformation *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6OptionPrefixInformation *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6OptionPrefixInformation_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionPrefixInformation(*((PyNs3Icmpv6OptionPrefixInformation *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6OptionPrefixInformation__tp_init__1(PyNs3Icmpv6OptionPrefixInformation *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionPrefixInformation();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6OptionPrefixInformation__tp_init__2(PyNs3Icmpv6OptionPrefixInformation *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6Address *network;
    int prefixlen;
    const char *keywords[] = {"network", "prefixlen", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!i", (char **) keywords, &PyNs3Ipv6Address_Type, &network, &prefixlen)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (prefixlen > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionPrefixInformation(*((PyNs3Ipv6Address *) network)->obj, prefixlen);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6OptionPrefixInformation__tp_init(PyNs3Icmpv6OptionPrefixInformation *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Icmpv6OptionPrefixInformation__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6OptionPrefixInformation__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6OptionPrefixInformation__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_GetValidTime(PyNs3Icmpv6OptionPrefixInformation *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetValidTime();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_GetReserved(PyNs3Icmpv6OptionPrefixInformation *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetReserved();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_Deserialize(PyNs3Icmpv6OptionPrefixInformation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_SetReserved(PyNs3Icmpv6OptionPrefixInformation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int reserved;
    const char *keywords[] = {"reserved", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &reserved)) {
        return NULL;
    }
    self->obj->SetReserved(reserved);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_GetPreferredTime(PyNs3Icmpv6OptionPrefixInformation *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetPreferredTime();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6OptionPrefixInformation::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_Serialize(PyNs3Icmpv6OptionPrefixInformation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_SetPreferredTime(PyNs3Icmpv6OptionPrefixInformation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int preferredTime;
    const char *keywords[] = {"preferredTime", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &preferredTime)) {
        return NULL;
    }
    self->obj->SetPreferredTime(preferredTime);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_SetValidTime(PyNs3Icmpv6OptionPrefixInformation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int validTime;
    const char *keywords[] = {"validTime", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &validTime)) {
        return NULL;
    }
    self->obj->SetValidTime(validTime);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_SetPrefix(PyNs3Icmpv6OptionPrefixInformation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *prefix;
    const char *keywords[] = {"prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &prefix)) {
        return NULL;
    }
    self->obj->SetPrefix(*((PyNs3Ipv6Address *) prefix)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_GetPrefix(PyNs3Icmpv6OptionPrefixInformation *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetPrefix();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_GetPrefixLength(PyNs3Icmpv6OptionPrefixInformation *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetPrefixLength();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_GetInstanceTypeId(PyNs3Icmpv6OptionPrefixInformation *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_GetSerializedSize(PyNs3Icmpv6OptionPrefixInformation *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_SetFlags(PyNs3Icmpv6OptionPrefixInformation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int flags;
    const char *keywords[] = {"flags", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &flags)) {
        return NULL;
    }
    if (flags > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetFlags(flags);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_GetFlags(PyNs3Icmpv6OptionPrefixInformation *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetFlags();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionPrefixInformation_SetPrefixLength(PyNs3Icmpv6OptionPrefixInformation *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int prefixLength;
    const char *keywords[] = {"prefixLength", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &prefixLength)) {
        return NULL;
    }
    if (prefixLength > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetPrefixLength(prefixLength);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6OptionPrefixInformation__copy__(PyNs3Icmpv6OptionPrefixInformation *self)
{

    PyNs3Icmpv6OptionPrefixInformation *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6OptionPrefixInformation, &PyNs3Icmpv6OptionPrefixInformation_Type);
    py_copy->obj = new ns3::Icmpv6OptionPrefixInformation(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6OptionPrefixInformation_methods[] = {
    {(char *) "GetValidTime", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_GetValidTime, METH_NOARGS, NULL },
    {(char *) "GetReserved", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_GetReserved, METH_NOARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetReserved", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_SetReserved, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetPreferredTime", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_GetPreferredTime, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPreferredTime", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_SetPreferredTime, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetValidTime", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_SetValidTime, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPrefix", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_SetPrefix, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetPrefix", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_GetPrefix, METH_NOARGS, NULL },
    {(char *) "GetPrefixLength", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_GetPrefixLength, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetFlags", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_SetFlags, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetFlags", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_GetFlags, METH_NOARGS, NULL },
    {(char *) "SetPrefixLength", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation_SetPrefixLength, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6OptionPrefixInformation__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6OptionPrefixInformation__tp_clear(PyNs3Icmpv6OptionPrefixInformation *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6OptionPrefixInformation *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6OptionPrefixInformation__tp_traverse(PyNs3Icmpv6OptionPrefixInformation *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6OptionPrefixInformation__tp_dealloc(PyNs3Icmpv6OptionPrefixInformation *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6OptionPrefixInformation__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6OptionPrefixInformation__tp_richcompare (PyNs3Icmpv6OptionPrefixInformation *PYBINDGEN_UNUSED(self), PyNs3Icmpv6OptionPrefixInformation *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6OptionPrefixInformation_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6OptionPrefixInformation_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6OptionPrefixInformation",            /* tp_name */
    sizeof(PyNs3Icmpv6OptionPrefixInformation),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6OptionPrefixInformation__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6OptionPrefixInformation__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6OptionPrefixInformation__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6OptionPrefixInformation__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6OptionPrefixInformation_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6OptionPrefixInformation, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6OptionPrefixInformation__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6OptionRedirected__tp_init__0(PyNs3Icmpv6OptionRedirected *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6OptionRedirected *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6OptionRedirected_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionRedirected(*((PyNs3Icmpv6OptionRedirected *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6OptionRedirected__tp_init__1(PyNs3Icmpv6OptionRedirected *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6OptionRedirected();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6OptionRedirected__tp_init(PyNs3Icmpv6OptionRedirected *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6OptionRedirected__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6OptionRedirected__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6OptionRedirected_SetPacket(PyNs3Icmpv6OptionRedirected *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    const char *keywords[] = {"packet", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &packet)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    self->obj->SetPacket(ns3::Ptr< ns3::Packet  > (packet_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionRedirected_Deserialize(PyNs3Icmpv6OptionRedirected *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionRedirected_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6OptionRedirected::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionRedirected_Serialize(PyNs3Icmpv6OptionRedirected *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionRedirected_GetPacket(PyNs3Icmpv6OptionRedirected *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetPacket();
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (retval))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionRedirected_GetInstanceTypeId(PyNs3Icmpv6OptionRedirected *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6OptionRedirected_GetSerializedSize(PyNs3Icmpv6OptionRedirected *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6OptionRedirected__copy__(PyNs3Icmpv6OptionRedirected *self)
{

    PyNs3Icmpv6OptionRedirected *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6OptionRedirected, &PyNs3Icmpv6OptionRedirected_Type);
    py_copy->obj = new ns3::Icmpv6OptionRedirected(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6OptionRedirected_methods[] = {
    {(char *) "SetPacket", (PyCFunction) _wrap_PyNs3Icmpv6OptionRedirected_SetPacket, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6OptionRedirected_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6OptionRedirected_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6OptionRedirected_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetPacket", (PyCFunction) _wrap_PyNs3Icmpv6OptionRedirected_GetPacket, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6OptionRedirected_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6OptionRedirected_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6OptionRedirected__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6OptionRedirected__tp_clear(PyNs3Icmpv6OptionRedirected *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6OptionRedirected *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6OptionRedirected__tp_traverse(PyNs3Icmpv6OptionRedirected *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6OptionRedirected__tp_dealloc(PyNs3Icmpv6OptionRedirected *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6OptionRedirected__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6OptionRedirected__tp_richcompare (PyNs3Icmpv6OptionRedirected *PYBINDGEN_UNUSED(self), PyNs3Icmpv6OptionRedirected *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6OptionRedirected_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6OptionRedirected_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6OptionRedirected",            /* tp_name */
    sizeof(PyNs3Icmpv6OptionRedirected),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6OptionRedirected__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6OptionRedirected__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6OptionRedirected__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6OptionRedirected__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6OptionRedirected_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6OptionRedirected, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6OptionRedirected__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6ParameterError__tp_init__0(PyNs3Icmpv6ParameterError *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6ParameterError *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6ParameterError_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6ParameterError(*((PyNs3Icmpv6ParameterError *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6ParameterError__tp_init__1(PyNs3Icmpv6ParameterError *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6ParameterError();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6ParameterError__tp_init(PyNs3Icmpv6ParameterError *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6ParameterError__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6ParameterError__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6ParameterError_SetPacket(PyNs3Icmpv6ParameterError *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &p)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    self->obj->SetPacket(ns3::Ptr< ns3::Packet  > (p_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6ParameterError_Deserialize(PyNs3Icmpv6ParameterError *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6ParameterError_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6ParameterError::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6ParameterError_Serialize(PyNs3Icmpv6ParameterError *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6ParameterError_SetPtr(PyNs3Icmpv6ParameterError *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int ptr;
    const char *keywords[] = {"ptr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &ptr)) {
        return NULL;
    }
    self->obj->SetPtr(ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6ParameterError_GetPtr(PyNs3Icmpv6ParameterError *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetPtr();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6ParameterError_GetPacket(PyNs3Icmpv6ParameterError *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetPacket();
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (retval))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6ParameterError_GetInstanceTypeId(PyNs3Icmpv6ParameterError *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6ParameterError_GetSerializedSize(PyNs3Icmpv6ParameterError *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6ParameterError__copy__(PyNs3Icmpv6ParameterError *self)
{

    PyNs3Icmpv6ParameterError *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6ParameterError, &PyNs3Icmpv6ParameterError_Type);
    py_copy->obj = new ns3::Icmpv6ParameterError(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6ParameterError_methods[] = {
    {(char *) "SetPacket", (PyCFunction) _wrap_PyNs3Icmpv6ParameterError_SetPacket, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6ParameterError_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6ParameterError_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6ParameterError_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPtr", (PyCFunction) _wrap_PyNs3Icmpv6ParameterError_SetPtr, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetPtr", (PyCFunction) _wrap_PyNs3Icmpv6ParameterError_GetPtr, METH_NOARGS, NULL },
    {(char *) "GetPacket", (PyCFunction) _wrap_PyNs3Icmpv6ParameterError_GetPacket, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6ParameterError_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6ParameterError_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6ParameterError__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6ParameterError__tp_clear(PyNs3Icmpv6ParameterError *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6ParameterError *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6ParameterError__tp_traverse(PyNs3Icmpv6ParameterError *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6ParameterError__tp_dealloc(PyNs3Icmpv6ParameterError *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6ParameterError__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6ParameterError__tp_richcompare (PyNs3Icmpv6ParameterError *PYBINDGEN_UNUSED(self), PyNs3Icmpv6ParameterError *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6ParameterError_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6ParameterError_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6ParameterError",            /* tp_name */
    sizeof(PyNs3Icmpv6ParameterError),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6ParameterError__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6ParameterError__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6ParameterError__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6ParameterError__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6ParameterError_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6ParameterError, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6ParameterError__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6RA__tp_init__0(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6RA *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6RA_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6RA(*((PyNs3Icmpv6RA *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6RA__tp_init__1(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6RA();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6RA__tp_init(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6RA__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6RA__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6RA_GetFlagO(PyNs3Icmpv6RA *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->GetFlagO();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_GetCurHopLimit(PyNs3Icmpv6RA *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetCurHopLimit();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_GetFlagM(PyNs3Icmpv6RA *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->GetFlagM();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_Deserialize(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_GetFlagH(PyNs3Icmpv6RA *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->GetFlagH();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_SetFlagM(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool m;
    PyObject *py_m;
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_m)) {
        return NULL;
    }
    m = (bool) PyObject_IsTrue(py_m);
    self->obj->SetFlagM(m);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6RA::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_Serialize(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_SetFlagH(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool h;
    PyObject *py_h;
    const char *keywords[] = {"h", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_h)) {
        return NULL;
    }
    h = (bool) PyObject_IsTrue(py_h);
    self->obj->SetFlagH(h);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_GetLifeTime(PyNs3Icmpv6RA *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetLifeTime();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_SetRetransmissionTime(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int r;
    const char *keywords[] = {"r", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &r)) {
        return NULL;
    }
    self->obj->SetRetransmissionTime(r);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_GetRetransmissionTime(PyNs3Icmpv6RA *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetRetransmissionTime();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_SetReachableTime(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int r;
    const char *keywords[] = {"r", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &r)) {
        return NULL;
    }
    self->obj->SetReachableTime(r);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_SetCurHopLimit(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int m;
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &m)) {
        return NULL;
    }
    if (m > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetCurHopLimit(m);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_GetInstanceTypeId(PyNs3Icmpv6RA *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_GetSerializedSize(PyNs3Icmpv6RA *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_SetFlags(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int f;
    const char *keywords[] = {"f", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &f)) {
        return NULL;
    }
    if (f > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetFlags(f);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_SetLifeTime(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int l;
    const char *keywords[] = {"l", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &l)) {
        return NULL;
    }
    if (l > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetLifeTime(l);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_GetFlags(PyNs3Icmpv6RA *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetFlags();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_GetReachableTime(PyNs3Icmpv6RA *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetReachableTime();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RA_SetFlagO(PyNs3Icmpv6RA *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool o;
    PyObject *py_o;
    const char *keywords[] = {"o", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_o)) {
        return NULL;
    }
    o = (bool) PyObject_IsTrue(py_o);
    self->obj->SetFlagO(o);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6RA__copy__(PyNs3Icmpv6RA *self)
{

    PyNs3Icmpv6RA *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6RA, &PyNs3Icmpv6RA_Type);
    py_copy->obj = new ns3::Icmpv6RA(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6RA_methods[] = {
    {(char *) "GetFlagO", (PyCFunction) _wrap_PyNs3Icmpv6RA_GetFlagO, METH_NOARGS, NULL },
    {(char *) "GetCurHopLimit", (PyCFunction) _wrap_PyNs3Icmpv6RA_GetCurHopLimit, METH_NOARGS, NULL },
    {(char *) "GetFlagM", (PyCFunction) _wrap_PyNs3Icmpv6RA_GetFlagM, METH_NOARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6RA_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetFlagH", (PyCFunction) _wrap_PyNs3Icmpv6RA_GetFlagH, METH_NOARGS, NULL },
    {(char *) "SetFlagM", (PyCFunction) _wrap_PyNs3Icmpv6RA_SetFlagM, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6RA_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6RA_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetFlagH", (PyCFunction) _wrap_PyNs3Icmpv6RA_SetFlagH, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLifeTime", (PyCFunction) _wrap_PyNs3Icmpv6RA_GetLifeTime, METH_NOARGS, NULL },
    {(char *) "SetRetransmissionTime", (PyCFunction) _wrap_PyNs3Icmpv6RA_SetRetransmissionTime, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetRetransmissionTime", (PyCFunction) _wrap_PyNs3Icmpv6RA_GetRetransmissionTime, METH_NOARGS, NULL },
    {(char *) "SetReachableTime", (PyCFunction) _wrap_PyNs3Icmpv6RA_SetReachableTime, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetCurHopLimit", (PyCFunction) _wrap_PyNs3Icmpv6RA_SetCurHopLimit, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6RA_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6RA_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetFlags", (PyCFunction) _wrap_PyNs3Icmpv6RA_SetFlags, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetLifeTime", (PyCFunction) _wrap_PyNs3Icmpv6RA_SetLifeTime, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetFlags", (PyCFunction) _wrap_PyNs3Icmpv6RA_GetFlags, METH_NOARGS, NULL },
    {(char *) "GetReachableTime", (PyCFunction) _wrap_PyNs3Icmpv6RA_GetReachableTime, METH_NOARGS, NULL },
    {(char *) "SetFlagO", (PyCFunction) _wrap_PyNs3Icmpv6RA_SetFlagO, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6RA__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6RA__tp_clear(PyNs3Icmpv6RA *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6RA *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6RA__tp_traverse(PyNs3Icmpv6RA *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6RA__tp_dealloc(PyNs3Icmpv6RA *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6RA__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6RA__tp_richcompare (PyNs3Icmpv6RA *PYBINDGEN_UNUSED(self), PyNs3Icmpv6RA *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6RA_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6RA_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6RA",            /* tp_name */
    sizeof(PyNs3Icmpv6RA),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6RA__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6RA__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6RA__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6RA__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6RA_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6RA, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6RA__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6RS__tp_init__0(PyNs3Icmpv6RS *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6RS *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6RS_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6RS(*((PyNs3Icmpv6RS *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6RS__tp_init__1(PyNs3Icmpv6RS *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6RS();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6RS__tp_init(PyNs3Icmpv6RS *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6RS__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6RS__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6RS_GetReserved(PyNs3Icmpv6RS *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetReserved();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RS_Deserialize(PyNs3Icmpv6RS *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RS_SetReserved(PyNs3Icmpv6RS *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int reserved;
    const char *keywords[] = {"reserved", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &reserved)) {
        return NULL;
    }
    self->obj->SetReserved(reserved);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RS_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6RS::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RS_Serialize(PyNs3Icmpv6RS *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RS_GetInstanceTypeId(PyNs3Icmpv6RS *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6RS_GetSerializedSize(PyNs3Icmpv6RS *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6RS__copy__(PyNs3Icmpv6RS *self)
{

    PyNs3Icmpv6RS *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6RS, &PyNs3Icmpv6RS_Type);
    py_copy->obj = new ns3::Icmpv6RS(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6RS_methods[] = {
    {(char *) "GetReserved", (PyCFunction) _wrap_PyNs3Icmpv6RS_GetReserved, METH_NOARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6RS_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetReserved", (PyCFunction) _wrap_PyNs3Icmpv6RS_SetReserved, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6RS_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6RS_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6RS_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6RS_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6RS__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6RS__tp_clear(PyNs3Icmpv6RS *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6RS *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6RS__tp_traverse(PyNs3Icmpv6RS *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6RS__tp_dealloc(PyNs3Icmpv6RS *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6RS__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6RS__tp_richcompare (PyNs3Icmpv6RS *PYBINDGEN_UNUSED(self), PyNs3Icmpv6RS *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6RS_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6RS_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6RS",            /* tp_name */
    sizeof(PyNs3Icmpv6RS),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6RS__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6RS__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6RS__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6RS__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6RS_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6RS, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6RS__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6Redirection__tp_init__0(PyNs3Icmpv6Redirection *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6Redirection *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6Redirection_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6Redirection(*((PyNs3Icmpv6Redirection *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6Redirection__tp_init__1(PyNs3Icmpv6Redirection *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6Redirection();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6Redirection__tp_init(PyNs3Icmpv6Redirection *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6Redirection__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6Redirection__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6Redirection_GetReserved(PyNs3Icmpv6Redirection *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetReserved();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Redirection_Deserialize(PyNs3Icmpv6Redirection *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Redirection_SetReserved(PyNs3Icmpv6Redirection *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int reserved;
    const char *keywords[] = {"reserved", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &reserved)) {
        return NULL;
    }
    self->obj->SetReserved(reserved);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Redirection_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6Redirection::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Redirection_Serialize(PyNs3Icmpv6Redirection *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Redirection_GetTarget(PyNs3Icmpv6Redirection *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetTarget();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Redirection_SetDestination(PyNs3Icmpv6Redirection *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *destination;
    const char *keywords[] = {"destination", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &destination)) {
        return NULL;
    }
    self->obj->SetDestination(*((PyNs3Ipv6Address *) destination)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Redirection_GetInstanceTypeId(PyNs3Icmpv6Redirection *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Redirection_GetSerializedSize(PyNs3Icmpv6Redirection *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Redirection_GetDestination(PyNs3Icmpv6Redirection *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetDestination();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Redirection_SetTarget(PyNs3Icmpv6Redirection *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *target;
    const char *keywords[] = {"target", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &target)) {
        return NULL;
    }
    self->obj->SetTarget(*((PyNs3Ipv6Address *) target)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6Redirection__copy__(PyNs3Icmpv6Redirection *self)
{

    PyNs3Icmpv6Redirection *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6Redirection, &PyNs3Icmpv6Redirection_Type);
    py_copy->obj = new ns3::Icmpv6Redirection(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6Redirection_methods[] = {
    {(char *) "GetReserved", (PyCFunction) _wrap_PyNs3Icmpv6Redirection_GetReserved, METH_NOARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6Redirection_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetReserved", (PyCFunction) _wrap_PyNs3Icmpv6Redirection_SetReserved, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6Redirection_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6Redirection_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTarget", (PyCFunction) _wrap_PyNs3Icmpv6Redirection_GetTarget, METH_NOARGS, NULL },
    {(char *) "SetDestination", (PyCFunction) _wrap_PyNs3Icmpv6Redirection_SetDestination, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6Redirection_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6Redirection_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetDestination", (PyCFunction) _wrap_PyNs3Icmpv6Redirection_GetDestination, METH_NOARGS, NULL },
    {(char *) "SetTarget", (PyCFunction) _wrap_PyNs3Icmpv6Redirection_SetTarget, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6Redirection__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6Redirection__tp_clear(PyNs3Icmpv6Redirection *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6Redirection *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6Redirection__tp_traverse(PyNs3Icmpv6Redirection *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6Redirection__tp_dealloc(PyNs3Icmpv6Redirection *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6Redirection__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6Redirection__tp_richcompare (PyNs3Icmpv6Redirection *PYBINDGEN_UNUSED(self), PyNs3Icmpv6Redirection *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6Redirection_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6Redirection_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6Redirection",            /* tp_name */
    sizeof(PyNs3Icmpv6Redirection),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6Redirection__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6Redirection__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6Redirection__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6Redirection__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6Redirection_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6Redirection, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6Redirection__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6TimeExceeded__tp_init__0(PyNs3Icmpv6TimeExceeded *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6TimeExceeded *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6TimeExceeded_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6TimeExceeded(*((PyNs3Icmpv6TimeExceeded *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6TimeExceeded__tp_init__1(PyNs3Icmpv6TimeExceeded *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6TimeExceeded();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6TimeExceeded__tp_init(PyNs3Icmpv6TimeExceeded *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6TimeExceeded__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6TimeExceeded__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6TimeExceeded_SetPacket(PyNs3Icmpv6TimeExceeded *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &p)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    self->obj->SetPacket(ns3::Ptr< ns3::Packet  > (p_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TimeExceeded_Deserialize(PyNs3Icmpv6TimeExceeded *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TimeExceeded_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6TimeExceeded::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TimeExceeded_Serialize(PyNs3Icmpv6TimeExceeded *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TimeExceeded_GetPacket(PyNs3Icmpv6TimeExceeded *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetPacket();
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (retval))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TimeExceeded_GetInstanceTypeId(PyNs3Icmpv6TimeExceeded *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TimeExceeded_GetSerializedSize(PyNs3Icmpv6TimeExceeded *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6TimeExceeded__copy__(PyNs3Icmpv6TimeExceeded *self)
{

    PyNs3Icmpv6TimeExceeded *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6TimeExceeded, &PyNs3Icmpv6TimeExceeded_Type);
    py_copy->obj = new ns3::Icmpv6TimeExceeded(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6TimeExceeded_methods[] = {
    {(char *) "SetPacket", (PyCFunction) _wrap_PyNs3Icmpv6TimeExceeded_SetPacket, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6TimeExceeded_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6TimeExceeded_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6TimeExceeded_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetPacket", (PyCFunction) _wrap_PyNs3Icmpv6TimeExceeded_GetPacket, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6TimeExceeded_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6TimeExceeded_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6TimeExceeded__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6TimeExceeded__tp_clear(PyNs3Icmpv6TimeExceeded *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6TimeExceeded *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6TimeExceeded__tp_traverse(PyNs3Icmpv6TimeExceeded *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6TimeExceeded__tp_dealloc(PyNs3Icmpv6TimeExceeded *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6TimeExceeded__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6TimeExceeded__tp_richcompare (PyNs3Icmpv6TimeExceeded *PYBINDGEN_UNUSED(self), PyNs3Icmpv6TimeExceeded *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6TimeExceeded_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6TimeExceeded_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6TimeExceeded",            /* tp_name */
    sizeof(PyNs3Icmpv6TimeExceeded),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6TimeExceeded__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6TimeExceeded__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6TimeExceeded__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6TimeExceeded__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6TimeExceeded_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6TimeExceeded, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6TimeExceeded__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6TooBig__tp_init__0(PyNs3Icmpv6TooBig *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6TooBig *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6TooBig_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6TooBig(*((PyNs3Icmpv6TooBig *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6TooBig__tp_init__1(PyNs3Icmpv6TooBig *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6TooBig();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6TooBig__tp_init(PyNs3Icmpv6TooBig *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6TooBig__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6TooBig__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6TooBig_SetPacket(PyNs3Icmpv6TooBig *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &p)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    self->obj->SetPacket(ns3::Ptr< ns3::Packet  > (p_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TooBig_Deserialize(PyNs3Icmpv6TooBig *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TooBig_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6TooBig::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TooBig_Serialize(PyNs3Icmpv6TooBig *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TooBig_GetPacket(PyNs3Icmpv6TooBig *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetPacket();
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (retval))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TooBig_GetMtu(PyNs3Icmpv6TooBig *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetMtu();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TooBig_GetInstanceTypeId(PyNs3Icmpv6TooBig *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TooBig_GetSerializedSize(PyNs3Icmpv6TooBig *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6TooBig_SetMtu(PyNs3Icmpv6TooBig *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int mtu;
    const char *keywords[] = {"mtu", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &mtu)) {
        return NULL;
    }
    self->obj->SetMtu(mtu);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6TooBig__copy__(PyNs3Icmpv6TooBig *self)
{

    PyNs3Icmpv6TooBig *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6TooBig, &PyNs3Icmpv6TooBig_Type);
    py_copy->obj = new ns3::Icmpv6TooBig(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6TooBig_methods[] = {
    {(char *) "SetPacket", (PyCFunction) _wrap_PyNs3Icmpv6TooBig_SetPacket, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6TooBig_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6TooBig_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6TooBig_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetPacket", (PyCFunction) _wrap_PyNs3Icmpv6TooBig_GetPacket, METH_NOARGS, NULL },
    {(char *) "GetMtu", (PyCFunction) _wrap_PyNs3Icmpv6TooBig_GetMtu, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6TooBig_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6TooBig_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetMtu", (PyCFunction) _wrap_PyNs3Icmpv6TooBig_SetMtu, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6TooBig__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6TooBig__tp_clear(PyNs3Icmpv6TooBig *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6TooBig *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6TooBig__tp_traverse(PyNs3Icmpv6TooBig *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6TooBig__tp_dealloc(PyNs3Icmpv6TooBig *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6TooBig__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6TooBig__tp_richcompare (PyNs3Icmpv6TooBig *PYBINDGEN_UNUSED(self), PyNs3Icmpv6TooBig *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6TooBig_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6TooBig_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6TooBig",            /* tp_name */
    sizeof(PyNs3Icmpv6TooBig),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6TooBig__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6TooBig__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6TooBig__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6TooBig__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6TooBig_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6TooBig, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6TooBig__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




void
PyNs3InternetStackHelper__PythonHelper::EnableAsciiIpv4Internal(ns3::Ptr< ns3::OutputStreamWrapper > stream, std::string prefix, ns3::Ptr< ns3::Ipv4 > ipv4, uint32_t interface, bool explicitFilename)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::InternetStackHelper *self_obj_before;
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *py_OutputStreamWrapper;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    const char *prefix_ptr;
    Py_ssize_t prefix_len;
    PyNs3Ipv4 *py_Ipv4;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter2;
    PyTypeObject *wrapper_type2 = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "EnableAsciiIpv4Internal"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj;
    reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = (ns3::InternetStackHelper*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_OutputStreamWrapper = NULL;
    } else {
        py_OutputStreamWrapper = (PyNs3OutputStreamWrapper *) wrapper_lookup_iter->second;
        Py_INCREF(py_OutputStreamWrapper);
    }
    
    if (py_OutputStreamWrapper == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream))), &PyNs3OutputStreamWrapper_Type);
        py_OutputStreamWrapper = PyObject_New(PyNs3OutputStreamWrapper, wrapper_type);
        py_OutputStreamWrapper->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream))->Ref();
        py_OutputStreamWrapper->obj = const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream));
        PyNs3Empty_wrapper_registry[(void *) py_OutputStreamWrapper->obj] = (PyObject *) py_OutputStreamWrapper;
    }
    prefix_ptr = (prefix).c_str();
    prefix_len = (prefix).size();
    if (typeid(*(const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4)))).name() == typeid(PyNs3Ipv4__PythonHelper).name())
    {
        py_Ipv4 = (PyNs3Ipv4*) (((PyNs3Ipv4__PythonHelper*) const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4)))->m_pyself);
        py_Ipv4->obj = const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4));
        Py_INCREF(py_Ipv4);
    } else {
        wrapper_lookup_iter2 = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4)));
        if (wrapper_lookup_iter2 == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Ipv4 = NULL;
        } else {
            py_Ipv4 = (PyNs3Ipv4 *) wrapper_lookup_iter2->second;
            Py_INCREF(py_Ipv4);
        }
    
        if (py_Ipv4 == NULL)
        {
            wrapper_type2 = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4))), &PyNs3Ipv4_Type);
            py_Ipv4 = PyObject_GC_New(PyNs3Ipv4, wrapper_type2);
            py_Ipv4->inst_dict = NULL;
            py_Ipv4->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4))->Ref();
            py_Ipv4->obj = const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4->obj] = (PyObject *) py_Ipv4;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "EnableAsciiIpv4Internal", (char *) "Ns#NNN", py_OutputStreamWrapper, prefix_ptr, prefix_len, py_Ipv4, PyLong_FromUnsignedLong(interface), PyBool_FromLong(explicitFilename));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3InternetStackHelper__PythonHelper::EnableAsciiIpv6Internal(ns3::Ptr< ns3::OutputStreamWrapper > stream, std::string prefix, ns3::Ptr< ns3::Ipv6 > ipv6, uint32_t interface, bool explicitFilename)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::InternetStackHelper *self_obj_before;
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *py_OutputStreamWrapper;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    const char *prefix_ptr;
    Py_ssize_t prefix_len;
    PyNs3Ipv6 *py_Ipv6;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter2;
    PyTypeObject *wrapper_type2 = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "EnableAsciiIpv6Internal"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj;
    reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = (ns3::InternetStackHelper*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_OutputStreamWrapper = NULL;
    } else {
        py_OutputStreamWrapper = (PyNs3OutputStreamWrapper *) wrapper_lookup_iter->second;
        Py_INCREF(py_OutputStreamWrapper);
    }
    
    if (py_OutputStreamWrapper == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream))), &PyNs3OutputStreamWrapper_Type);
        py_OutputStreamWrapper = PyObject_New(PyNs3OutputStreamWrapper, wrapper_type);
        py_OutputStreamWrapper->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream))->Ref();
        py_OutputStreamWrapper->obj = const_cast<ns3::OutputStreamWrapper *> (ns3::PeekPointer (stream));
        PyNs3Empty_wrapper_registry[(void *) py_OutputStreamWrapper->obj] = (PyObject *) py_OutputStreamWrapper;
    }
    prefix_ptr = (prefix).c_str();
    prefix_len = (prefix).size();
    if (typeid(*(const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6)))).name() == typeid(PyNs3Ipv6__PythonHelper).name())
    {
        py_Ipv6 = (PyNs3Ipv6*) (((PyNs3Ipv6__PythonHelper*) const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6)))->m_pyself);
        py_Ipv6->obj = const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6));
        Py_INCREF(py_Ipv6);
    } else {
        wrapper_lookup_iter2 = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6)));
        if (wrapper_lookup_iter2 == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Ipv6 = NULL;
        } else {
            py_Ipv6 = (PyNs3Ipv6 *) wrapper_lookup_iter2->second;
            Py_INCREF(py_Ipv6);
        }
    
        if (py_Ipv6 == NULL)
        {
            wrapper_type2 = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6))), &PyNs3Ipv6_Type);
            py_Ipv6 = PyObject_GC_New(PyNs3Ipv6, wrapper_type2);
            py_Ipv6->inst_dict = NULL;
            py_Ipv6->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6))->Ref();
            py_Ipv6->obj = const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6->obj] = (PyObject *) py_Ipv6;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "EnableAsciiIpv6Internal", (char *) "Ns#NNN", py_OutputStreamWrapper, prefix_ptr, prefix_len, py_Ipv6, PyLong_FromUnsignedLong(interface), PyBool_FromLong(explicitFilename));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3InternetStackHelper__PythonHelper::EnablePcapIpv4Internal(std::string prefix, ns3::Ptr< ns3::Ipv4 > ipv4, uint32_t interface, bool explicitFilename)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::InternetStackHelper *self_obj_before;
    PyObject *py_retval;
    const char *prefix_ptr;
    Py_ssize_t prefix_len;
    PyNs3Ipv4 *py_Ipv4;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "EnablePcapIpv4Internal"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj;
    reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = (ns3::InternetStackHelper*) this;
    prefix_ptr = (prefix).c_str();
    prefix_len = (prefix).size();
    if (typeid(*(const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4)))).name() == typeid(PyNs3Ipv4__PythonHelper).name())
    {
        py_Ipv4 = (PyNs3Ipv4*) (((PyNs3Ipv4__PythonHelper*) const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4)))->m_pyself);
        py_Ipv4->obj = const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4));
        Py_INCREF(py_Ipv4);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Ipv4 = NULL;
        } else {
            py_Ipv4 = (PyNs3Ipv4 *) wrapper_lookup_iter->second;
            Py_INCREF(py_Ipv4);
        }
    
        if (py_Ipv4 == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4))), &PyNs3Ipv4_Type);
            py_Ipv4 = PyObject_GC_New(PyNs3Ipv4, wrapper_type);
            py_Ipv4->inst_dict = NULL;
            py_Ipv4->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4))->Ref();
            py_Ipv4->obj = const_cast<ns3::Ipv4 *> (ns3::PeekPointer (ipv4));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4->obj] = (PyObject *) py_Ipv4;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "EnablePcapIpv4Internal", (char *) "s#NNN", prefix_ptr, prefix_len, py_Ipv4, PyLong_FromUnsignedLong(interface), PyBool_FromLong(explicitFilename));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3InternetStackHelper__PythonHelper::EnablePcapIpv6Internal(std::string prefix, ns3::Ptr< ns3::Ipv6 > ipv6, uint32_t interface, bool explicitFilename)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::InternetStackHelper *self_obj_before;
    PyObject *py_retval;
    const char *prefix_ptr;
    Py_ssize_t prefix_len;
    PyNs3Ipv6 *py_Ipv6;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "EnablePcapIpv6Internal"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj;
    reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = (ns3::InternetStackHelper*) this;
    prefix_ptr = (prefix).c_str();
    prefix_len = (prefix).size();
    if (typeid(*(const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6)))).name() == typeid(PyNs3Ipv6__PythonHelper).name())
    {
        py_Ipv6 = (PyNs3Ipv6*) (((PyNs3Ipv6__PythonHelper*) const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6)))->m_pyself);
        py_Ipv6->obj = const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6));
        Py_INCREF(py_Ipv6);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Ipv6 = NULL;
        } else {
            py_Ipv6 = (PyNs3Ipv6 *) wrapper_lookup_iter->second;
            Py_INCREF(py_Ipv6);
        }
    
        if (py_Ipv6 == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6))), &PyNs3Ipv6_Type);
            py_Ipv6 = PyObject_GC_New(PyNs3Ipv6, wrapper_type);
            py_Ipv6->inst_dict = NULL;
            py_Ipv6->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6))->Ref();
            py_Ipv6->obj = const_cast<ns3::Ipv6 *> (ns3::PeekPointer (ipv6));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6->obj] = (PyObject *) py_Ipv6;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "EnablePcapIpv6Internal", (char *) "s#NNN", prefix_ptr, prefix_len, py_Ipv6, PyLong_FromUnsignedLong(interface), PyBool_FromLong(explicitFilename));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3InternetStackHelper* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3InternetStackHelper__tp_init__0(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3InternetStackHelper_Type)
    {
        self->obj = new PyNs3InternetStackHelper__PythonHelper();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3InternetStackHelper__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        self->obj = new ns3::InternetStackHelper();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    }
    return 0;
}

static int
_wrap_PyNs3InternetStackHelper__tp_init__1(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3InternetStackHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3InternetStackHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3InternetStackHelper_Type)
    {
        self->obj = new PyNs3InternetStackHelper__PythonHelper(*((PyNs3InternetStackHelper *) arg0)->obj);
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3InternetStackHelper__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        self->obj = new ns3::InternetStackHelper(*((PyNs3InternetStackHelper *) arg0)->obj);
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    }
    return 0;
}

int _wrap_PyNs3InternetStackHelper__tp_init(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3InternetStackHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3InternetStackHelper_Reset(PyNs3InternetStackHelper *self)
{
    PyObject *py_retval;
    
    self->obj->Reset();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3InternetStackHelper_SetIpv6StackInstall(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool enable;
    PyObject *py_enable;
    const char *keywords[] = {"enable", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_enable)) {
        return NULL;
    }
    enable = (bool) PyObject_IsTrue(py_enable);
    self->obj->SetIpv6StackInstall(enable);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3InternetStackHelper_SetRoutingHelper__0(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4RoutingHelper *routing;
    const char *keywords[] = {"routing", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4RoutingHelper_Type, &routing)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->SetRoutingHelper(*((PyNs3Ipv4RoutingHelper *) routing)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_SetRoutingHelper__1(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6RoutingHelper *routing;
    const char *keywords[] = {"routing", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6RoutingHelper_Type, &routing)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->SetRoutingHelper(*((PyNs3Ipv6RoutingHelper *) routing)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3InternetStackHelper_SetRoutingHelper(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3InternetStackHelper_SetRoutingHelper__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_SetRoutingHelper__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3InternetStackHelper_InstallAll(PyNs3InternetStackHelper *self)
{
    PyObject *py_retval;
    
    self->obj->InstallAll();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3InternetStackHelper_SetTcp__0(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *tid;
    Py_ssize_t tid_len;
    const char *keywords[] = {"tid", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &tid, &tid_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->SetTcp(std::string(tid, tid_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_SetTcp__1(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *tid;
    Py_ssize_t tid_len;
    const char *attr;
    Py_ssize_t attr_len;
    PyNs3AttributeValue *val;
    const char *keywords[] = {"tid", "attr", "val", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#O!", (char **) keywords, &tid, &tid_len, &attr, &attr_len, &PyNs3AttributeValue_Type, &val)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->SetTcp(std::string(tid, tid_len), std::string(attr, attr_len), *((PyNs3AttributeValue *) val)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3InternetStackHelper_SetTcp(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3InternetStackHelper_SetTcp__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_SetTcp__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3InternetStackHelper_SetIpv4StackInstall(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool enable;
    PyObject *py_enable;
    const char *keywords[] = {"enable", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_enable)) {
        return NULL;
    }
    enable = (bool) PyObject_IsTrue(py_enable);
    self->obj->SetIpv4StackInstall(enable);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3InternetStackHelper_Install__0(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *nodeName;
    Py_ssize_t nodeName_len;
    const char *keywords[] = {"nodeName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &nodeName, &nodeName_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->Install(std::string(nodeName, nodeName_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_Install__1(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->Install(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_Install__2(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3NodeContainer *c;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NodeContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->Install(*((PyNs3NodeContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3InternetStackHelper_Install(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3InternetStackHelper_Install__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_Install__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_Install__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3InternetStackHelper_AssignStreams(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int64_t retval;
    PyNs3NodeContainer *c;
    int64_t stream;
    const char *keywords[] = {"c", "stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!L", (char **) keywords, &PyNs3NodeContainer_Type, &c, &stream)) {
        return NULL;
    }
    retval = self->obj->AssignStreams(*((PyNs3NodeContainer *) c)->obj, stream);
    py_retval = Py_BuildValue((char *) "L", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__0(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv4", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!I|O", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv4_Type, &ipv4, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnableAsciiIpv4(std::string(prefix, prefix_len), ns3::Ptr< ns3::Ipv4  > (ipv4_ptr), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__1(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    unsigned int interface;
    const char *keywords[] = {"stream", "ipv4", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &PyNs3Ipv4_Type, &ipv4, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    self->obj->EnableAsciiIpv4(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), ns3::Ptr< ns3::Ipv4  > (ipv4_ptr), interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__2(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *ipv4Name;
    Py_ssize_t ipv4Name_len;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv4Name", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#I|O", (char **) keywords, &prefix, &prefix_len, &ipv4Name, &ipv4Name_len, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnableAsciiIpv4(std::string(prefix, prefix_len), std::string(ipv4Name, ipv4Name_len), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__3(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *ipv4Name;
    Py_ssize_t ipv4Name_len;
    unsigned int interface;
    const char *keywords[] = {"stream", "ipv4Name", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#I", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &ipv4Name, &ipv4Name_len, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv4(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), std::string(ipv4Name, ipv4Name_len), interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__4(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv4InterfaceContainer *c;
    const char *keywords[] = {"prefix", "c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv4InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnableAsciiIpv4(std::string(prefix, prefix_len), *((PyNs3Ipv4InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__5(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    PyNs3Ipv4InterfaceContainer *c;
    const char *keywords[] = {"stream", "c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &PyNs3Ipv4InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv4(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), *((PyNs3Ipv4InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__6(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3NodeContainer *n;
    const char *keywords[] = {"prefix", "n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3NodeContainer_Type, &n)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnableAsciiIpv4(std::string(prefix, prefix_len), *((PyNs3NodeContainer *) n)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__7(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    PyNs3NodeContainer *n;
    const char *keywords[] = {"stream", "n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &PyNs3NodeContainer_Type, &n)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv4(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), *((PyNs3NodeContainer *) n)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__8(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    unsigned int nodeid;
    unsigned int deviceid;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"prefix", "nodeid", "deviceid", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#IIO", (char **) keywords, &prefix, &prefix_len, &nodeid, &deviceid, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnableAsciiIpv4(std::string(prefix, prefix_len), nodeid, deviceid, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__9(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    unsigned int nodeid;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"stream", "nodeid", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!IIO", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &nodeid, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnableAsciiIpv4(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), nodeid, interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[10] = {0,};
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__4(self, args, kwargs, &exceptions[4]);
    if (!exceptions[4]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__5(self, args, kwargs, &exceptions[5]);
    if (!exceptions[5]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__6(self, args, kwargs, &exceptions[6]);
    if (!exceptions[6]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__7(self, args, kwargs, &exceptions[7]);
    if (!exceptions[7]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        Py_DECREF(exceptions[6]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__8(self, args, kwargs, &exceptions[8]);
    if (!exceptions[8]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        Py_DECREF(exceptions[6]);
        Py_DECREF(exceptions[7]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4__9(self, args, kwargs, &exceptions[9]);
    if (!exceptions[9]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        Py_DECREF(exceptions[6]);
        Py_DECREF(exceptions[7]);
        Py_DECREF(exceptions[8]);
        return retval;
    }
    error_list = PyList_New(10);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyList_SET_ITEM(error_list, 4, PyObject_Str(exceptions[4]));
    Py_DECREF(exceptions[4]);
    PyList_SET_ITEM(error_list, 5, PyObject_Str(exceptions[5]));
    Py_DECREF(exceptions[5]);
    PyList_SET_ITEM(error_list, 6, PyObject_Str(exceptions[6]));
    Py_DECREF(exceptions[6]);
    PyList_SET_ITEM(error_list, 7, PyObject_Str(exceptions[7]));
    Py_DECREF(exceptions[7]);
    PyList_SET_ITEM(error_list, 8, PyObject_Str(exceptions[8]));
    Py_DECREF(exceptions[8]);
    PyList_SET_ITEM(error_list, 9, PyObject_Str(exceptions[9]));
    Py_DECREF(exceptions[9]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv4All__0(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *keywords[] = {"prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &prefix, &prefix_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnableAsciiIpv4All(std::string(prefix, prefix_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv4All__1(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv4All(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4All(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4All__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4All__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3InternetStackHelper_EnablePcapIpv6__0(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv6", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!I|O", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv6_Type, &ipv6, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnablePcapIpv6(std::string(prefix, prefix_len), ns3::Ptr< ns3::Ipv6  > (ipv6_ptr), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnablePcapIpv6__1(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *ipv6Name;
    Py_ssize_t ipv6Name_len;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv6Name", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#I|O", (char **) keywords, &prefix, &prefix_len, &ipv6Name, &ipv6Name_len, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnablePcapIpv6(std::string(prefix, prefix_len), std::string(ipv6Name, ipv6Name_len), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnablePcapIpv6__2(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv6InterfaceContainer *c;
    const char *keywords[] = {"prefix", "c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv6InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnablePcapIpv6(std::string(prefix, prefix_len), *((PyNs3Ipv6InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnablePcapIpv6__3(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3NodeContainer *n;
    const char *keywords[] = {"prefix", "n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3NodeContainer_Type, &n)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnablePcapIpv6(std::string(prefix, prefix_len), *((PyNs3NodeContainer *) n)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnablePcapIpv6__4(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    unsigned int nodeid;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"prefix", "nodeid", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#IIO", (char **) keywords, &prefix, &prefix_len, &nodeid, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnablePcapIpv6(std::string(prefix, prefix_len), nodeid, interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3InternetStackHelper_EnablePcapIpv6(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[5] = {0,};
    retval = _wrap_PyNs3InternetStackHelper_EnablePcapIpv6__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnablePcapIpv6__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnablePcapIpv6__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnablePcapIpv6__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnablePcapIpv6__4(self, args, kwargs, &exceptions[4]);
    if (!exceptions[4]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        return retval;
    }
    error_list = PyList_New(5);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyList_SET_ITEM(error_list, 4, PyObject_Str(exceptions[4]));
    Py_DECREF(exceptions[4]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3InternetStackHelper_EnablePcapIpv4__0(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv4", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!I|O", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv4_Type, &ipv4, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnablePcapIpv4(std::string(prefix, prefix_len), ns3::Ptr< ns3::Ipv4  > (ipv4_ptr), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnablePcapIpv4__1(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *ipv4Name;
    Py_ssize_t ipv4Name_len;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv4Name", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#I|O", (char **) keywords, &prefix, &prefix_len, &ipv4Name, &ipv4Name_len, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnablePcapIpv4(std::string(prefix, prefix_len), std::string(ipv4Name, ipv4Name_len), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnablePcapIpv4__2(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv4InterfaceContainer *c;
    const char *keywords[] = {"prefix", "c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv4InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnablePcapIpv4(std::string(prefix, prefix_len), *((PyNs3Ipv4InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnablePcapIpv4__3(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3NodeContainer *n;
    const char *keywords[] = {"prefix", "n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3NodeContainer_Type, &n)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnablePcapIpv4(std::string(prefix, prefix_len), *((PyNs3NodeContainer *) n)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnablePcapIpv4__4(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    unsigned int nodeid;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"prefix", "nodeid", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#IIO", (char **) keywords, &prefix, &prefix_len, &nodeid, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnablePcapIpv4(std::string(prefix, prefix_len), nodeid, interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3InternetStackHelper_EnablePcapIpv4(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[5] = {0,};
    retval = _wrap_PyNs3InternetStackHelper_EnablePcapIpv4__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnablePcapIpv4__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnablePcapIpv4__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnablePcapIpv4__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnablePcapIpv4__4(self, args, kwargs, &exceptions[4]);
    if (!exceptions[4]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        return retval;
    }
    error_list = PyList_New(5);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyList_SET_ITEM(error_list, 4, PyObject_Str(exceptions[4]));
    Py_DECREF(exceptions[4]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnablePcapIpv4All(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *keywords[] = {"prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &prefix, &prefix_len)) {
        return NULL;
    }
    self->obj->EnablePcapIpv4All(std::string(prefix, prefix_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__0(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv6", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!I|O", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv6_Type, &ipv6, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnableAsciiIpv6(std::string(prefix, prefix_len), ns3::Ptr< ns3::Ipv6  > (ipv6_ptr), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__1(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    unsigned int interface;
    const char *keywords[] = {"stream", "ipv6", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &PyNs3Ipv6_Type, &ipv6, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    self->obj->EnableAsciiIpv6(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), ns3::Ptr< ns3::Ipv6  > (ipv6_ptr), interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__2(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *ipv6Name;
    Py_ssize_t ipv6Name_len;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename = NULL;
    const char *keywords[] = {"prefix", "ipv6Name", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#I|O", (char **) keywords, &prefix, &prefix_len, &ipv6Name, &ipv6Name_len, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = py_explicitFilename? (bool) PyObject_IsTrue(py_explicitFilename) : false;
    self->obj->EnableAsciiIpv6(std::string(prefix, prefix_len), std::string(ipv6Name, ipv6Name_len), interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__3(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *ipv6Name;
    Py_ssize_t ipv6Name_len;
    unsigned int interface;
    const char *keywords[] = {"stream", "ipv6Name", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!s#I", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &ipv6Name, &ipv6Name_len, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv6(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), std::string(ipv6Name, ipv6Name_len), interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__4(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3Ipv6InterfaceContainer *c;
    const char *keywords[] = {"prefix", "c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3Ipv6InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnableAsciiIpv6(std::string(prefix, prefix_len), *((PyNs3Ipv6InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__5(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    PyNs3Ipv6InterfaceContainer *c;
    const char *keywords[] = {"stream", "c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &PyNs3Ipv6InterfaceContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv6(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), *((PyNs3Ipv6InterfaceContainer *) c)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__6(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    PyNs3NodeContainer *n;
    const char *keywords[] = {"prefix", "n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &prefix, &prefix_len, &PyNs3NodeContainer_Type, &n)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnableAsciiIpv6(std::string(prefix, prefix_len), *((PyNs3NodeContainer *) n)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__7(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    PyNs3NodeContainer *n;
    const char *keywords[] = {"stream", "n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &PyNs3NodeContainer_Type, &n)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv6(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), *((PyNs3NodeContainer *) n)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__8(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    unsigned int nodeid;
    unsigned int interface;
    bool explicitFilename;
    PyObject *py_explicitFilename;
    const char *keywords[] = {"prefix", "nodeid", "interface", "explicitFilename", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#IIO", (char **) keywords, &prefix, &prefix_len, &nodeid, &interface, &py_explicitFilename)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    explicitFilename = (bool) PyObject_IsTrue(py_explicitFilename);
    self->obj->EnableAsciiIpv6(std::string(prefix, prefix_len), nodeid, interface, explicitFilename);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__9(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    unsigned int nodeid;
    unsigned int interface;
    const char *keywords[] = {"stream", "nodeid", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!II", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream, &nodeid, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv6(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr), nodeid, interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[10] = {0,};
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__4(self, args, kwargs, &exceptions[4]);
    if (!exceptions[4]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__5(self, args, kwargs, &exceptions[5]);
    if (!exceptions[5]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__6(self, args, kwargs, &exceptions[6]);
    if (!exceptions[6]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__7(self, args, kwargs, &exceptions[7]);
    if (!exceptions[7]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        Py_DECREF(exceptions[6]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__8(self, args, kwargs, &exceptions[8]);
    if (!exceptions[8]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        Py_DECREF(exceptions[6]);
        Py_DECREF(exceptions[7]);
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6__9(self, args, kwargs, &exceptions[9]);
    if (!exceptions[9]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        Py_DECREF(exceptions[5]);
        Py_DECREF(exceptions[6]);
        Py_DECREF(exceptions[7]);
        Py_DECREF(exceptions[8]);
        return retval;
    }
    error_list = PyList_New(10);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyList_SET_ITEM(error_list, 4, PyObject_Str(exceptions[4]));
    Py_DECREF(exceptions[4]);
    PyList_SET_ITEM(error_list, 5, PyObject_Str(exceptions[5]));
    Py_DECREF(exceptions[5]);
    PyList_SET_ITEM(error_list, 6, PyObject_Str(exceptions[6]));
    Py_DECREF(exceptions[6]);
    PyList_SET_ITEM(error_list, 7, PyObject_Str(exceptions[7]));
    Py_DECREF(exceptions[7]);
    PyList_SET_ITEM(error_list, 8, PyObject_Str(exceptions[8]));
    Py_DECREF(exceptions[8]);
    PyList_SET_ITEM(error_list, 9, PyObject_Str(exceptions[9]));
    Py_DECREF(exceptions[9]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv6All__0(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *keywords[] = {"prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &prefix, &prefix_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->EnableAsciiIpv6All(std::string(prefix, prefix_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnableAsciiIpv6All__1(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->EnableAsciiIpv6All(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6All(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6All__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6All__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}

PyObject *
_wrap_PyNs3InternetStackHelper_EnablePcapIpv6All(PyNs3InternetStackHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *keywords[] = {"prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &prefix, &prefix_len)) {
        return NULL;
    }
    self->obj->EnablePcapIpv6All(std::string(prefix, prefix_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3InternetStackHelper__copy__(PyNs3InternetStackHelper *self)
{

    PyNs3InternetStackHelper *py_copy;
    py_copy = PyObject_GC_New(PyNs3InternetStackHelper, &PyNs3InternetStackHelper_Type);
    py_copy->obj = new ns3::InternetStackHelper(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3PcapHelperForIpv4_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3InternetStackHelper_methods[] = {
    {(char *) "Reset", (PyCFunction) _wrap_PyNs3InternetStackHelper_Reset, METH_NOARGS, NULL },
    {(char *) "SetIpv6StackInstall", (PyCFunction) _wrap_PyNs3InternetStackHelper_SetIpv6StackInstall, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRoutingHelper", (PyCFunction) _wrap_PyNs3InternetStackHelper_SetRoutingHelper, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "InstallAll", (PyCFunction) _wrap_PyNs3InternetStackHelper_InstallAll, METH_NOARGS, NULL },
    {(char *) "SetTcp", (PyCFunction) _wrap_PyNs3InternetStackHelper_SetTcp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetIpv4StackInstall", (PyCFunction) _wrap_PyNs3InternetStackHelper_SetIpv4StackInstall, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Install", (PyCFunction) _wrap_PyNs3InternetStackHelper_Install, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AssignStreams", (PyCFunction) _wrap_PyNs3InternetStackHelper_AssignStreams, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnableAsciiIpv4", (PyCFunction) _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnableAsciiIpv4All", (PyCFunction) _wrap_PyNs3InternetStackHelper_EnableAsciiIpv4All, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnablePcapIpv6", (PyCFunction) _wrap_PyNs3InternetStackHelper_EnablePcapIpv6, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnablePcapIpv4", (PyCFunction) _wrap_PyNs3InternetStackHelper_EnablePcapIpv4, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnablePcapIpv4All", (PyCFunction) _wrap_PyNs3InternetStackHelper_EnablePcapIpv4All, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnableAsciiIpv6", (PyCFunction) _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnableAsciiIpv6All", (PyCFunction) _wrap_PyNs3InternetStackHelper_EnableAsciiIpv6All, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnablePcapIpv6All", (PyCFunction) _wrap_PyNs3InternetStackHelper_EnablePcapIpv6All, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3InternetStackHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3InternetStackHelper__tp_clear(PyNs3InternetStackHelper *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::InternetStackHelper *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3InternetStackHelper__tp_traverse(PyNs3InternetStackHelper *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3InternetStackHelper__PythonHelper).name() )
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3InternetStackHelper__tp_dealloc(PyNs3InternetStackHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3PcapHelperForIpv4_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3PcapHelperForIpv4_wrapper_registry.end()) {
        PyNs3PcapHelperForIpv4_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3InternetStackHelper__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3InternetStackHelper__tp_richcompare (PyNs3InternetStackHelper *PYBINDGEN_UNUSED(self), PyNs3InternetStackHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3InternetStackHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3InternetStackHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.InternetStackHelper",            /* tp_name */
    sizeof(PyNs3InternetStackHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3InternetStackHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3InternetStackHelper__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3InternetStackHelper__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3InternetStackHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3InternetStackHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3InternetStackHelper, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3InternetStackHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv4GlobalRoutingHelper__tp_init__0(PyNs3Ipv4GlobalRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4GlobalRoutingHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4GlobalRoutingHelper__tp_init__1(PyNs3Ipv4GlobalRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4GlobalRoutingHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4GlobalRoutingHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4GlobalRoutingHelper(*((PyNs3Ipv4GlobalRoutingHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4GlobalRoutingHelper__tp_init(PyNs3Ipv4GlobalRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4GlobalRoutingHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4GlobalRoutingHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRoutingHelper_RecomputeRoutingTables(void)
{
    PyObject *py_retval;
    
    ns3::Ipv4GlobalRoutingHelper::RecomputeRoutingTables();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRoutingHelper_Create(PyNs3Ipv4GlobalRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4RoutingProtocol > retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    PyNs3Ipv4RoutingProtocol *py_Ipv4RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    retval = self->obj->Create(ns3::Ptr< ns3::Node  > (node_ptr));
    if (!(const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv4RoutingProtocol = NULL;
    } else {
        py_Ipv4RoutingProtocol = (PyNs3Ipv4RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4RoutingProtocol);
    }
    
    if (py_Ipv4RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4RoutingProtocol_Type);
        py_Ipv4RoutingProtocol = PyObject_GC_New(PyNs3Ipv4RoutingProtocol, wrapper_type);
        py_Ipv4RoutingProtocol->inst_dict = NULL;
        py_Ipv4RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4RoutingProtocol->obj = const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4RoutingProtocol->obj] = (PyObject *) py_Ipv4RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingProtocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRoutingHelper_PopulateRoutingTables(void)
{
    PyObject *py_retval;
    
    ns3::Ipv4GlobalRoutingHelper::PopulateRoutingTables();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4GlobalRoutingHelper__copy__(PyNs3Ipv4GlobalRoutingHelper *self)
{

    PyNs3Ipv4GlobalRoutingHelper *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv4GlobalRoutingHelper, &PyNs3Ipv4GlobalRoutingHelper_Type);
    py_copy->obj = new ns3::Ipv4GlobalRoutingHelper(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv4RoutingHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4GlobalRoutingHelper_methods[] = {
    {(char *) "RecomputeRoutingTables", (PyCFunction) _wrap_PyNs3Ipv4GlobalRoutingHelper_RecomputeRoutingTables, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Create", (PyCFunction) _wrap_PyNs3Ipv4GlobalRoutingHelper_Create, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PopulateRoutingTables", (PyCFunction) _wrap_PyNs3Ipv4GlobalRoutingHelper_PopulateRoutingTables, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4GlobalRoutingHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4GlobalRoutingHelper__tp_clear(PyNs3Ipv4GlobalRoutingHelper *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv4GlobalRoutingHelper *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv4GlobalRoutingHelper__tp_traverse(PyNs3Ipv4GlobalRoutingHelper *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv4GlobalRoutingHelper__tp_dealloc(PyNs3Ipv4GlobalRoutingHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv4RoutingHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv4RoutingHelper_wrapper_registry.end()) {
        PyNs3Ipv4RoutingHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4GlobalRoutingHelper__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4GlobalRoutingHelper__tp_richcompare (PyNs3Ipv4GlobalRoutingHelper *PYBINDGEN_UNUSED(self), PyNs3Ipv4GlobalRoutingHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4GlobalRoutingHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4GlobalRoutingHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4GlobalRoutingHelper",            /* tp_name */
    sizeof(PyNs3Ipv4GlobalRoutingHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4GlobalRoutingHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4GlobalRoutingHelper__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4GlobalRoutingHelper__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4GlobalRoutingHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4GlobalRoutingHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4GlobalRoutingHelper, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4GlobalRoutingHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv4Header__tp_init__0(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4Header *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Header_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4Header(*((PyNs3Ipv4Header *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4Header__tp_init__1(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4Header();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4Header__tp_init(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4Header__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4Header__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetIdentification(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int identification;
    const char *keywords[] = {"identification", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &identification)) {
        return NULL;
    }
    if (identification > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetIdentification(identification);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetProtocol(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int num;
    const char *keywords[] = {"num", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &num)) {
        return NULL;
    }
    if (num > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetProtocol(num);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv4Header::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetIdentification(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetIdentification();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetTtl(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int ttl;
    const char *keywords[] = {"ttl", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &ttl)) {
        return NULL;
    }
    if (ttl > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetTtl(ttl);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetSource(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetSource();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_IsDontFragment(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsDontFragment();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_IsChecksumOk(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsChecksumOk();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetTos(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int tos;
    const char *keywords[] = {"tos", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &tos)) {
        return NULL;
    }
    if (tos > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetTos(tos);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetDestination(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *destination;
    const char *keywords[] = {"destination", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &destination)) {
        return NULL;
    }
    self->obj->SetDestination(*((PyNs3Ipv4Address *) destination)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetProtocol(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetProtocol();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetMoreFragments(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    
    self->obj->SetMoreFragments();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetSource(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *source;
    const char *keywords[] = {"source", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &source)) {
        return NULL;
    }
    self->obj->SetSource(*((PyNs3Ipv4Address *) source)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetTos(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetTos();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_Deserialize(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_EnableChecksum(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    
    self->obj->EnableChecksum();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetEcn(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ipv4Header::EcnType ecn;
    const char *keywords[] = {"ecn", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &ecn)) {
        return NULL;
    }
    self->obj->SetEcn(ecn);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetDscp(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ipv4Header::DscpType dscp;
    const char *keywords[] = {"dscp", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &dscp)) {
        return NULL;
    }
    self->obj->SetDscp(dscp);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetMayFragment(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    
    self->obj->SetMayFragment();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetPayloadSize(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetPayloadSize();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_IsLastFragment(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsLastFragment();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetInstanceTypeId(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetSerializedSize(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetDestination(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetDestination();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetLastFragment(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    
    self->obj->SetLastFragment();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetEcn(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    ns3::Ipv4Header::EcnType retval;
    
    retval = self->obj->GetEcn();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_DscpTypeToString(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    ns3::Ipv4Header::DscpType dscp;
    const char *keywords[] = {"dscp", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &dscp)) {
        return NULL;
    }
    retval = self->obj->DscpTypeToString(dscp);
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_Serialize(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetFragmentOffset(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetFragmentOffset();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetDontFragment(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    
    self->obj->SetDontFragment();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetPayloadSize(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int size;
    const char *keywords[] = {"size", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &size)) {
        return NULL;
    }
    if (size > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetPayloadSize(size);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetDscp(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    ns3::Ipv4Header::DscpType retval;
    
    retval = self->obj->GetDscp();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_SetFragmentOffset(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int offsetBytes;
    const char *keywords[] = {"offsetBytes", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &offsetBytes)) {
        return NULL;
    }
    if (offsetBytes > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetFragmentOffset(offsetBytes);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_EcnTypeToString(PyNs3Ipv4Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    ns3::Ipv4Header::EcnType ecn;
    const char *keywords[] = {"ecn", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &ecn)) {
        return NULL;
    }
    retval = self->obj->EcnTypeToString(ecn);
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Header_GetTtl(PyNs3Ipv4Header *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetTtl();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4Header__copy__(PyNs3Ipv4Header *self)
{

    PyNs3Ipv4Header *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv4Header, &PyNs3Ipv4Header_Type);
    py_copy->obj = new ns3::Ipv4Header(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4Header_methods[] = {
    {(char *) "SetIdentification", (PyCFunction) _wrap_PyNs3Ipv4Header_SetIdentification, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetProtocol", (PyCFunction) _wrap_PyNs3Ipv4Header_SetProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv4Header_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetIdentification", (PyCFunction) _wrap_PyNs3Ipv4Header_GetIdentification, METH_NOARGS, NULL },
    {(char *) "SetTtl", (PyCFunction) _wrap_PyNs3Ipv4Header_SetTtl, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSource", (PyCFunction) _wrap_PyNs3Ipv4Header_GetSource, METH_NOARGS, NULL },
    {(char *) "IsDontFragment", (PyCFunction) _wrap_PyNs3Ipv4Header_IsDontFragment, METH_NOARGS, NULL },
    {(char *) "IsChecksumOk", (PyCFunction) _wrap_PyNs3Ipv4Header_IsChecksumOk, METH_NOARGS, NULL },
    {(char *) "SetTos", (PyCFunction) _wrap_PyNs3Ipv4Header_SetTos, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDestination", (PyCFunction) _wrap_PyNs3Ipv4Header_SetDestination, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetProtocol", (PyCFunction) _wrap_PyNs3Ipv4Header_GetProtocol, METH_NOARGS, NULL },
    {(char *) "SetMoreFragments", (PyCFunction) _wrap_PyNs3Ipv4Header_SetMoreFragments, METH_NOARGS, NULL },
    {(char *) "SetSource", (PyCFunction) _wrap_PyNs3Ipv4Header_SetSource, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTos", (PyCFunction) _wrap_PyNs3Ipv4Header_GetTos, METH_NOARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv4Header_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EnableChecksum", (PyCFunction) _wrap_PyNs3Ipv4Header_EnableChecksum, METH_NOARGS, NULL },
    {(char *) "SetEcn", (PyCFunction) _wrap_PyNs3Ipv4Header_SetEcn, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDscp", (PyCFunction) _wrap_PyNs3Ipv4Header_SetDscp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetMayFragment", (PyCFunction) _wrap_PyNs3Ipv4Header_SetMayFragment, METH_NOARGS, NULL },
    {(char *) "GetPayloadSize", (PyCFunction) _wrap_PyNs3Ipv4Header_GetPayloadSize, METH_NOARGS, NULL },
    {(char *) "IsLastFragment", (PyCFunction) _wrap_PyNs3Ipv4Header_IsLastFragment, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv4Header_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv4Header_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetDestination", (PyCFunction) _wrap_PyNs3Ipv4Header_GetDestination, METH_NOARGS, NULL },
    {(char *) "SetLastFragment", (PyCFunction) _wrap_PyNs3Ipv4Header_SetLastFragment, METH_NOARGS, NULL },
    {(char *) "GetEcn", (PyCFunction) _wrap_PyNs3Ipv4Header_GetEcn, METH_NOARGS, NULL },
    {(char *) "DscpTypeToString", (PyCFunction) _wrap_PyNs3Ipv4Header_DscpTypeToString, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv4Header_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetFragmentOffset", (PyCFunction) _wrap_PyNs3Ipv4Header_GetFragmentOffset, METH_NOARGS, NULL },
    {(char *) "SetDontFragment", (PyCFunction) _wrap_PyNs3Ipv4Header_SetDontFragment, METH_NOARGS, NULL },
    {(char *) "SetPayloadSize", (PyCFunction) _wrap_PyNs3Ipv4Header_SetPayloadSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDscp", (PyCFunction) _wrap_PyNs3Ipv4Header_GetDscp, METH_NOARGS, NULL },
    {(char *) "SetFragmentOffset", (PyCFunction) _wrap_PyNs3Ipv4Header_SetFragmentOffset, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "EcnTypeToString", (PyCFunction) _wrap_PyNs3Ipv4Header_EcnTypeToString, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTtl", (PyCFunction) _wrap_PyNs3Ipv4Header_GetTtl, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4Header__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4Header__tp_clear(PyNs3Ipv4Header *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv4Header *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv4Header__tp_traverse(PyNs3Ipv4Header *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv4Header__tp_dealloc(PyNs3Ipv4Header *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4Header__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4Header__tp_richcompare (PyNs3Ipv4Header *PYBINDGEN_UNUSED(self), PyNs3Ipv4Header *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4Header_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4Header_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4Header",            /* tp_name */
    sizeof(PyNs3Ipv4Header),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4Header__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4Header__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4Header__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4Header__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4Header_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4Header, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4Header__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv4ListRoutingHelper__tp_init__0(PyNs3Ipv4ListRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4ListRoutingHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4ListRoutingHelper__tp_init__1(PyNs3Ipv4ListRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4ListRoutingHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4ListRoutingHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4ListRoutingHelper(*((PyNs3Ipv4ListRoutingHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4ListRoutingHelper__tp_init(PyNs3Ipv4ListRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4ListRoutingHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4ListRoutingHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4ListRoutingHelper_Add(PyNs3Ipv4ListRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4RoutingHelper *routing;
    int priority;
    const char *keywords[] = {"routing", "priority", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!i", (char **) keywords, &PyNs3Ipv4RoutingHelper_Type, &routing, &priority)) {
        return NULL;
    }
    if (priority > 0x7fff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->Add(*((PyNs3Ipv4RoutingHelper *) routing)->obj, priority);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4ListRoutingHelper_Create(PyNs3Ipv4ListRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4RoutingProtocol > retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    PyNs3Ipv4RoutingProtocol *py_Ipv4RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    retval = self->obj->Create(ns3::Ptr< ns3::Node  > (node_ptr));
    if (!(const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv4RoutingProtocol = NULL;
    } else {
        py_Ipv4RoutingProtocol = (PyNs3Ipv4RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4RoutingProtocol);
    }
    
    if (py_Ipv4RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4RoutingProtocol_Type);
        py_Ipv4RoutingProtocol = PyObject_GC_New(PyNs3Ipv4RoutingProtocol, wrapper_type);
        py_Ipv4RoutingProtocol->inst_dict = NULL;
        py_Ipv4RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4RoutingProtocol->obj = const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4RoutingProtocol->obj] = (PyObject *) py_Ipv4RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingProtocol);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4ListRoutingHelper__copy__(PyNs3Ipv4ListRoutingHelper *self)
{

    PyNs3Ipv4ListRoutingHelper *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv4ListRoutingHelper, &PyNs3Ipv4ListRoutingHelper_Type);
    py_copy->obj = new ns3::Ipv4ListRoutingHelper(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv4RoutingHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4ListRoutingHelper_methods[] = {
    {(char *) "Add", (PyCFunction) _wrap_PyNs3Ipv4ListRoutingHelper_Add, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Create", (PyCFunction) _wrap_PyNs3Ipv4ListRoutingHelper_Create, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4ListRoutingHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4ListRoutingHelper__tp_clear(PyNs3Ipv4ListRoutingHelper *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv4ListRoutingHelper *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv4ListRoutingHelper__tp_traverse(PyNs3Ipv4ListRoutingHelper *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv4ListRoutingHelper__tp_dealloc(PyNs3Ipv4ListRoutingHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv4RoutingHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv4RoutingHelper_wrapper_registry.end()) {
        PyNs3Ipv4RoutingHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4ListRoutingHelper__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4ListRoutingHelper__tp_richcompare (PyNs3Ipv4ListRoutingHelper *PYBINDGEN_UNUSED(self), PyNs3Ipv4ListRoutingHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4ListRoutingHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4ListRoutingHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4ListRoutingHelper",            /* tp_name */
    sizeof(PyNs3Ipv4ListRoutingHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4ListRoutingHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4ListRoutingHelper__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4ListRoutingHelper__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4ListRoutingHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4ListRoutingHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4ListRoutingHelper, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4ListRoutingHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv4PacketInfoTag__tp_init__0(PyNs3Ipv4PacketInfoTag *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4PacketInfoTag *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4PacketInfoTag_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4PacketInfoTag(*((PyNs3Ipv4PacketInfoTag *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4PacketInfoTag__tp_init__1(PyNs3Ipv4PacketInfoTag *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4PacketInfoTag();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4PacketInfoTag__tp_init(PyNs3Ipv4PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4PacketInfoTag__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4PacketInfoTag__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_Deserialize(PyNs3Ipv4PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3TagBuffer *i;
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3TagBuffer_Type, &i)) {
        return NULL;
    }
    self->obj->Deserialize(*((PyNs3TagBuffer *) i)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_GetLocalAddress(PyNs3Ipv4PacketInfoTag *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetLocalAddress();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_SetRecvIf(PyNs3Ipv4PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int ifindex;
    const char *keywords[] = {"ifindex", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &ifindex)) {
        return NULL;
    }
    self->obj->SetRecvIf(ifindex);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv4PacketInfoTag::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_Serialize(PyNs3Ipv4PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3TagBuffer *i;
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3TagBuffer_Type, &i)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3TagBuffer *) i)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_SetLocalAddress(PyNs3Ipv4PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *addr;
    const char *keywords[] = {"addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr)) {
        return NULL;
    }
    self->obj->SetLocalAddress(*((PyNs3Ipv4Address *) addr)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_GetAddress(PyNs3Ipv4PacketInfoTag *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetAddress();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_GetRecvIf(PyNs3Ipv4PacketInfoTag *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetRecvIf();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_SetTtl(PyNs3Ipv4PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int ttl;
    const char *keywords[] = {"ttl", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &ttl)) {
        return NULL;
    }
    if (ttl > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetTtl(ttl);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_GetInstanceTypeId(PyNs3Ipv4PacketInfoTag *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_GetSerializedSize(PyNs3Ipv4PacketInfoTag *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_SetAddress(PyNs3Ipv4PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *addr;
    const char *keywords[] = {"addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr)) {
        return NULL;
    }
    self->obj->SetAddress(*((PyNs3Ipv4Address *) addr)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4PacketInfoTag_GetTtl(PyNs3Ipv4PacketInfoTag *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetTtl();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4PacketInfoTag__copy__(PyNs3Ipv4PacketInfoTag *self)
{

    PyNs3Ipv4PacketInfoTag *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv4PacketInfoTag, &PyNs3Ipv4PacketInfoTag_Type);
    py_copy->obj = new ns3::Ipv4PacketInfoTag(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4PacketInfoTag_methods[] = {
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLocalAddress", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_GetLocalAddress, METH_NOARGS, NULL },
    {(char *) "SetRecvIf", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_SetRecvIf, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetLocalAddress", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_SetLocalAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_GetAddress, METH_NOARGS, NULL },
    {(char *) "GetRecvIf", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_GetRecvIf, METH_NOARGS, NULL },
    {(char *) "SetTtl", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_SetTtl, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetAddress", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_SetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTtl", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag_GetTtl, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4PacketInfoTag__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4PacketInfoTag__tp_clear(PyNs3Ipv4PacketInfoTag *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv4PacketInfoTag *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv4PacketInfoTag__tp_traverse(PyNs3Ipv4PacketInfoTag *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv4PacketInfoTag__tp_dealloc(PyNs3Ipv4PacketInfoTag *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4PacketInfoTag__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4PacketInfoTag__tp_richcompare (PyNs3Ipv4PacketInfoTag *PYBINDGEN_UNUSED(self), PyNs3Ipv4PacketInfoTag *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4PacketInfoTag_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4PacketInfoTag_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4PacketInfoTag",            /* tp_name */
    sizeof(PyNs3Ipv4PacketInfoTag),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4PacketInfoTag__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4PacketInfoTag__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4PacketInfoTag__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4PacketInfoTag__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4PacketInfoTag_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4PacketInfoTag, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4PacketInfoTag__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6ExtensionHeader__tp_init__0(PyNs3Ipv6ExtensionHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionHeader(*((PyNs3Ipv6ExtensionHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionHeader__tp_init__1(PyNs3Ipv6ExtensionHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionHeader__tp_init(PyNs3Ipv6ExtensionHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHeader_Deserialize(PyNs3Ipv6ExtensionHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHeader_GetLength(PyNs3Ipv6ExtensionHeader *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetLength();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHeader_Serialize(PyNs3Ipv6ExtensionHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHeader_GetNextHeader(PyNs3Ipv6ExtensionHeader *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetNextHeader();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHeader_SetNextHeader(PyNs3Ipv6ExtensionHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int nextHeader;
    const char *keywords[] = {"nextHeader", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &nextHeader)) {
        return NULL;
    }
    if (nextHeader > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetNextHeader(nextHeader);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHeader_GetInstanceTypeId(PyNs3Ipv6ExtensionHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHeader_GetSerializedSize(PyNs3Ipv6ExtensionHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHeader_SetLength(PyNs3Ipv6ExtensionHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int length;
    const char *keywords[] = {"length", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &length)) {
        return NULL;
    }
    if (length > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetLength(length);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionHeader__copy__(PyNs3Ipv6ExtensionHeader *self)
{

    PyNs3Ipv6ExtensionHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionHeader, &PyNs3Ipv6ExtensionHeader_Type);
    py_copy->obj = new ns3::Ipv6ExtensionHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionHeader_methods[] = {
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLength", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHeader_GetLength, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNextHeader", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHeader_GetNextHeader, METH_NOARGS, NULL },
    {(char *) "SetNextHeader", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHeader_SetNextHeader, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetLength", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHeader_SetLength, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionHeader__tp_clear(PyNs3Ipv6ExtensionHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6ExtensionHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6ExtensionHeader__tp_traverse(PyNs3Ipv6ExtensionHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionHeader__tp_dealloc(PyNs3Ipv6ExtensionHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionHeader__tp_richcompare (PyNs3Ipv6ExtensionHeader *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionHeader",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6ExtensionHopByHopHeader__tp_init__0(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionHopByHopHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionHopByHopHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionHopByHopHeader(*((PyNs3Ipv6ExtensionHopByHopHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionHopByHopHeader__tp_init__1(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionHopByHopHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionHopByHopHeader__tp_init(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionHopByHopHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionHopByHopHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetSerializedSize(PyNs3Ipv6ExtensionHopByHopHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionHopByHopHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_Serialize(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_Deserialize(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetInstanceTypeId(PyNs3Ipv6ExtensionHopByHopHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetOptionsOffset(PyNs3Ipv6ExtensionHopByHopHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetOptionsOffset();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_AddOption(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6OptionHeader *option;
    const char *keywords[] = {"option", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6OptionHeader_Type, &option)) {
        return NULL;
    }
    self->obj->AddOption(*((PyNs3Ipv6OptionHeader *) option)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetAttribute(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3AttributeValue *value;
    const char *keywords[] = {"name", "value", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3AttributeValue_Type, &value)) {
        return NULL;
    }
    self->obj->GetAttribute(std::string(name, name_len), *((PyNs3AttributeValue *) value)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetLength(PyNs3Ipv6ExtensionHopByHopHeader *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetLength();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_SetAttribute(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3AttributeValue *value;
    const char *keywords[] = {"name", "value", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3AttributeValue_Type, &value)) {
        return NULL;
    }
    self->obj->SetAttribute(std::string(name, name_len), *((PyNs3AttributeValue *) value)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetNextHeader(PyNs3Ipv6ExtensionHopByHopHeader *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetNextHeader();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_TraceDisconnect(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    const char *context;
    Py_ssize_t context_len;
    PyNs3CallbackBase *cb;
    const char *keywords[] = {"name", "context", "cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#O!", (char **) keywords, &name, &name_len, &context, &context_len, &PyNs3CallbackBase_Type, &cb)) {
        return NULL;
    }
    retval = self->obj->TraceDisconnect(std::string(name, name_len), std::string(context, context_len), *((PyNs3CallbackBase *) cb)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_TraceDisconnectWithoutContext(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3CallbackBase *cb;
    const char *keywords[] = {"name", "cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3CallbackBase_Type, &cb)) {
        return NULL;
    }
    retval = self->obj->TraceDisconnectWithoutContext(std::string(name, name_len), *((PyNs3CallbackBase *) cb)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_SetNextHeader(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int nextHeader;
    const char *keywords[] = {"nextHeader", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &nextHeader)) {
        return NULL;
    }
    if (nextHeader > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetNextHeader(nextHeader);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_TraceConnect(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    const char *context;
    Py_ssize_t context_len;
    PyNs3CallbackBase *cb;
    const char *keywords[] = {"name", "context", "cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#O!", (char **) keywords, &name, &name_len, &context, &context_len, &PyNs3CallbackBase_Type, &cb)) {
        return NULL;
    }
    retval = self->obj->TraceConnect(std::string(name, name_len), std::string(context, context_len), *((PyNs3CallbackBase *) cb)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetOptionBuffer(PyNs3Ipv6ExtensionHopByHopHeader *self)
{
    PyObject *py_retval;
    PyNs3Buffer *py_Buffer;
    
    ns3::Buffer retval = self->obj->GetOptionBuffer();
    py_Buffer = PyObject_New(PyNs3Buffer, &PyNs3Buffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new ns3::Buffer(retval);
    PyNs3Buffer_wrapper_registry[(void *) py_Buffer->obj] = (PyObject *) py_Buffer;
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_SetAttributeFailSafe(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3AttributeValue *value;
    const char *keywords[] = {"name", "value", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3AttributeValue_Type, &value)) {
        return NULL;
    }
    retval = self->obj->SetAttributeFailSafe(std::string(name, name_len), *((PyNs3AttributeValue *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_TraceConnectWithoutContext(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3CallbackBase *cb;
    const char *keywords[] = {"name", "cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3CallbackBase_Type, &cb)) {
        return NULL;
    }
    retval = self->obj->TraceConnectWithoutContext(std::string(name, name_len), *((PyNs3CallbackBase *) cb)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_SetLength(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int length;
    const char *keywords[] = {"length", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &length)) {
        return NULL;
    }
    if (length > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetLength(length);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetAttributeFailSafe(PyNs3Ipv6ExtensionHopByHopHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3AttributeValue *attribute;
    const char *keywords[] = {"name", "attribute", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3AttributeValue_Type, &attribute)) {
        return NULL;
    }
    retval = self->obj->GetAttributeFailSafe(std::string(name, name_len), *((PyNs3AttributeValue *) attribute)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionHopByHopHeader__copy__(PyNs3Ipv6ExtensionHopByHopHeader *self)
{

    PyNs3Ipv6ExtensionHopByHopHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionHopByHopHeader, &PyNs3Ipv6ExtensionHopByHopHeader_Type);
    py_copy->obj = new ns3::Ipv6ExtensionHopByHopHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionHopByHopHeader_methods[] = {
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetOptionsOffset", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetOptionsOffset, METH_NOARGS, NULL },
    {(char *) "AddOption", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_AddOption, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAttribute", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetAttribute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLength", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetLength, METH_NOARGS, NULL },
    {(char *) "SetAttribute", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_SetAttribute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNextHeader", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetNextHeader, METH_NOARGS, NULL },
    {(char *) "TraceDisconnect", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_TraceDisconnect, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "TraceDisconnectWithoutContext", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_TraceDisconnectWithoutContext, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNextHeader", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_SetNextHeader, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "TraceConnect", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_TraceConnect, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOptionBuffer", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetOptionBuffer, METH_NOARGS, NULL },
    {(char *) "SetAttributeFailSafe", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_SetAttributeFailSafe, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "TraceConnectWithoutContext", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_TraceConnectWithoutContext, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetLength", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_SetLength, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAttributeFailSafe", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader_GetAttributeFailSafe, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHopHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionHopByHopHeader__tp_clear(PyNs3Ipv6ExtensionHopByHopHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6ExtensionHopByHopHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6ExtensionHopByHopHeader__tp_traverse(PyNs3Ipv6ExtensionHopByHopHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionHopByHopHeader__tp_dealloc(PyNs3Ipv6ExtensionHopByHopHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionHopByHopHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionHopByHopHeader__tp_richcompare (PyNs3Ipv6ExtensionHopByHopHeader *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionHopByHopHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionHopByHopHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionHopByHopHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionHopByHopHeader",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionHopByHopHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionHopByHopHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionHopByHopHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionHopByHopHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionHopByHopHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionHopByHopHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionHopByHopHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionHopByHopHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6ExtensionRoutingHeader__tp_init__0(PyNs3Ipv6ExtensionRoutingHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionRoutingHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionRoutingHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionRoutingHeader(*((PyNs3Ipv6ExtensionRoutingHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionRoutingHeader__tp_init__1(PyNs3Ipv6ExtensionRoutingHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionRoutingHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionRoutingHeader__tp_init(PyNs3Ipv6ExtensionRoutingHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionRoutingHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionRoutingHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingHeader_GetTypeRouting(PyNs3Ipv6ExtensionRoutingHeader *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetTypeRouting();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingHeader_SetTypeRouting(PyNs3Ipv6ExtensionRoutingHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int typeRouting;
    const char *keywords[] = {"typeRouting", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &typeRouting)) {
        return NULL;
    }
    if (typeRouting > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetTypeRouting(typeRouting);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingHeader_Deserialize(PyNs3Ipv6ExtensionRoutingHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionRoutingHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingHeader_Serialize(PyNs3Ipv6ExtensionRoutingHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingHeader_GetInstanceTypeId(PyNs3Ipv6ExtensionRoutingHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingHeader_GetSerializedSize(PyNs3Ipv6ExtensionRoutingHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingHeader_GetSegmentsLeft(PyNs3Ipv6ExtensionRoutingHeader *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetSegmentsLeft();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingHeader_SetSegmentsLeft(PyNs3Ipv6ExtensionRoutingHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int segmentsLeft;
    const char *keywords[] = {"segmentsLeft", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &segmentsLeft)) {
        return NULL;
    }
    if (segmentsLeft > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetSegmentsLeft(segmentsLeft);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionRoutingHeader__copy__(PyNs3Ipv6ExtensionRoutingHeader *self)
{

    PyNs3Ipv6ExtensionRoutingHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionRoutingHeader, &PyNs3Ipv6ExtensionRoutingHeader_Type);
    py_copy->obj = new ns3::Ipv6ExtensionRoutingHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionRoutingHeader_methods[] = {
    {(char *) "GetTypeRouting", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingHeader_GetTypeRouting, METH_NOARGS, NULL },
    {(char *) "SetTypeRouting", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingHeader_SetTypeRouting, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetSegmentsLeft", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingHeader_GetSegmentsLeft, METH_NOARGS, NULL },
    {(char *) "SetSegmentsLeft", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingHeader_SetSegmentsLeft, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionRoutingHeader__tp_clear(PyNs3Ipv6ExtensionRoutingHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6ExtensionRoutingHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6ExtensionRoutingHeader__tp_traverse(PyNs3Ipv6ExtensionRoutingHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionRoutingHeader__tp_dealloc(PyNs3Ipv6ExtensionRoutingHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionRoutingHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionRoutingHeader__tp_richcompare (PyNs3Ipv6ExtensionRoutingHeader *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionRoutingHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionRoutingHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionRoutingHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionRoutingHeader",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionRoutingHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionRoutingHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionRoutingHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionRoutingHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionRoutingHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionRoutingHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionRoutingHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionRoutingHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6Header__tp_init__0(PyNs3Ipv6Header *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6Header *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Header_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6Header(*((PyNs3Ipv6Header *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6Header__tp_init__1(PyNs3Ipv6Header *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6Header();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6Header__tp_init(PyNs3Ipv6Header *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6Header__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6Header__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6Header_GetDestinationAddress(PyNs3Ipv6Header *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetDestinationAddress();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_SetDestinationAddress(PyNs3Ipv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dst;
    const char *keywords[] = {"dst", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &dst)) {
        return NULL;
    }
    self->obj->SetDestinationAddress(*((PyNs3Ipv6Address *) dst)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_Deserialize(PyNs3Ipv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_SetSourceAddress(PyNs3Ipv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *src;
    const char *keywords[] = {"src", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &src)) {
        return NULL;
    }
    self->obj->SetSourceAddress(*((PyNs3Ipv6Address *) src)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_GetFlowLabel(PyNs3Ipv6Header *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetFlowLabel();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_Serialize(PyNs3Ipv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_GetNextHeader(PyNs3Ipv6Header *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetNextHeader();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_SetFlowLabel(PyNs3Ipv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int flow;
    const char *keywords[] = {"flow", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &flow)) {
        return NULL;
    }
    self->obj->SetFlowLabel(flow);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_SetNextHeader(PyNs3Ipv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int next;
    const char *keywords[] = {"next", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &next)) {
        return NULL;
    }
    if (next > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetNextHeader(next);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_GetTrafficClass(PyNs3Ipv6Header *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetTrafficClass();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_SetTrafficClass(PyNs3Ipv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int traffic;
    const char *keywords[] = {"traffic", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &traffic)) {
        return NULL;
    }
    if (traffic > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetTrafficClass(traffic);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6Header::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_GetInstanceTypeId(PyNs3Ipv6Header *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_GetSerializedSize(PyNs3Ipv6Header *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_GetHopLimit(PyNs3Ipv6Header *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetHopLimit();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_GetPayloadLength(PyNs3Ipv6Header *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetPayloadLength();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_GetSourceAddress(PyNs3Ipv6Header *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetSourceAddress();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_SetPayloadLength(PyNs3Ipv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int len;
    const char *keywords[] = {"len", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &len)) {
        return NULL;
    }
    if (len > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetPayloadLength(len);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Header_SetHopLimit(PyNs3Ipv6Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int limit;
    const char *keywords[] = {"limit", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &limit)) {
        return NULL;
    }
    if (limit > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetHopLimit(limit);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6Header__copy__(PyNs3Ipv6Header *self)
{

    PyNs3Ipv6Header *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6Header, &PyNs3Ipv6Header_Type);
    py_copy->obj = new ns3::Ipv6Header(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6Header_methods[] = {
    {(char *) "GetDestinationAddress", (PyCFunction) _wrap_PyNs3Ipv6Header_GetDestinationAddress, METH_NOARGS, NULL },
    {(char *) "SetDestinationAddress", (PyCFunction) _wrap_PyNs3Ipv6Header_SetDestinationAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6Header_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetSourceAddress", (PyCFunction) _wrap_PyNs3Ipv6Header_SetSourceAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetFlowLabel", (PyCFunction) _wrap_PyNs3Ipv6Header_GetFlowLabel, METH_NOARGS, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6Header_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNextHeader", (PyCFunction) _wrap_PyNs3Ipv6Header_GetNextHeader, METH_NOARGS, NULL },
    {(char *) "SetFlowLabel", (PyCFunction) _wrap_PyNs3Ipv6Header_SetFlowLabel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNextHeader", (PyCFunction) _wrap_PyNs3Ipv6Header_SetNextHeader, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTrafficClass", (PyCFunction) _wrap_PyNs3Ipv6Header_GetTrafficClass, METH_NOARGS, NULL },
    {(char *) "SetTrafficClass", (PyCFunction) _wrap_PyNs3Ipv6Header_SetTrafficClass, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6Header_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6Header_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6Header_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetHopLimit", (PyCFunction) _wrap_PyNs3Ipv6Header_GetHopLimit, METH_NOARGS, NULL },
    {(char *) "GetPayloadLength", (PyCFunction) _wrap_PyNs3Ipv6Header_GetPayloadLength, METH_NOARGS, NULL },
    {(char *) "GetSourceAddress", (PyCFunction) _wrap_PyNs3Ipv6Header_GetSourceAddress, METH_NOARGS, NULL },
    {(char *) "SetPayloadLength", (PyCFunction) _wrap_PyNs3Ipv6Header_SetPayloadLength, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetHopLimit", (PyCFunction) _wrap_PyNs3Ipv6Header_SetHopLimit, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6Header__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6Header__tp_clear(PyNs3Ipv6Header *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6Header *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6Header__tp_traverse(PyNs3Ipv6Header *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6Header__tp_dealloc(PyNs3Ipv6Header *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6Header__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6Header__tp_richcompare (PyNs3Ipv6Header *PYBINDGEN_UNUSED(self), PyNs3Ipv6Header *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6Header_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6Header_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6Header",            /* tp_name */
    sizeof(PyNs3Ipv6Header),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6Header__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6Header__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6Header__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6Header__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6Header_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6Header, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6Header__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6ListRoutingHelper__tp_init__0(PyNs3Ipv6ListRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ListRoutingHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ListRoutingHelper__tp_init__1(PyNs3Ipv6ListRoutingHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ListRoutingHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ListRoutingHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ListRoutingHelper(*((PyNs3Ipv6ListRoutingHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ListRoutingHelper__tp_init(PyNs3Ipv6ListRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ListRoutingHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ListRoutingHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ListRoutingHelper_Add(PyNs3Ipv6ListRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6RoutingHelper *routing;
    int priority;
    const char *keywords[] = {"routing", "priority", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!i", (char **) keywords, &PyNs3Ipv6RoutingHelper_Type, &routing, &priority)) {
        return NULL;
    }
    if (priority > 0x7fff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->Add(*((PyNs3Ipv6RoutingHelper *) routing)->obj, priority);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRoutingHelper_Create(PyNs3Ipv6ListRoutingHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6RoutingProtocol > retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    PyNs3Ipv6RoutingProtocol *py_Ipv6RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    retval = self->obj->Create(ns3::Ptr< ns3::Node  > (node_ptr));
    if (!(const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv6RoutingProtocol = NULL;
    } else {
        py_Ipv6RoutingProtocol = (PyNs3Ipv6RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6RoutingProtocol);
    }
    
    if (py_Ipv6RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6RoutingProtocol_Type);
        py_Ipv6RoutingProtocol = PyObject_GC_New(PyNs3Ipv6RoutingProtocol, wrapper_type);
        py_Ipv6RoutingProtocol->inst_dict = NULL;
        py_Ipv6RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv6RoutingProtocol->obj = const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6RoutingProtocol->obj] = (PyObject *) py_Ipv6RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingProtocol);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ListRoutingHelper__copy__(PyNs3Ipv6ListRoutingHelper *self)
{

    PyNs3Ipv6ListRoutingHelper *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ListRoutingHelper, &PyNs3Ipv6ListRoutingHelper_Type);
    py_copy->obj = new ns3::Ipv6ListRoutingHelper(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv6RoutingHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ListRoutingHelper_methods[] = {
    {(char *) "Add", (PyCFunction) _wrap_PyNs3Ipv6ListRoutingHelper_Add, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Create", (PyCFunction) _wrap_PyNs3Ipv6ListRoutingHelper_Create, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ListRoutingHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ListRoutingHelper__tp_clear(PyNs3Ipv6ListRoutingHelper *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6ListRoutingHelper *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6ListRoutingHelper__tp_traverse(PyNs3Ipv6ListRoutingHelper *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ListRoutingHelper__tp_dealloc(PyNs3Ipv6ListRoutingHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv6RoutingHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv6RoutingHelper_wrapper_registry.end()) {
        PyNs3Ipv6RoutingHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ListRoutingHelper__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ListRoutingHelper__tp_richcompare (PyNs3Ipv6ListRoutingHelper *PYBINDGEN_UNUSED(self), PyNs3Ipv6ListRoutingHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ListRoutingHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ListRoutingHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ListRoutingHelper",            /* tp_name */
    sizeof(PyNs3Ipv6ListRoutingHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ListRoutingHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ListRoutingHelper__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ListRoutingHelper__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ListRoutingHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ListRoutingHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ListRoutingHelper, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ListRoutingHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6OptionHeader__tp_init__0(PyNs3Ipv6OptionHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6OptionHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6OptionHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6OptionHeader(*((PyNs3Ipv6OptionHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6OptionHeader__tp_init__1(PyNs3Ipv6OptionHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6OptionHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6OptionHeader__tp_init(PyNs3Ipv6OptionHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6OptionHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6OptionHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6OptionHeader_Serialize(PyNs3Ipv6OptionHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionHeader_Deserialize(PyNs3Ipv6OptionHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionHeader_GetLength(PyNs3Ipv6OptionHeader *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetLength();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6OptionHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionHeader_GetType(PyNs3Ipv6OptionHeader *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetType();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionHeader_GetInstanceTypeId(PyNs3Ipv6OptionHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionHeader_GetSerializedSize(PyNs3Ipv6OptionHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionHeader_GetAlignment(PyNs3Ipv6OptionHeader *self)
{
    PyObject *py_retval;
    PyNs3Ipv6OptionHeaderAlignment *py_Alignment;
    
    ns3::Ipv6OptionHeader::Alignment retval = self->obj->GetAlignment();
    py_Alignment = PyObject_New(PyNs3Ipv6OptionHeaderAlignment, &PyNs3Ipv6OptionHeaderAlignment_Type);
    py_Alignment->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Alignment->obj = new ns3::Ipv6OptionHeader::Alignment(retval);
    PyNs3Ipv6OptionHeaderAlignment_wrapper_registry[(void *) py_Alignment->obj] = (PyObject *) py_Alignment;
    py_retval = Py_BuildValue((char *) "N", py_Alignment);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionHeader_SetLength(PyNs3Ipv6OptionHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int length;
    const char *keywords[] = {"length", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &length)) {
        return NULL;
    }
    if (length > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetLength(length);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionHeader_SetType(PyNs3Ipv6OptionHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int type;
    const char *keywords[] = {"type", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &type)) {
        return NULL;
    }
    if (type > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetType(type);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6OptionHeader__copy__(PyNs3Ipv6OptionHeader *self)
{

    PyNs3Ipv6OptionHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6OptionHeader, &PyNs3Ipv6OptionHeader_Type);
    py_copy->obj = new ns3::Ipv6OptionHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6OptionHeader_methods[] = {
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6OptionHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6OptionHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLength", (PyCFunction) _wrap_PyNs3Ipv6OptionHeader_GetLength, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6OptionHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetType", (PyCFunction) _wrap_PyNs3Ipv6OptionHeader_GetType, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6OptionHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6OptionHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetAlignment", (PyCFunction) _wrap_PyNs3Ipv6OptionHeader_GetAlignment, METH_NOARGS, NULL },
    {(char *) "SetLength", (PyCFunction) _wrap_PyNs3Ipv6OptionHeader_SetLength, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetType", (PyCFunction) _wrap_PyNs3Ipv6OptionHeader_SetType, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6OptionHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6OptionHeader__tp_clear(PyNs3Ipv6OptionHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6OptionHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6OptionHeader__tp_traverse(PyNs3Ipv6OptionHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6OptionHeader__tp_dealloc(PyNs3Ipv6OptionHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6OptionHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6OptionHeader__tp_richcompare (PyNs3Ipv6OptionHeader *PYBINDGEN_UNUSED(self), PyNs3Ipv6OptionHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6OptionHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6OptionHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6OptionHeader",            /* tp_name */
    sizeof(PyNs3Ipv6OptionHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6OptionHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6OptionHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6OptionHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6OptionHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6OptionHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6OptionHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6OptionHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3Ipv6OptionHeaderAlignment_wrapper_registry;
static PyObject* _wrap_PyNs3Ipv6OptionHeaderAlignment__get_factor(PyNs3Ipv6OptionHeaderAlignment *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)self->obj->factor);
    return py_retval;
}
static int _wrap_PyNs3Ipv6OptionHeaderAlignment__set_factor(PyNs3Ipv6OptionHeaderAlignment *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    int tmp;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        Py_DECREF(py_retval);
        return -1;
    }
    if (tmp > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        return -1;
    }
    self->obj->factor = tmp;
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyNs3Ipv6OptionHeaderAlignment__get_offset(PyNs3Ipv6OptionHeaderAlignment *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)self->obj->offset);
    return py_retval;
}
static int _wrap_PyNs3Ipv6OptionHeaderAlignment__set_offset(PyNs3Ipv6OptionHeaderAlignment *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    int tmp;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        Py_DECREF(py_retval);
        return -1;
    }
    if (tmp > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        return -1;
    }
    self->obj->offset = tmp;
    Py_DECREF(py_retval);
    return 0;
}
static PyGetSetDef PyNs3Ipv6OptionHeaderAlignment__getsets[] = {
    {
        (char*) "offset", /* attribute name */
        (getter) _wrap_PyNs3Ipv6OptionHeaderAlignment__get_offset, /* C function to get the attribute */
        (setter) _wrap_PyNs3Ipv6OptionHeaderAlignment__set_offset, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "factor", /* attribute name */
        (getter) _wrap_PyNs3Ipv6OptionHeaderAlignment__get_factor, /* C function to get the attribute */
        (setter) _wrap_PyNs3Ipv6OptionHeaderAlignment__set_factor, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyNs3Ipv6OptionHeaderAlignment__tp_init__0(PyNs3Ipv6OptionHeaderAlignment *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6OptionHeader::Alignment();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6OptionHeaderAlignment__tp_init__1(PyNs3Ipv6OptionHeaderAlignment *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6OptionHeaderAlignment *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6OptionHeaderAlignment_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6OptionHeader::Alignment(*((PyNs3Ipv6OptionHeaderAlignment *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6OptionHeaderAlignment__tp_init(PyNs3Ipv6OptionHeaderAlignment *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6OptionHeaderAlignment__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6OptionHeaderAlignment__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


static PyObject*
_wrap_PyNs3Ipv6OptionHeaderAlignment__copy__(PyNs3Ipv6OptionHeaderAlignment *self)
{

    PyNs3Ipv6OptionHeaderAlignment *py_copy;
    py_copy = PyObject_New(PyNs3Ipv6OptionHeaderAlignment, &PyNs3Ipv6OptionHeaderAlignment_Type);
    py_copy->obj = new ns3::Ipv6OptionHeader::Alignment(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Ipv6OptionHeaderAlignment_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6OptionHeaderAlignment_methods[] = {
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6OptionHeaderAlignment__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv6OptionHeaderAlignment__tp_dealloc(PyNs3Ipv6OptionHeaderAlignment *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Ipv6OptionHeaderAlignment_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Ipv6OptionHeaderAlignment_wrapper_registry.end()) {
        PyNs3Ipv6OptionHeaderAlignment_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::Ipv6OptionHeader::Alignment *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6OptionHeaderAlignment__tp_richcompare (PyNs3Ipv6OptionHeaderAlignment *PYBINDGEN_UNUSED(self), PyNs3Ipv6OptionHeaderAlignment *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6OptionHeaderAlignment_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6OptionHeaderAlignment_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6OptionHeader.Alignment",            /* tp_name */
    sizeof(PyNs3Ipv6OptionHeaderAlignment),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6OptionHeaderAlignment__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6OptionHeaderAlignment__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6OptionHeaderAlignment_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    PyNs3Ipv6OptionHeaderAlignment__getsets,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6OptionHeaderAlignment__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6OptionJumbogramHeader__tp_init__0(PyNs3Ipv6OptionJumbogramHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6OptionJumbogramHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6OptionJumbogramHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6OptionJumbogramHeader(*((PyNs3Ipv6OptionJumbogramHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6OptionJumbogramHeader__tp_init__1(PyNs3Ipv6OptionJumbogramHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6OptionJumbogramHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6OptionJumbogramHeader__tp_init(PyNs3Ipv6OptionJumbogramHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6OptionJumbogramHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6OptionJumbogramHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6OptionJumbogramHeader_Serialize(PyNs3Ipv6OptionJumbogramHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionJumbogramHeader_GetDataLength(PyNs3Ipv6OptionJumbogramHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetDataLength();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionJumbogramHeader_Deserialize(PyNs3Ipv6OptionJumbogramHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionJumbogramHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6OptionJumbogramHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionJumbogramHeader_GetAlignment(PyNs3Ipv6OptionJumbogramHeader *self)
{
    PyObject *py_retval;
    PyNs3Ipv6OptionHeaderAlignment *py_Alignment;
    
    ns3::Ipv6OptionHeader::Alignment retval = self->obj->GetAlignment();
    py_Alignment = PyObject_New(PyNs3Ipv6OptionHeaderAlignment, &PyNs3Ipv6OptionHeaderAlignment_Type);
    py_Alignment->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Alignment->obj = new ns3::Ipv6OptionHeader::Alignment(retval);
    PyNs3Ipv6OptionHeaderAlignment_wrapper_registry[(void *) py_Alignment->obj] = (PyObject *) py_Alignment;
    py_retval = Py_BuildValue((char *) "N", py_Alignment);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionJumbogramHeader_SetDataLength(PyNs3Ipv6OptionJumbogramHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int dataLength;
    const char *keywords[] = {"dataLength", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &dataLength)) {
        return NULL;
    }
    self->obj->SetDataLength(dataLength);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionJumbogramHeader_GetInstanceTypeId(PyNs3Ipv6OptionJumbogramHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionJumbogramHeader_GetSerializedSize(PyNs3Ipv6OptionJumbogramHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6OptionJumbogramHeader__copy__(PyNs3Ipv6OptionJumbogramHeader *self)
{

    PyNs3Ipv6OptionJumbogramHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6OptionJumbogramHeader, &PyNs3Ipv6OptionJumbogramHeader_Type);
    py_copy->obj = new ns3::Ipv6OptionJumbogramHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6OptionJumbogramHeader_methods[] = {
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6OptionJumbogramHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDataLength", (PyCFunction) _wrap_PyNs3Ipv6OptionJumbogramHeader_GetDataLength, METH_NOARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6OptionJumbogramHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6OptionJumbogramHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetAlignment", (PyCFunction) _wrap_PyNs3Ipv6OptionJumbogramHeader_GetAlignment, METH_NOARGS, NULL },
    {(char *) "SetDataLength", (PyCFunction) _wrap_PyNs3Ipv6OptionJumbogramHeader_SetDataLength, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6OptionJumbogramHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6OptionJumbogramHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6OptionJumbogramHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6OptionJumbogramHeader__tp_clear(PyNs3Ipv6OptionJumbogramHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6OptionJumbogramHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6OptionJumbogramHeader__tp_traverse(PyNs3Ipv6OptionJumbogramHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6OptionJumbogramHeader__tp_dealloc(PyNs3Ipv6OptionJumbogramHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6OptionJumbogramHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6OptionJumbogramHeader__tp_richcompare (PyNs3Ipv6OptionJumbogramHeader *PYBINDGEN_UNUSED(self), PyNs3Ipv6OptionJumbogramHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6OptionJumbogramHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6OptionJumbogramHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6OptionJumbogramHeader",            /* tp_name */
    sizeof(PyNs3Ipv6OptionJumbogramHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6OptionJumbogramHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6OptionJumbogramHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6OptionJumbogramHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6OptionJumbogramHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6OptionJumbogramHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6OptionJumbogramHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6OptionJumbogramHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6OptionPad1Header__tp_init__0(PyNs3Ipv6OptionPad1Header *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6OptionPad1Header *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6OptionPad1Header_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6OptionPad1Header(*((PyNs3Ipv6OptionPad1Header *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6OptionPad1Header__tp_init__1(PyNs3Ipv6OptionPad1Header *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6OptionPad1Header();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6OptionPad1Header__tp_init(PyNs3Ipv6OptionPad1Header *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6OptionPad1Header__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6OptionPad1Header__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6OptionPad1Header_GetSerializedSize(PyNs3Ipv6OptionPad1Header *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionPad1Header_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6OptionPad1Header::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionPad1Header_Serialize(PyNs3Ipv6OptionPad1Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionPad1Header_Deserialize(PyNs3Ipv6OptionPad1Header *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionPad1Header_GetInstanceTypeId(PyNs3Ipv6OptionPad1Header *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6OptionPad1Header__copy__(PyNs3Ipv6OptionPad1Header *self)
{

    PyNs3Ipv6OptionPad1Header *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6OptionPad1Header, &PyNs3Ipv6OptionPad1Header_Type);
    py_copy->obj = new ns3::Ipv6OptionPad1Header(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6OptionPad1Header_methods[] = {
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6OptionPad1Header_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6OptionPad1Header_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6OptionPad1Header_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6OptionPad1Header_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6OptionPad1Header_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6OptionPad1Header__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6OptionPad1Header__tp_clear(PyNs3Ipv6OptionPad1Header *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6OptionPad1Header *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6OptionPad1Header__tp_traverse(PyNs3Ipv6OptionPad1Header *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6OptionPad1Header__tp_dealloc(PyNs3Ipv6OptionPad1Header *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6OptionPad1Header__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6OptionPad1Header__tp_richcompare (PyNs3Ipv6OptionPad1Header *PYBINDGEN_UNUSED(self), PyNs3Ipv6OptionPad1Header *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6OptionPad1Header_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6OptionPad1Header_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6OptionPad1Header",            /* tp_name */
    sizeof(PyNs3Ipv6OptionPad1Header),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6OptionPad1Header__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6OptionPad1Header__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6OptionPad1Header__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6OptionPad1Header__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6OptionPad1Header_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6OptionPad1Header, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6OptionPad1Header__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6OptionPadnHeader__tp_init__0(PyNs3Ipv6OptionPadnHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6OptionPadnHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6OptionPadnHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6OptionPadnHeader(*((PyNs3Ipv6OptionPadnHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6OptionPadnHeader__tp_init__1(PyNs3Ipv6OptionPadnHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    unsigned int pad = 2;
    const char *keywords[] = {"pad", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|I", (char **) keywords, &pad)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6OptionPadnHeader(pad);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6OptionPadnHeader__tp_init(PyNs3Ipv6OptionPadnHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6OptionPadnHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6OptionPadnHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6OptionPadnHeader_GetSerializedSize(PyNs3Ipv6OptionPadnHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionPadnHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6OptionPadnHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionPadnHeader_Serialize(PyNs3Ipv6OptionPadnHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionPadnHeader_Deserialize(PyNs3Ipv6OptionPadnHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionPadnHeader_GetInstanceTypeId(PyNs3Ipv6OptionPadnHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6OptionPadnHeader__copy__(PyNs3Ipv6OptionPadnHeader *self)
{

    PyNs3Ipv6OptionPadnHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6OptionPadnHeader, &PyNs3Ipv6OptionPadnHeader_Type);
    py_copy->obj = new ns3::Ipv6OptionPadnHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6OptionPadnHeader_methods[] = {
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6OptionPadnHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6OptionPadnHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6OptionPadnHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6OptionPadnHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6OptionPadnHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6OptionPadnHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6OptionPadnHeader__tp_clear(PyNs3Ipv6OptionPadnHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6OptionPadnHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6OptionPadnHeader__tp_traverse(PyNs3Ipv6OptionPadnHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6OptionPadnHeader__tp_dealloc(PyNs3Ipv6OptionPadnHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6OptionPadnHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6OptionPadnHeader__tp_richcompare (PyNs3Ipv6OptionPadnHeader *PYBINDGEN_UNUSED(self), PyNs3Ipv6OptionPadnHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6OptionPadnHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6OptionPadnHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6OptionPadnHeader",            /* tp_name */
    sizeof(PyNs3Ipv6OptionPadnHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6OptionPadnHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6OptionPadnHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6OptionPadnHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6OptionPadnHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6OptionPadnHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6OptionPadnHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6OptionPadnHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6OptionRouterAlertHeader__tp_init__0(PyNs3Ipv6OptionRouterAlertHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6OptionRouterAlertHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6OptionRouterAlertHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6OptionRouterAlertHeader(*((PyNs3Ipv6OptionRouterAlertHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6OptionRouterAlertHeader__tp_init__1(PyNs3Ipv6OptionRouterAlertHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6OptionRouterAlertHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6OptionRouterAlertHeader__tp_init(PyNs3Ipv6OptionRouterAlertHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6OptionRouterAlertHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6OptionRouterAlertHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6OptionRouterAlertHeader_Serialize(PyNs3Ipv6OptionRouterAlertHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionRouterAlertHeader_Deserialize(PyNs3Ipv6OptionRouterAlertHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionRouterAlertHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6OptionRouterAlertHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionRouterAlertHeader_GetAlignment(PyNs3Ipv6OptionRouterAlertHeader *self)
{
    PyObject *py_retval;
    PyNs3Ipv6OptionHeaderAlignment *py_Alignment;
    
    ns3::Ipv6OptionHeader::Alignment retval = self->obj->GetAlignment();
    py_Alignment = PyObject_New(PyNs3Ipv6OptionHeaderAlignment, &PyNs3Ipv6OptionHeaderAlignment_Type);
    py_Alignment->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Alignment->obj = new ns3::Ipv6OptionHeader::Alignment(retval);
    PyNs3Ipv6OptionHeaderAlignment_wrapper_registry[(void *) py_Alignment->obj] = (PyObject *) py_Alignment;
    py_retval = Py_BuildValue((char *) "N", py_Alignment);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionRouterAlertHeader_GetValue(PyNs3Ipv6OptionRouterAlertHeader *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetValue();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionRouterAlertHeader_SetValue(PyNs3Ipv6OptionRouterAlertHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int value;
    const char *keywords[] = {"value", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &value)) {
        return NULL;
    }
    if (value > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetValue(value);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionRouterAlertHeader_GetInstanceTypeId(PyNs3Ipv6OptionRouterAlertHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6OptionRouterAlertHeader_GetSerializedSize(PyNs3Ipv6OptionRouterAlertHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6OptionRouterAlertHeader__copy__(PyNs3Ipv6OptionRouterAlertHeader *self)
{

    PyNs3Ipv6OptionRouterAlertHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6OptionRouterAlertHeader, &PyNs3Ipv6OptionRouterAlertHeader_Type);
    py_copy->obj = new ns3::Ipv6OptionRouterAlertHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6OptionRouterAlertHeader_methods[] = {
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6OptionRouterAlertHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6OptionRouterAlertHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6OptionRouterAlertHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetAlignment", (PyCFunction) _wrap_PyNs3Ipv6OptionRouterAlertHeader_GetAlignment, METH_NOARGS, NULL },
    {(char *) "GetValue", (PyCFunction) _wrap_PyNs3Ipv6OptionRouterAlertHeader_GetValue, METH_NOARGS, NULL },
    {(char *) "SetValue", (PyCFunction) _wrap_PyNs3Ipv6OptionRouterAlertHeader_SetValue, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6OptionRouterAlertHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6OptionRouterAlertHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6OptionRouterAlertHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6OptionRouterAlertHeader__tp_clear(PyNs3Ipv6OptionRouterAlertHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6OptionRouterAlertHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6OptionRouterAlertHeader__tp_traverse(PyNs3Ipv6OptionRouterAlertHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6OptionRouterAlertHeader__tp_dealloc(PyNs3Ipv6OptionRouterAlertHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6OptionRouterAlertHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6OptionRouterAlertHeader__tp_richcompare (PyNs3Ipv6OptionRouterAlertHeader *PYBINDGEN_UNUSED(self), PyNs3Ipv6OptionRouterAlertHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6OptionRouterAlertHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6OptionRouterAlertHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6OptionRouterAlertHeader",            /* tp_name */
    sizeof(PyNs3Ipv6OptionRouterAlertHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6OptionRouterAlertHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6OptionRouterAlertHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6OptionRouterAlertHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6OptionRouterAlertHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6OptionRouterAlertHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6OptionRouterAlertHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6OptionRouterAlertHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6PacketInfoTag__tp_init__0(PyNs3Ipv6PacketInfoTag *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6PacketInfoTag *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6PacketInfoTag_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6PacketInfoTag(*((PyNs3Ipv6PacketInfoTag *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6PacketInfoTag__tp_init__1(PyNs3Ipv6PacketInfoTag *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6PacketInfoTag();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6PacketInfoTag__tp_init(PyNs3Ipv6PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6PacketInfoTag__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6PacketInfoTag__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_SetHoplimit(PyNs3Ipv6PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int ttl;
    const char *keywords[] = {"ttl", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &ttl)) {
        return NULL;
    }
    if (ttl > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetHoplimit(ttl);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_Deserialize(PyNs3Ipv6PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3TagBuffer *i;
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3TagBuffer_Type, &i)) {
        return NULL;
    }
    self->obj->Deserialize(*((PyNs3TagBuffer *) i)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_GetRecvIf(PyNs3Ipv6PacketInfoTag *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetRecvIf();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6PacketInfoTag::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_Serialize(PyNs3Ipv6PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3TagBuffer *i;
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3TagBuffer_Type, &i)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3TagBuffer *) i)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_SetRecvIf(PyNs3Ipv6PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int ifindex;
    const char *keywords[] = {"ifindex", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &ifindex)) {
        return NULL;
    }
    self->obj->SetRecvIf(ifindex);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_GetAddress(PyNs3Ipv6PacketInfoTag *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetAddress();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_SetTrafficClass(PyNs3Ipv6PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int tclass;
    const char *keywords[] = {"tclass", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &tclass)) {
        return NULL;
    }
    if (tclass > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetTrafficClass(tclass);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_GetInstanceTypeId(PyNs3Ipv6PacketInfoTag *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_GetSerializedSize(PyNs3Ipv6PacketInfoTag *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_GetHoplimit(PyNs3Ipv6PacketInfoTag *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetHoplimit();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_GetTrafficClass(PyNs3Ipv6PacketInfoTag *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetTrafficClass();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6PacketInfoTag_SetAddress(PyNs3Ipv6PacketInfoTag *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *addr;
    const char *keywords[] = {"addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &addr)) {
        return NULL;
    }
    self->obj->SetAddress(*((PyNs3Ipv6Address *) addr)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6PacketInfoTag__copy__(PyNs3Ipv6PacketInfoTag *self)
{

    PyNs3Ipv6PacketInfoTag *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6PacketInfoTag, &PyNs3Ipv6PacketInfoTag_Type);
    py_copy->obj = new ns3::Ipv6PacketInfoTag(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6PacketInfoTag_methods[] = {
    {(char *) "SetHoplimit", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_SetHoplimit, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetRecvIf", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_GetRecvIf, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRecvIf", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_SetRecvIf, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_GetAddress, METH_NOARGS, NULL },
    {(char *) "SetTrafficClass", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_SetTrafficClass, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetHoplimit", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_GetHoplimit, METH_NOARGS, NULL },
    {(char *) "GetTrafficClass", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_GetTrafficClass, METH_NOARGS, NULL },
    {(char *) "SetAddress", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag_SetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6PacketInfoTag__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6PacketInfoTag__tp_clear(PyNs3Ipv6PacketInfoTag *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6PacketInfoTag *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6PacketInfoTag__tp_traverse(PyNs3Ipv6PacketInfoTag *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6PacketInfoTag__tp_dealloc(PyNs3Ipv6PacketInfoTag *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6PacketInfoTag__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6PacketInfoTag__tp_richcompare (PyNs3Ipv6PacketInfoTag *PYBINDGEN_UNUSED(self), PyNs3Ipv6PacketInfoTag *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6PacketInfoTag_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6PacketInfoTag_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6PacketInfoTag",            /* tp_name */
    sizeof(PyNs3Ipv6PacketInfoTag),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6PacketInfoTag__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6PacketInfoTag__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6PacketInfoTag__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6PacketInfoTag__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6PacketInfoTag_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6PacketInfoTag, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6PacketInfoTag__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




pybindgen::TypeMap PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____typeid_map;



static int
_wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____tp_init__0(PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> >();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____tp_init__1(PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__ *o;
    const char *keywords[] = {"o", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type, &o)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> >(*((PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__ *) o)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____tp_init(PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__ *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Cleanup(void)
{
    PyObject *py_retval;
    
    ns3::SimpleRefCount< ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> >::Cleanup();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____copy__(PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__ *self)
{

    PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__ *py_copy;
    py_copy = PyObject_New(PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__, &PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type);
    py_copy->obj = new ns3::SimpleRefCount< ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> >(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___methods[] = {
    {(char *) "Cleanup", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Cleanup, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____tp_dealloc(PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__ *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::SimpleRefCount< ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> > *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____tp_richcompare (PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__ *PYBINDGEN_UNUSED(self), PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__ *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__",            /* tp_name */
    sizeof(PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




pybindgen::TypeMap PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map;



static int
_wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____tp_init__0(PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> >();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____tp_init__1(PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__ *o;
    const char *keywords[] = {"o", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___Type, &o)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> >(*((PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__ *) o)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____tp_init(PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__ *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___Cleanup(void)
{
    PyObject *py_retval;
    
    ns3::SimpleRefCount< ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> >::Cleanup();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____copy__(PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__ *self)
{

    PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__ *py_copy;
    py_copy = PyObject_New(PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__, &PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___Type);
    py_copy->obj = new ns3::SimpleRefCount< ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> >(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___methods[] = {
    {(char *) "Cleanup", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___Cleanup, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____tp_dealloc(PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__ *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::SimpleRefCount< ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> > *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____tp_richcompare (PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__ *PYBINDGEN_UNUSED(self), PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__ *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__",            /* tp_name */
    sizeof(PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




pybindgen::TypeMap PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____typeid_map;



static int
_wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____tp_init__0(PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::Ipv6MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6MulticastRoute> >();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____tp_init__1(PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__ *o;
    const char *keywords[] = {"o", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type, &o)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::Ipv6MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6MulticastRoute> >(*((PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__ *) o)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____tp_init(PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__ *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Cleanup(void)
{
    PyObject *py_retval;
    
    ns3::SimpleRefCount< ns3::Ipv6MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6MulticastRoute> >::Cleanup();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____copy__(PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__ *self)
{

    PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__ *py_copy;
    py_copy = PyObject_New(PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__, &PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type);
    py_copy->obj = new ns3::SimpleRefCount< ns3::Ipv6MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6MulticastRoute> >(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___methods[] = {
    {(char *) "Cleanup", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Cleanup, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____tp_dealloc(PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__ *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::SimpleRefCount< ns3::Ipv6MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6MulticastRoute> > *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____tp_richcompare (PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__ *PYBINDGEN_UNUSED(self), PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__ *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__",            /* tp_name */
    sizeof(PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




pybindgen::TypeMap PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____typeid_map;



static int
_wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____tp_init__0(PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::Ipv6Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6Route> >();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____tp_init__1(PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__ *o;
    const char *keywords[] = {"o", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___Type, &o)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::Ipv6Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6Route> >(*((PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__ *) o)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____tp_init(PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__ *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___Cleanup(void)
{
    PyObject *py_retval;
    
    ns3::SimpleRefCount< ns3::Ipv6Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6Route> >::Cleanup();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____copy__(PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__ *self)
{

    PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__ *py_copy;
    py_copy = PyObject_New(PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__, &PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___Type);
    py_copy->obj = new ns3::SimpleRefCount< ns3::Ipv6Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6Route> >(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___methods[] = {
    {(char *) "Cleanup", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___Cleanup, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____tp_dealloc(PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__ *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::SimpleRefCount< ns3::Ipv6Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6Route> > *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____tp_richcompare (PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__ *PYBINDGEN_UNUSED(self), PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__ *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__",            /* tp_name */
    sizeof(PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3TcpHeader__tp_init__0(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3TcpHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3TcpHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::TcpHeader(*((PyNs3TcpHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3TcpHeader__tp_init__1(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::TcpHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3TcpHeader__tp_init(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3TcpHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3TcpHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3TcpHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::TcpHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_SetSequenceNumber(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SequenceNumber32 *sequenceNumber;
    const char *keywords[] = {"sequenceNumber", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SequenceNumber32_Type, &sequenceNumber)) {
        return NULL;
    }
    self->obj->SetSequenceNumber(*((PyNs3SequenceNumber32 *) sequenceNumber)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_GetFlags(PyNs3TcpHeader *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetFlags();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_GetSequenceNumber(PyNs3TcpHeader *self)
{
    PyObject *py_retval;
    PyNs3SequenceNumber32 *py_SequenceNumber32;
    
    ns3::SequenceNumber32 retval = self->obj->GetSequenceNumber();
    py_SequenceNumber32 = PyObject_New(PyNs3SequenceNumber32, &PyNs3SequenceNumber32_Type);
    py_SequenceNumber32->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SequenceNumber32->obj = new ns3::SequenceNumber32(retval);
    PyNs3SequenceNumber32_wrapper_registry[(void *) py_SequenceNumber32->obj] = (PyObject *) py_SequenceNumber32;
    py_retval = Py_BuildValue((char *) "N", py_SequenceNumber32);
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_IsChecksumOk(PyNs3TcpHeader *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsChecksumOk();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_EnableChecksums(PyNs3TcpHeader *self)
{
    PyObject *py_retval;
    
    self->obj->EnableChecksums();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_GetUrgentPointer(PyNs3TcpHeader *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetUrgentPointer();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_SetUrgentPointer(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int urgentPointer;
    const char *keywords[] = {"urgentPointer", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &urgentPointer)) {
        return NULL;
    }
    if (urgentPointer > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetUrgentPointer(urgentPointer);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_Deserialize(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_GetLength(PyNs3TcpHeader *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetLength();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_SetWindowSize(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int windowSize;
    const char *keywords[] = {"windowSize", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &windowSize)) {
        return NULL;
    }
    if (windowSize > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetWindowSize(windowSize);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_SetDestinationPort(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int port;
    const char *keywords[] = {"port", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &port)) {
        return NULL;
    }
    if (port > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetDestinationPort(port);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_GetSourcePort(PyNs3TcpHeader *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetSourcePort();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_GetInstanceTypeId(PyNs3TcpHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_GetSerializedSize(PyNs3TcpHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_SetSourcePort(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int port;
    const char *keywords[] = {"port", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &port)) {
        return NULL;
    }
    if (port > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetSourcePort(port);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3TcpHeader_InitializeChecksum__0(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *source;
    PyNs3Ipv4Address *destination;
    int protocol;
    const char *keywords[] = {"source", "destination", "protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!i", (char **) keywords, &PyNs3Ipv4Address_Type, &source, &PyNs3Ipv4Address_Type, &destination, &protocol)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (protocol > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->InitializeChecksum(*((PyNs3Ipv4Address *) source)->obj, *((PyNs3Ipv4Address *) destination)->obj, protocol);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3TcpHeader_InitializeChecksum__1(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *source;
    PyNs3Ipv6Address *destination;
    int protocol;
    const char *keywords[] = {"source", "destination", "protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!i", (char **) keywords, &PyNs3Ipv6Address_Type, &source, &PyNs3Ipv6Address_Type, &destination, &protocol)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (protocol > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->InitializeChecksum(*((PyNs3Ipv6Address *) source)->obj, *((PyNs3Ipv6Address *) destination)->obj, protocol);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3TcpHeader_InitializeChecksum__2(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyObject *source;
    ns3::Address source2;
    PyObject *destination;
    ns3::Address destination2;
    int protocol;
    const char *keywords[] = {"source", "destination", "protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OOi", (char **) keywords, &source, &destination, &protocol)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (PyObject_IsInstance(source, (PyObject*) &PyNs3Address_Type)) {
        source2 = *((PyNs3Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv4Address_Type)) {
        source2 = *((PyNs3Ipv4Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv6Address_Type)) {
        source2 = *((PyNs3Ipv6Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Mac48Address_Type)) {
        source2 = *((PyNs3Mac48Address *) source)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", source->ob_type->tp_name);
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (PyObject_IsInstance(destination, (PyObject*) &PyNs3Address_Type)) {
        destination2 = *((PyNs3Address *) destination)->obj;
    } else if (PyObject_IsInstance(destination, (PyObject*) &PyNs3Ipv4Address_Type)) {
        destination2 = *((PyNs3Ipv4Address *) destination)->obj;
    } else if (PyObject_IsInstance(destination, (PyObject*) &PyNs3Ipv6Address_Type)) {
        destination2 = *((PyNs3Ipv6Address *) destination)->obj;
    } else if (PyObject_IsInstance(destination, (PyObject*) &PyNs3Mac48Address_Type)) {
        destination2 = *((PyNs3Mac48Address *) destination)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", destination->ob_type->tp_name);
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (protocol > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->InitializeChecksum(source2, destination2, protocol);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3TcpHeader_InitializeChecksum(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3TcpHeader_InitializeChecksum__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3TcpHeader_InitializeChecksum__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3TcpHeader_InitializeChecksum__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3TcpHeader_GetWindowSize(PyNs3TcpHeader *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetWindowSize();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_Serialize(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_GetAckNumber(PyNs3TcpHeader *self)
{
    PyObject *py_retval;
    PyNs3SequenceNumber32 *py_SequenceNumber32;
    
    ns3::SequenceNumber32 retval = self->obj->GetAckNumber();
    py_SequenceNumber32 = PyObject_New(PyNs3SequenceNumber32, &PyNs3SequenceNumber32_Type);
    py_SequenceNumber32->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SequenceNumber32->obj = new ns3::SequenceNumber32(retval);
    PyNs3SequenceNumber32_wrapper_registry[(void *) py_SequenceNumber32->obj] = (PyObject *) py_SequenceNumber32;
    py_retval = Py_BuildValue((char *) "N", py_SequenceNumber32);
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_SetAckNumber(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SequenceNumber32 *ackNumber;
    const char *keywords[] = {"ackNumber", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SequenceNumber32_Type, &ackNumber)) {
        return NULL;
    }
    self->obj->SetAckNumber(*((PyNs3SequenceNumber32 *) ackNumber)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_SetFlags(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int flags;
    const char *keywords[] = {"flags", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &flags)) {
        return NULL;
    }
    if (flags > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetFlags(flags);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_SetLength(PyNs3TcpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int length;
    const char *keywords[] = {"length", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &length)) {
        return NULL;
    }
    if (length > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetLength(length);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpHeader_GetDestinationPort(PyNs3TcpHeader *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetDestinationPort();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3TcpHeader__copy__(PyNs3TcpHeader *self)
{

    PyNs3TcpHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3TcpHeader, &PyNs3TcpHeader_Type);
    py_copy->obj = new ns3::TcpHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3TcpHeader_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3TcpHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "SetSequenceNumber", (PyCFunction) _wrap_PyNs3TcpHeader_SetSequenceNumber, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetFlags", (PyCFunction) _wrap_PyNs3TcpHeader_GetFlags, METH_NOARGS, NULL },
    {(char *) "GetSequenceNumber", (PyCFunction) _wrap_PyNs3TcpHeader_GetSequenceNumber, METH_NOARGS, NULL },
    {(char *) "IsChecksumOk", (PyCFunction) _wrap_PyNs3TcpHeader_IsChecksumOk, METH_NOARGS, NULL },
    {(char *) "EnableChecksums", (PyCFunction) _wrap_PyNs3TcpHeader_EnableChecksums, METH_NOARGS, NULL },
    {(char *) "GetUrgentPointer", (PyCFunction) _wrap_PyNs3TcpHeader_GetUrgentPointer, METH_NOARGS, NULL },
    {(char *) "SetUrgentPointer", (PyCFunction) _wrap_PyNs3TcpHeader_SetUrgentPointer, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3TcpHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLength", (PyCFunction) _wrap_PyNs3TcpHeader_GetLength, METH_NOARGS, NULL },
    {(char *) "SetWindowSize", (PyCFunction) _wrap_PyNs3TcpHeader_SetWindowSize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDestinationPort", (PyCFunction) _wrap_PyNs3TcpHeader_SetDestinationPort, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSourcePort", (PyCFunction) _wrap_PyNs3TcpHeader_GetSourcePort, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3TcpHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3TcpHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetSourcePort", (PyCFunction) _wrap_PyNs3TcpHeader_SetSourcePort, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "InitializeChecksum", (PyCFunction) _wrap_PyNs3TcpHeader_InitializeChecksum, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetWindowSize", (PyCFunction) _wrap_PyNs3TcpHeader_GetWindowSize, METH_NOARGS, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3TcpHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAckNumber", (PyCFunction) _wrap_PyNs3TcpHeader_GetAckNumber, METH_NOARGS, NULL },
    {(char *) "SetAckNumber", (PyCFunction) _wrap_PyNs3TcpHeader_SetAckNumber, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetFlags", (PyCFunction) _wrap_PyNs3TcpHeader_SetFlags, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetLength", (PyCFunction) _wrap_PyNs3TcpHeader_SetLength, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDestinationPort", (PyCFunction) _wrap_PyNs3TcpHeader_GetDestinationPort, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3TcpHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3TcpHeader__tp_clear(PyNs3TcpHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::TcpHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3TcpHeader__tp_traverse(PyNs3TcpHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3TcpHeader__tp_dealloc(PyNs3TcpHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3TcpHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3TcpHeader__tp_richcompare (PyNs3TcpHeader *PYBINDGEN_UNUSED(self), PyNs3TcpHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3TcpHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3TcpHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.TcpHeader",            /* tp_name */
    sizeof(PyNs3TcpHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3TcpHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3TcpHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3TcpHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3TcpHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3TcpHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3TcpHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3TcpHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3TcpSocket__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3TcpSocket *self)
{
    PyObject *py_retval;
    PyNs3TcpSocket__PythonHelper *helper = dynamic_cast< PyNs3TcpSocket__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3TcpSocket__PythonHelper::_wrap_NotifyNewAggregate(PyNs3TcpSocket *self)
{
    PyObject *py_retval;
    PyNs3TcpSocket__PythonHelper *helper = dynamic_cast< PyNs3TcpSocket__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3TcpSocket__PythonHelper::_wrap_DoStart(PyNs3TcpSocket *self)
{
    PyObject *py_retval;
    PyNs3TcpSocket__PythonHelper *helper = dynamic_cast< PyNs3TcpSocket__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3TcpSocket__PythonHelper::_wrap_DoDispose(PyNs3TcpSocket *self)
{
    PyObject *py_retval;
    PyNs3TcpSocket__PythonHelper *helper = dynamic_cast< PyNs3TcpSocket__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Socket is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

uint32_t
PyNs3TcpSocket__PythonHelper::GetConnCount() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetConnCount"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = const_cast< ns3::TcpSocket* >((const ns3::TcpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetConnCount", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Time
PyNs3TcpSocket__PythonHelper::GetConnTimeout() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    PyNs3Time *tmp_Time;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetConnTimeout"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Time();
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = const_cast< ns3::TcpSocket* >((const ns3::TcpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetConnTimeout", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Time();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Time_Type, &tmp_Time)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Time();
    }
    ns3::Time retval = *tmp_Time->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3TcpSocket__PythonHelper::GetDelAckMaxCount() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetDelAckMaxCount"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = const_cast< ns3::TcpSocket* >((const ns3::TcpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetDelAckMaxCount", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Time
PyNs3TcpSocket__PythonHelper::GetDelAckTimeout() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    PyNs3Time *tmp_Time;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetDelAckTimeout"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Time();
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = const_cast< ns3::TcpSocket* >((const ns3::TcpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetDelAckTimeout", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Time();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Time_Type, &tmp_Time)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Time();
    }
    ns3::Time retval = *tmp_Time->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3TcpSocket__PythonHelper::GetInitialCwnd() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInitialCwnd"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = const_cast< ns3::TcpSocket* >((const ns3::TcpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInitialCwnd", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Time
PyNs3TcpSocket__PythonHelper::GetPersistTimeout() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    PyNs3Time *tmp_Time;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetPersistTimeout"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Time();
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = const_cast< ns3::TcpSocket* >((const ns3::TcpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetPersistTimeout", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Time();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Time_Type, &tmp_Time)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Time();
    }
    ns3::Time retval = *tmp_Time->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3TcpSocket__PythonHelper::GetRcvBufSize() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetRcvBufSize"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = const_cast< ns3::TcpSocket* >((const ns3::TcpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetRcvBufSize", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3TcpSocket__PythonHelper::GetSSThresh() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetSSThresh"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = const_cast< ns3::TcpSocket* >((const ns3::TcpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetSSThresh", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3TcpSocket__PythonHelper::GetSegSize() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetSegSize"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = const_cast< ns3::TcpSocket* >((const ns3::TcpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetSegSize", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3TcpSocket__PythonHelper::GetSndBufSize() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetSndBufSize"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = const_cast< ns3::TcpSocket* >((const ns3::TcpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetSndBufSize", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3TcpSocket__PythonHelper::GetTcpNoDelay() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetTcpNoDelay"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = const_cast< ns3::TcpSocket* >((const ns3::TcpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetTcpNoDelay", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3TcpSocket__PythonHelper::SetConnCount(uint32_t count)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetConnCount"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = (ns3::TcpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetConnCount", (char *) "N", PyLong_FromUnsignedLong(count));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3TcpSocket__PythonHelper::SetConnTimeout(ns3::Time timeout)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    PyNs3Time *py_Time;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetConnTimeout"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = (ns3::TcpSocket*) this;
    py_Time = PyObject_New(PyNs3Time, &PyNs3Time_Type);
    py_Time->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Time->obj = new ns3::Time(timeout);
    PyNs3Time_wrapper_registry[(void *) py_Time->obj] = (PyObject *) py_Time;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetConnTimeout", (char *) "N", py_Time);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3TcpSocket__PythonHelper::SetDelAckMaxCount(uint32_t count)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetDelAckMaxCount"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = (ns3::TcpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetDelAckMaxCount", (char *) "N", PyLong_FromUnsignedLong(count));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3TcpSocket__PythonHelper::SetDelAckTimeout(ns3::Time timeout)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    PyNs3Time *py_Time;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetDelAckTimeout"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = (ns3::TcpSocket*) this;
    py_Time = PyObject_New(PyNs3Time, &PyNs3Time_Type);
    py_Time->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Time->obj = new ns3::Time(timeout);
    PyNs3Time_wrapper_registry[(void *) py_Time->obj] = (PyObject *) py_Time;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetDelAckTimeout", (char *) "N", py_Time);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3TcpSocket__PythonHelper::SetInitialCwnd(uint32_t count)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetInitialCwnd"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = (ns3::TcpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetInitialCwnd", (char *) "N", PyLong_FromUnsignedLong(count));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3TcpSocket__PythonHelper::SetPersistTimeout(ns3::Time timeout)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    PyNs3Time *py_Time;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetPersistTimeout"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = (ns3::TcpSocket*) this;
    py_Time = PyObject_New(PyNs3Time, &PyNs3Time_Type);
    py_Time->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Time->obj = new ns3::Time(timeout);
    PyNs3Time_wrapper_registry[(void *) py_Time->obj] = (PyObject *) py_Time;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetPersistTimeout", (char *) "N", py_Time);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3TcpSocket__PythonHelper::SetRcvBufSize(uint32_t size)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetRcvBufSize"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = (ns3::TcpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetRcvBufSize", (char *) "N", PyLong_FromUnsignedLong(size));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3TcpSocket__PythonHelper::SetSSThresh(uint32_t threshold)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetSSThresh"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = (ns3::TcpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetSSThresh", (char *) "N", PyLong_FromUnsignedLong(threshold));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3TcpSocket__PythonHelper::SetSegSize(uint32_t size)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetSegSize"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = (ns3::TcpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetSegSize", (char *) "N", PyLong_FromUnsignedLong(size));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3TcpSocket__PythonHelper::SetSndBufSize(uint32_t size)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetSndBufSize"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = (ns3::TcpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetSndBufSize", (char *) "N", PyLong_FromUnsignedLong(size));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3TcpSocket__PythonHelper::SetTcpNoDelay(bool noDelay)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::TcpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetTcpNoDelay"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = (ns3::TcpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetTcpNoDelay", (char *) "N", PyBool_FromLong(noDelay));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3TcpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

uint32_t
PyNs3TcpSocket__PythonHelper::GetRxAvailable() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetRxAvailable"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetRxAvailable", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3TcpSocket__PythonHelper::SetAllowBroadcast(bool allowBroadcast)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetAllowBroadcast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetAllowBroadcast", (char *) "N", PyBool_FromLong(allowBroadcast));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Socket::SocketType
PyNs3TcpSocket__PythonHelper::GetSocketType() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    ns3::Socket::SocketType retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetSocketType"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetSocketType", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3TcpSocket__PythonHelper::Send(ns3::Ptr< ns3::Packet > p, uint32_t flags)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Send"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (p)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (p))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (p))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (p));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Send", (char *) "NN", py_Packet, PyLong_FromUnsignedLong(flags));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3TcpSocket__PythonHelper::Bind6()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Bind6"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Bind6", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3TcpSocket__PythonHelper::GetAllowBroadcast() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetAllowBroadcast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetAllowBroadcast", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Socket::SocketErrno
PyNs3TcpSocket__PythonHelper::GetErrno() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    ns3::Socket::SocketErrno retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetErrno"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetErrno", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Node >
PyNs3TcpSocket__PythonHelper::GetNode() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3Node *tmp_Node;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNode"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNode", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Node_Type, &tmp_Node)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Node  > (tmp_Node->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3TcpSocket__PythonHelper::ShutdownRecv()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "ShutdownRecv"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "ShutdownRecv", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3TcpSocket__PythonHelper::ShutdownSend()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "ShutdownSend"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "ShutdownSend", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3TcpSocket__PythonHelper::GetSockName(ns3::Address & address) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetSockName"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(address);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetSockName", (char *) "N", py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3TcpSocket__PythonHelper::SendTo(ns3::Ptr< ns3::Packet > p, uint32_t flags, ns3::Address const & toAddress)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SendTo"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (p)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (p))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (p))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (p));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(toAddress);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SendTo", (char *) "NNN", py_Packet, PyLong_FromUnsignedLong(flags), py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3TcpSocket__PythonHelper::Listen()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Listen"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Listen", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Packet >
PyNs3TcpSocket__PythonHelper::Recv(uint32_t maxSize, uint32_t flags)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Packet *tmp_Packet;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Recv"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Recv", (char *) "NN", PyLong_FromUnsignedLong(maxSize), PyLong_FromUnsignedLong(flags));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Packet_Type, &tmp_Packet)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Packet  > (tmp_Packet->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3TcpSocket__PythonHelper::Bind(ns3::Address const & address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Bind"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(address);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Bind", (char *) "N", py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3TcpSocket__PythonHelper::Bind()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Bind"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Bind", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3TcpSocket__PythonHelper::GetTxAvailable() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetTxAvailable"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetTxAvailable", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3TcpSocket__PythonHelper::BindToNetDevice(ns3::Ptr< ns3::NetDevice > netdevice)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "BindToNetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Socket::BindToNetDevice(netdevice);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "BindToNetDevice", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::Ptr< ns3::Packet >
PyNs3TcpSocket__PythonHelper::RecvFrom(uint32_t maxSize, uint32_t flags, ns3::Address & fromAddress)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Address *py_Address;
    PyNs3Packet *tmp_Packet;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "RecvFrom"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(fromAddress);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "RecvFrom", (char *) "NNN", PyLong_FromUnsignedLong(maxSize), PyLong_FromUnsignedLong(flags), py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Packet_Type, &tmp_Packet)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Packet  > (tmp_Packet->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3TcpSocket__PythonHelper::Connect(ns3::Address const & address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Connect"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(address);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Connect", (char *) "N", py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3TcpSocket__PythonHelper::Close()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Close"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Close", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3TcpSocket__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Socket::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3TcpSocket__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3TcpSocket__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3TcpSocket__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3TcpSocket__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3TcpSocket__tp_init__0(PyNs3TcpSocket *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3TcpSocket *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3TcpSocket_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3TcpSocket_Type)
    {
        self->obj = new PyNs3TcpSocket__PythonHelper(*((PyNs3TcpSocket *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3TcpSocket__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'TcpSocket' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3TcpSocket__tp_init__1(PyNs3TcpSocket *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3TcpSocket_Type)
    {
        self->obj = new PyNs3TcpSocket__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3TcpSocket__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'TcpSocket' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3TcpSocket__tp_init(PyNs3TcpSocket *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3TcpSocket__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3TcpSocket__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3TcpSocket_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::TcpSocket::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

static PyMethodDef PyNs3TcpSocket_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3TcpSocket_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3TcpSocket__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3TcpSocket__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3TcpSocket__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "DoDispose", (PyCFunction) PyNs3TcpSocket__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3TcpSocket__tp_clear(PyNs3TcpSocket *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::TcpSocket *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3TcpSocket__tp_traverse(PyNs3TcpSocket *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3TcpSocket__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3TcpSocket__tp_dealloc(PyNs3TcpSocket *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3TcpSocket__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3TcpSocket__tp_richcompare (PyNs3TcpSocket *PYBINDGEN_UNUSED(self), PyNs3TcpSocket *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3TcpSocket_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3TcpSocket_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.TcpSocket",            /* tp_name */
    sizeof(PyNs3TcpSocket),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3TcpSocket__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3TcpSocket__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3TcpSocket__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3TcpSocket__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3TcpSocket_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3TcpSocket, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3TcpSocket__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyNs3TcpSocketFactory__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'TcpSocketFactory' cannot be constructed (have pure virtual methods but no helper class)");
    return -1;
}


PyObject *
_wrap_PyNs3TcpSocketFactory_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::TcpSocketFactory::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

static PyMethodDef PyNs3TcpSocketFactory_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3TcpSocketFactory_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3TcpSocketFactory__tp_clear(PyNs3TcpSocketFactory *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::TcpSocketFactory *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3TcpSocketFactory__tp_traverse(PyNs3TcpSocketFactory *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3TcpSocketFactory__tp_dealloc(PyNs3TcpSocketFactory *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3TcpSocketFactory__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3TcpSocketFactory__tp_richcompare (PyNs3TcpSocketFactory *PYBINDGEN_UNUSED(self), PyNs3TcpSocketFactory *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3TcpSocketFactory_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3TcpSocketFactory_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.TcpSocketFactory",            /* tp_name */
    sizeof(PyNs3TcpSocketFactory),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3TcpSocketFactory__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3TcpSocketFactory__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3TcpSocketFactory__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3TcpSocketFactory__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3TcpSocketFactory_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3TcpSocketFactory, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3TcpSocketFactory__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3UdpHeader__tp_init__0(PyNs3UdpHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3UdpHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3UdpHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::UdpHeader(*((PyNs3UdpHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3UdpHeader__tp_init__1(PyNs3UdpHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::UdpHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3UdpHeader__tp_init(PyNs3UdpHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3UdpHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3UdpHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}



PyObject *
_wrap_PyNs3UdpHeader_InitializeChecksum__0(PyNs3UdpHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyObject *source;
    ns3::Address source2;
    PyObject *destination;
    ns3::Address destination2;
    int protocol;
    const char *keywords[] = {"source", "destination", "protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OOi", (char **) keywords, &source, &destination, &protocol)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (PyObject_IsInstance(source, (PyObject*) &PyNs3Address_Type)) {
        source2 = *((PyNs3Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv4Address_Type)) {
        source2 = *((PyNs3Ipv4Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv6Address_Type)) {
        source2 = *((PyNs3Ipv6Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Mac48Address_Type)) {
        source2 = *((PyNs3Mac48Address *) source)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", source->ob_type->tp_name);
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (PyObject_IsInstance(destination, (PyObject*) &PyNs3Address_Type)) {
        destination2 = *((PyNs3Address *) destination)->obj;
    } else if (PyObject_IsInstance(destination, (PyObject*) &PyNs3Ipv4Address_Type)) {
        destination2 = *((PyNs3Ipv4Address *) destination)->obj;
    } else if (PyObject_IsInstance(destination, (PyObject*) &PyNs3Ipv6Address_Type)) {
        destination2 = *((PyNs3Ipv6Address *) destination)->obj;
    } else if (PyObject_IsInstance(destination, (PyObject*) &PyNs3Mac48Address_Type)) {
        destination2 = *((PyNs3Mac48Address *) destination)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", destination->ob_type->tp_name);
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (protocol > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->InitializeChecksum(source2, destination2, protocol);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3UdpHeader_InitializeChecksum__1(PyNs3UdpHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *source;
    PyNs3Ipv4Address *destination;
    int protocol;
    const char *keywords[] = {"source", "destination", "protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!i", (char **) keywords, &PyNs3Ipv4Address_Type, &source, &PyNs3Ipv4Address_Type, &destination, &protocol)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (protocol > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->InitializeChecksum(*((PyNs3Ipv4Address *) source)->obj, *((PyNs3Ipv4Address *) destination)->obj, protocol);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3UdpHeader_InitializeChecksum__2(PyNs3UdpHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *source;
    PyNs3Ipv6Address *destination;
    int protocol;
    const char *keywords[] = {"source", "destination", "protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!i", (char **) keywords, &PyNs3Ipv6Address_Type, &source, &PyNs3Ipv6Address_Type, &destination, &protocol)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (protocol > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->InitializeChecksum(*((PyNs3Ipv6Address *) source)->obj, *((PyNs3Ipv6Address *) destination)->obj, protocol);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3UdpHeader_InitializeChecksum(PyNs3UdpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3UdpHeader_InitializeChecksum__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3UdpHeader_InitializeChecksum__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3UdpHeader_InitializeChecksum__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3UdpHeader_Serialize(PyNs3UdpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpHeader_Deserialize(PyNs3UdpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::UdpHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpHeader_IsChecksumOk(PyNs3UdpHeader *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsChecksumOk();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpHeader_EnableChecksums(PyNs3UdpHeader *self)
{
    PyObject *py_retval;
    
    self->obj->EnableChecksums();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpHeader_GetSourcePort(PyNs3UdpHeader *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetSourcePort();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpHeader_GetInstanceTypeId(PyNs3UdpHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpHeader_GetSerializedSize(PyNs3UdpHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpHeader_SetDestinationPort(PyNs3UdpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int port;
    const char *keywords[] = {"port", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &port)) {
        return NULL;
    }
    if (port > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetDestinationPort(port);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpHeader_SetSourcePort(PyNs3UdpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int port;
    const char *keywords[] = {"port", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &port)) {
        return NULL;
    }
    if (port > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetSourcePort(port);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpHeader_GetDestinationPort(PyNs3UdpHeader *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetDestinationPort();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3UdpHeader__copy__(PyNs3UdpHeader *self)
{

    PyNs3UdpHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3UdpHeader, &PyNs3UdpHeader_Type);
    py_copy->obj = new ns3::UdpHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3UdpHeader_methods[] = {
    {(char *) "InitializeChecksum", (PyCFunction) _wrap_PyNs3UdpHeader_InitializeChecksum, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3UdpHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3UdpHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3UdpHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "IsChecksumOk", (PyCFunction) _wrap_PyNs3UdpHeader_IsChecksumOk, METH_NOARGS, NULL },
    {(char *) "EnableChecksums", (PyCFunction) _wrap_PyNs3UdpHeader_EnableChecksums, METH_NOARGS, NULL },
    {(char *) "GetSourcePort", (PyCFunction) _wrap_PyNs3UdpHeader_GetSourcePort, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3UdpHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3UdpHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetDestinationPort", (PyCFunction) _wrap_PyNs3UdpHeader_SetDestinationPort, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetSourcePort", (PyCFunction) _wrap_PyNs3UdpHeader_SetSourcePort, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDestinationPort", (PyCFunction) _wrap_PyNs3UdpHeader_GetDestinationPort, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3UdpHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3UdpHeader__tp_clear(PyNs3UdpHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::UdpHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3UdpHeader__tp_traverse(PyNs3UdpHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3UdpHeader__tp_dealloc(PyNs3UdpHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3UdpHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3UdpHeader__tp_richcompare (PyNs3UdpHeader *PYBINDGEN_UNUSED(self), PyNs3UdpHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3UdpHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3UdpHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.UdpHeader",            /* tp_name */
    sizeof(PyNs3UdpHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3UdpHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3UdpHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3UdpHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3UdpHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3UdpHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3UdpHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3UdpHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3UdpSocket__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3UdpSocket *self)
{
    PyObject *py_retval;
    PyNs3UdpSocket__PythonHelper *helper = dynamic_cast< PyNs3UdpSocket__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3UdpSocket__PythonHelper::_wrap_NotifyNewAggregate(PyNs3UdpSocket *self)
{
    PyObject *py_retval;
    PyNs3UdpSocket__PythonHelper *helper = dynamic_cast< PyNs3UdpSocket__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3UdpSocket__PythonHelper::_wrap_DoStart(PyNs3UdpSocket *self)
{
    PyObject *py_retval;
    PyNs3UdpSocket__PythonHelper *helper = dynamic_cast< PyNs3UdpSocket__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3UdpSocket__PythonHelper::_wrap_DoDispose(PyNs3UdpSocket *self)
{
    PyObject *py_retval;
    PyNs3UdpSocket__PythonHelper *helper = dynamic_cast< PyNs3UdpSocket__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Socket is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

int
PyNs3UdpSocket__PythonHelper::MulticastJoinGroup(uint32_t interface, ns3::Address const & groupAddress)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "MulticastJoinGroup"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = (ns3::UdpSocket*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(groupAddress);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "MulticastJoinGroup", (char *) "NN", PyLong_FromUnsignedLong(interface), py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3UdpSocket__PythonHelper::MulticastLeaveGroup(uint32_t interface, ns3::Address const & groupAddress)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "MulticastLeaveGroup"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = (ns3::UdpSocket*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(groupAddress);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "MulticastLeaveGroup", (char *) "NN", PyLong_FromUnsignedLong(interface), py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3UdpSocket__PythonHelper::GetIpMulticastIf() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetIpMulticastIf"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = const_cast< ns3::UdpSocket* >((const ns3::UdpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetIpMulticastIf", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3UdpSocket__PythonHelper::GetIpMulticastLoop() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetIpMulticastLoop"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = const_cast< ns3::UdpSocket* >((const ns3::UdpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetIpMulticastLoop", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint8_t
PyNs3UdpSocket__PythonHelper::GetIpMulticastTtl() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    uint8_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetIpMulticastTtl"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = const_cast< ns3::UdpSocket* >((const ns3::UdpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetIpMulticastTtl", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    if (tmp > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint8_t
PyNs3UdpSocket__PythonHelper::GetIpTtl() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    uint8_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetIpTtl"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = const_cast< ns3::UdpSocket* >((const ns3::UdpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetIpTtl", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    if (tmp > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3UdpSocket__PythonHelper::GetMtuDiscover() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetMtuDiscover"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = const_cast< ns3::UdpSocket* >((const ns3::UdpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetMtuDiscover", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3UdpSocket__PythonHelper::GetRcvBufSize() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetRcvBufSize"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = const_cast< ns3::UdpSocket* >((const ns3::UdpSocket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetRcvBufSize", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3UdpSocket__PythonHelper::SetIpMulticastIf(int32_t ipIf)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetIpMulticastIf"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = (ns3::UdpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetIpMulticastIf", (char *) "i", ipIf);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3UdpSocket__PythonHelper::SetIpMulticastLoop(bool loop)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetIpMulticastLoop"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = (ns3::UdpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetIpMulticastLoop", (char *) "N", PyBool_FromLong(loop));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3UdpSocket__PythonHelper::SetIpMulticastTtl(uint8_t ipTtl)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetIpMulticastTtl"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = (ns3::UdpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetIpMulticastTtl", (char *) "i", (int) ipTtl);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3UdpSocket__PythonHelper::SetIpTtl(uint8_t ipTtl)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetIpTtl"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = (ns3::UdpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetIpTtl", (char *) "i", (int) ipTtl);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3UdpSocket__PythonHelper::SetMtuDiscover(bool discover)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetMtuDiscover"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = (ns3::UdpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetMtuDiscover", (char *) "N", PyBool_FromLong(discover));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3UdpSocket__PythonHelper::SetRcvBufSize(uint32_t size)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::UdpSocket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetRcvBufSize"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = (ns3::UdpSocket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetRcvBufSize", (char *) "N", PyLong_FromUnsignedLong(size));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3UdpSocket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

uint32_t
PyNs3UdpSocket__PythonHelper::GetRxAvailable() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetRxAvailable"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetRxAvailable", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3UdpSocket__PythonHelper::SetAllowBroadcast(bool allowBroadcast)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetAllowBroadcast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetAllowBroadcast", (char *) "N", PyBool_FromLong(allowBroadcast));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Socket::SocketType
PyNs3UdpSocket__PythonHelper::GetSocketType() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    ns3::Socket::SocketType retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetSocketType"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetSocketType", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3UdpSocket__PythonHelper::Send(ns3::Ptr< ns3::Packet > p, uint32_t flags)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Send"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (p)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (p))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (p))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (p));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Send", (char *) "NN", py_Packet, PyLong_FromUnsignedLong(flags));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3UdpSocket__PythonHelper::Bind6()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Bind6"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Bind6", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3UdpSocket__PythonHelper::GetAllowBroadcast() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetAllowBroadcast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetAllowBroadcast", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Socket::SocketErrno
PyNs3UdpSocket__PythonHelper::GetErrno() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    ns3::Socket::SocketErrno retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetErrno"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetErrno", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Node >
PyNs3UdpSocket__PythonHelper::GetNode() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3Node *tmp_Node;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNode"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNode", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Node_Type, &tmp_Node)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Node  > (tmp_Node->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3UdpSocket__PythonHelper::ShutdownRecv()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "ShutdownRecv"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "ShutdownRecv", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3UdpSocket__PythonHelper::ShutdownSend()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "ShutdownSend"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "ShutdownSend", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3UdpSocket__PythonHelper::GetSockName(ns3::Address & address) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetSockName"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(address);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetSockName", (char *) "N", py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3UdpSocket__PythonHelper::SendTo(ns3::Ptr< ns3::Packet > p, uint32_t flags, ns3::Address const & toAddress)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SendTo"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (p)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (p))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (p))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (p));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(toAddress);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SendTo", (char *) "NNN", py_Packet, PyLong_FromUnsignedLong(flags), py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3UdpSocket__PythonHelper::Listen()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Listen"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Listen", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Packet >
PyNs3UdpSocket__PythonHelper::Recv(uint32_t maxSize, uint32_t flags)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Packet *tmp_Packet;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Recv"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Recv", (char *) "NN", PyLong_FromUnsignedLong(maxSize), PyLong_FromUnsignedLong(flags));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Packet_Type, &tmp_Packet)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Packet  > (tmp_Packet->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3UdpSocket__PythonHelper::Bind(ns3::Address const & address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Bind"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(address);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Bind", (char *) "N", py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3UdpSocket__PythonHelper::Bind()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Bind"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Bind", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3UdpSocket__PythonHelper::GetTxAvailable() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetTxAvailable"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = const_cast< ns3::Socket* >((const ns3::Socket*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetTxAvailable", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3UdpSocket__PythonHelper::BindToNetDevice(ns3::Ptr< ns3::NetDevice > netdevice)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "BindToNetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Socket::BindToNetDevice(netdevice);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "BindToNetDevice", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::Ptr< ns3::Packet >
PyNs3UdpSocket__PythonHelper::RecvFrom(uint32_t maxSize, uint32_t flags, ns3::Address & fromAddress)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Address *py_Address;
    PyNs3Packet *tmp_Packet;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "RecvFrom"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(fromAddress);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "RecvFrom", (char *) "NNN", PyLong_FromUnsignedLong(maxSize), PyLong_FromUnsignedLong(flags), py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Packet_Type, &tmp_Packet)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Packet  > (tmp_Packet->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3UdpSocket__PythonHelper::Connect(ns3::Address const & address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Connect"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(address);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Connect", (char *) "N", py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3UdpSocket__PythonHelper::Close()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Close"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Close", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3UdpSocket__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Socket::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3UdpSocket__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3UdpSocket__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3UdpSocket__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3UdpSocket__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3UdpSocket__tp_init__0(PyNs3UdpSocket *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3UdpSocket *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3UdpSocket_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3UdpSocket_Type)
    {
        self->obj = new PyNs3UdpSocket__PythonHelper(*((PyNs3UdpSocket *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3UdpSocket__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'UdpSocket' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3UdpSocket__tp_init__1(PyNs3UdpSocket *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3UdpSocket_Type)
    {
        self->obj = new PyNs3UdpSocket__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3UdpSocket__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'UdpSocket' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3UdpSocket__tp_init(PyNs3UdpSocket *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3UdpSocket__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3UdpSocket__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3UdpSocket_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::UdpSocket::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpSocket_MulticastJoinGroup(PyNs3UdpSocket *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    unsigned int interface;
    PyObject *groupAddress;
    ns3::Address groupAddress2;
    const char *keywords[] = {"interface", "groupAddress", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO", (char **) keywords, &interface, &groupAddress)) {
        return NULL;
    }
    if (PyObject_IsInstance(groupAddress, (PyObject*) &PyNs3Address_Type)) {
        groupAddress2 = *((PyNs3Address *) groupAddress)->obj;
    } else if (PyObject_IsInstance(groupAddress, (PyObject*) &PyNs3Ipv4Address_Type)) {
        groupAddress2 = *((PyNs3Ipv4Address *) groupAddress)->obj;
    } else if (PyObject_IsInstance(groupAddress, (PyObject*) &PyNs3Ipv6Address_Type)) {
        groupAddress2 = *((PyNs3Ipv6Address *) groupAddress)->obj;
    } else if (PyObject_IsInstance(groupAddress, (PyObject*) &PyNs3Mac48Address_Type)) {
        groupAddress2 = *((PyNs3Mac48Address *) groupAddress)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", groupAddress->ob_type->tp_name);
        return NULL;
    }
    retval = self->obj->MulticastJoinGroup(interface, groupAddress2);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpSocket_MulticastLeaveGroup(PyNs3UdpSocket *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    unsigned int interface;
    PyObject *groupAddress;
    ns3::Address groupAddress2;
    const char *keywords[] = {"interface", "groupAddress", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO", (char **) keywords, &interface, &groupAddress)) {
        return NULL;
    }
    if (PyObject_IsInstance(groupAddress, (PyObject*) &PyNs3Address_Type)) {
        groupAddress2 = *((PyNs3Address *) groupAddress)->obj;
    } else if (PyObject_IsInstance(groupAddress, (PyObject*) &PyNs3Ipv4Address_Type)) {
        groupAddress2 = *((PyNs3Ipv4Address *) groupAddress)->obj;
    } else if (PyObject_IsInstance(groupAddress, (PyObject*) &PyNs3Ipv6Address_Type)) {
        groupAddress2 = *((PyNs3Ipv6Address *) groupAddress)->obj;
    } else if (PyObject_IsInstance(groupAddress, (PyObject*) &PyNs3Mac48Address_Type)) {
        groupAddress2 = *((PyNs3Mac48Address *) groupAddress)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", groupAddress->ob_type->tp_name);
        return NULL;
    }
    retval = self->obj->MulticastLeaveGroup(interface, groupAddress2);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

static PyMethodDef PyNs3UdpSocket_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3UdpSocket_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "MulticastJoinGroup", (PyCFunction) _wrap_PyNs3UdpSocket_MulticastJoinGroup, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "MulticastLeaveGroup", (PyCFunction) _wrap_PyNs3UdpSocket_MulticastLeaveGroup, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3UdpSocket__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3UdpSocket__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3UdpSocket__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "DoDispose", (PyCFunction) PyNs3UdpSocket__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3UdpSocket__tp_clear(PyNs3UdpSocket *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::UdpSocket *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3UdpSocket__tp_traverse(PyNs3UdpSocket *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3UdpSocket__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3UdpSocket__tp_dealloc(PyNs3UdpSocket *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3UdpSocket__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3UdpSocket__tp_richcompare (PyNs3UdpSocket *PYBINDGEN_UNUSED(self), PyNs3UdpSocket *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3UdpSocket_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3UdpSocket_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.UdpSocket",            /* tp_name */
    sizeof(PyNs3UdpSocket),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3UdpSocket__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3UdpSocket__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3UdpSocket__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3UdpSocket__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3UdpSocket_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3UdpSocket, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3UdpSocket__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyNs3UdpSocketFactory__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'UdpSocketFactory' cannot be constructed (have pure virtual methods but no helper class)");
    return -1;
}


PyObject *
_wrap_PyNs3UdpSocketFactory_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::UdpSocketFactory::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

static PyMethodDef PyNs3UdpSocketFactory_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3UdpSocketFactory_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3UdpSocketFactory__tp_clear(PyNs3UdpSocketFactory *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::UdpSocketFactory *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3UdpSocketFactory__tp_traverse(PyNs3UdpSocketFactory *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3UdpSocketFactory__tp_dealloc(PyNs3UdpSocketFactory *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3UdpSocketFactory__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3UdpSocketFactory__tp_richcompare (PyNs3UdpSocketFactory *PYBINDGEN_UNUSED(self), PyNs3UdpSocketFactory *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3UdpSocketFactory_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3UdpSocketFactory_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.UdpSocketFactory",            /* tp_name */
    sizeof(PyNs3UdpSocketFactory),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3UdpSocketFactory__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3UdpSocketFactory__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3UdpSocketFactory__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3UdpSocketFactory__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3UdpSocketFactory_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3UdpSocketFactory, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3UdpSocketFactory__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3ArpCache__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3ArpCache *self)
{
    PyObject *py_retval;
    PyNs3ArpCache__PythonHelper *helper = dynamic_cast< PyNs3ArpCache__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3ArpCache__PythonHelper::_wrap_NotifyNewAggregate(PyNs3ArpCache *self)
{
    PyObject *py_retval;
    PyNs3ArpCache__PythonHelper *helper = dynamic_cast< PyNs3ArpCache__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3ArpCache__PythonHelper::_wrap_DoStart(PyNs3ArpCache *self)
{
    PyObject *py_retval;
    PyNs3ArpCache__PythonHelper *helper = dynamic_cast< PyNs3ArpCache__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

void
PyNs3ArpCache__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ArpCache *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ArpCache* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ArpCache* >(m_pyself)->obj = (ns3::ArpCache*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ArpCache* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ArpCache* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ArpCache* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3ArpCache__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3ArpCache__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3ArpCache__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3ArpCache__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

static int
_wrap_PyNs3ArpCache__tp_init(PyNs3ArpCache *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    if (self->ob_type != &PyNs3ArpCache_Type)
    {
        self->obj = new PyNs3ArpCache__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3ArpCache__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::ArpCache();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}


PyObject *
_wrap_PyNs3ArpCache_SetWaitReplyTimeout(PyNs3ArpCache *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Time *waitReplyTimeout;
    const char *keywords[] = {"waitReplyTimeout", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Time_Type, &waitReplyTimeout)) {
        return NULL;
    }
    self->obj->SetWaitReplyTimeout(*((PyNs3Time *) waitReplyTimeout)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCache_SetAliveTimeout(PyNs3ArpCache *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Time *aliveTimeout;
    const char *keywords[] = {"aliveTimeout", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Time_Type, &aliveTimeout)) {
        return NULL;
    }
    self->obj->SetAliveTimeout(*((PyNs3Time *) aliveTimeout)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCache_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::ArpCache::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCache_Flush(PyNs3ArpCache *self)
{
    PyObject *py_retval;
    
    self->obj->Flush();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCache_SetDeadTimeout(PyNs3ArpCache *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Time *deadTimeout;
    const char *keywords[] = {"deadTimeout", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Time_Type, &deadTimeout)) {
        return NULL;
    }
    self->obj->SetDeadTimeout(*((PyNs3Time *) deadTimeout)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCache_SetArpRequestCallback(PyNs3ArpCache *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *arpRequestCallback;
    ns3::Ptr<PythonCallbackImpl12> arpRequestCallback_cb_impl;
    const char *keywords[] = {"arpRequestCallback", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &arpRequestCallback)) {
        return NULL;
    }
    if (!PyCallable_Check(arpRequestCallback)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'arpRequestCallback' must be callbale");
        return NULL;
    }
    arpRequestCallback_cb_impl = ns3::Create<PythonCallbackImpl12> (arpRequestCallback);
    self->obj->SetArpRequestCallback(ns3::Callback<void, ns3::Ptr<ns3::ArpCache const>, ns3::Ipv4Address, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (arpRequestCallback_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCache_GetAliveTimeout(PyNs3ArpCache *self)
{
    PyObject *py_retval;
    PyNs3Time *py_Time;
    
    ns3::Time retval = self->obj->GetAliveTimeout();
    py_Time = PyObject_New(PyNs3Time, &PyNs3Time_Type);
    py_Time->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Time->obj = new ns3::Time(retval);
    PyNs3Time_wrapper_registry[(void *) py_Time->obj] = (PyObject *) py_Time;
    py_retval = Py_BuildValue((char *) "N", py_Time);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCache_StartWaitReplyTimer(PyNs3ArpCache *self)
{
    PyObject *py_retval;
    
    self->obj->StartWaitReplyTimer();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCache_GetWaitReplyTimeout(PyNs3ArpCache *self)
{
    PyObject *py_retval;
    PyNs3Time *py_Time;
    
    ns3::Time retval = self->obj->GetWaitReplyTimeout();
    py_Time = PyObject_New(PyNs3Time, &PyNs3Time_Type);
    py_Time->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Time->obj = new ns3::Time(retval);
    PyNs3Time_wrapper_registry[(void *) py_Time->obj] = (PyObject *) py_Time;
    py_retval = Py_BuildValue((char *) "N", py_Time);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCache_SetDevice(PyNs3ArpCache *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Ipv4Interface *interface;
    ns3::Ipv4Interface *interface_ptr;
    const char *keywords[] = {"device", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3NetDevice_Type, &device, &PyNs3Ipv4Interface_Type, &interface)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    interface_ptr = (interface ? interface->obj : NULL);
    self->obj->SetDevice(ns3::Ptr< ns3::NetDevice  > (device_ptr), ns3::Ptr< ns3::Ipv4Interface  > (interface_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCache_GetDeadTimeout(PyNs3ArpCache *self)
{
    PyObject *py_retval;
    PyNs3Time *py_Time;
    
    ns3::Time retval = self->obj->GetDeadTimeout();
    py_Time = PyObject_New(PyNs3Time, &PyNs3Time_Type);
    py_Time->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Time->obj = new ns3::Time(retval);
    PyNs3Time_wrapper_registry[(void *) py_Time->obj] = (PyObject *) py_Time;
    py_retval = Py_BuildValue((char *) "N", py_Time);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCache_GetInterface(PyNs3ArpCache *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4Interface > retval;
    PyNs3Ipv4Interface *py_Ipv4Interface;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetInterface();
    if (!(const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Ipv4Interface__PythonHelper).name())
    {
        py_Ipv4Interface = reinterpret_cast< PyNs3Ipv4Interface* >(reinterpret_cast< PyNs3Ipv4Interface__PythonHelper* >(const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Ipv4Interface->obj = const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Ipv4Interface);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Ipv4Interface = NULL;
        } else {
            py_Ipv4Interface = (PyNs3Ipv4Interface *) wrapper_lookup_iter->second;
            Py_INCREF(py_Ipv4Interface);
        }
    
        if (py_Ipv4Interface == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4Interface_Type);
            py_Ipv4Interface = PyObject_GC_New(PyNs3Ipv4Interface, wrapper_type);
            py_Ipv4Interface->inst_dict = NULL;
            py_Ipv4Interface->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval))->Ref();
            py_Ipv4Interface->obj = const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4Interface->obj] = (PyObject *) py_Ipv4Interface;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Interface);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCache_GetDevice(PyNs3ArpCache *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetDevice();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}

static PyMethodDef PyNs3ArpCache_methods[] = {
    {(char *) "SetWaitReplyTimeout", (PyCFunction) _wrap_PyNs3ArpCache_SetWaitReplyTimeout, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetAliveTimeout", (PyCFunction) _wrap_PyNs3ArpCache_SetAliveTimeout, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3ArpCache_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Flush", (PyCFunction) _wrap_PyNs3ArpCache_Flush, METH_NOARGS, NULL },
    {(char *) "SetDeadTimeout", (PyCFunction) _wrap_PyNs3ArpCache_SetDeadTimeout, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetArpRequestCallback", (PyCFunction) _wrap_PyNs3ArpCache_SetArpRequestCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAliveTimeout", (PyCFunction) _wrap_PyNs3ArpCache_GetAliveTimeout, METH_NOARGS, NULL },
    {(char *) "StartWaitReplyTimer", (PyCFunction) _wrap_PyNs3ArpCache_StartWaitReplyTimer, METH_NOARGS, NULL },
    {(char *) "GetWaitReplyTimeout", (PyCFunction) _wrap_PyNs3ArpCache_GetWaitReplyTimeout, METH_NOARGS, NULL },
    {(char *) "SetDevice", (PyCFunction) _wrap_PyNs3ArpCache_SetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDeadTimeout", (PyCFunction) _wrap_PyNs3ArpCache_GetDeadTimeout, METH_NOARGS, NULL },
    {(char *) "GetInterface", (PyCFunction) _wrap_PyNs3ArpCache_GetInterface, METH_NOARGS, NULL },
    {(char *) "GetDevice", (PyCFunction) _wrap_PyNs3ArpCache_GetDevice, METH_NOARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3ArpCache__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3ArpCache__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3ArpCache__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3ArpCache__tp_clear(PyNs3ArpCache *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::ArpCache *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3ArpCache__tp_traverse(PyNs3ArpCache *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3ArpCache__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3ArpCache__tp_dealloc(PyNs3ArpCache *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3ArpCache__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3ArpCache__tp_richcompare (PyNs3ArpCache *PYBINDGEN_UNUSED(self), PyNs3ArpCache *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3ArpCache_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3ArpCache_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.ArpCache",            /* tp_name */
    sizeof(PyNs3ArpCache),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3ArpCache__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3ArpCache__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3ArpCache__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3ArpCache__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3ArpCache_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3ArpCache, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3ArpCache__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3ArpCacheEntry_wrapper_registry;

static int
_wrap_PyNs3ArpCacheEntry__tp_init(PyNs3ArpCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyNs3ArpCacheEntry *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3ArpCacheEntry_Type, &arg0)) {
        return -1;
    }
    self->obj = new ns3::ArpCache::Entry(*((PyNs3ArpCacheEntry *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_GetRetries(PyNs3ArpCacheEntry *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetRetries();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_DequeuePending(PyNs3ArpCacheEntry *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->DequeuePending();
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (retval))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_GetMacAddress(PyNs3ArpCacheEntry *self)
{
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    ns3::Address retval = self->obj->GetMacAddress();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_ClearRetries(PyNs3ArpCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->ClearRetries();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_IsAlive(PyNs3ArpCacheEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsAlive();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_MarkWaitReply(PyNs3ArpCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *waiting;
    ns3::Packet *waiting_ptr;
    const char *keywords[] = {"waiting", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &waiting)) {
        return NULL;
    }
    waiting_ptr = (waiting ? waiting->obj : NULL);
    self->obj->MarkWaitReply(ns3::Ptr< ns3::Packet  > (waiting_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_MarkDead(PyNs3ArpCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->MarkDead();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_SetIpv4Address(PyNs3ArpCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *destination;
    const char *keywords[] = {"destination", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &destination)) {
        return NULL;
    }
    self->obj->SetIpv4Address(*((PyNs3Ipv4Address *) destination)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_UpdateWaitReply(PyNs3ArpCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *waiting;
    ns3::Packet *waiting_ptr;
    const char *keywords[] = {"waiting", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &waiting)) {
        return NULL;
    }
    waiting_ptr = (waiting ? waiting->obj : NULL);
    retval = self->obj->UpdateWaitReply(ns3::Ptr< ns3::Packet  > (waiting_ptr));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_IncrementRetries(PyNs3ArpCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->IncrementRetries();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_GetIpv4Address(PyNs3ArpCacheEntry *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetIpv4Address();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_IsDead(PyNs3ArpCacheEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsDead();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_IsExpired(PyNs3ArpCacheEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsExpired();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_IsWaitReply(PyNs3ArpCacheEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsWaitReply();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpCacheEntry_MarkAlive(PyNs3ArpCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *macAddress;
    ns3::Address macAddress2;
    const char *keywords[] = {"macAddress", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &macAddress)) {
        return NULL;
    }
    if (PyObject_IsInstance(macAddress, (PyObject*) &PyNs3Address_Type)) {
        macAddress2 = *((PyNs3Address *) macAddress)->obj;
    } else if (PyObject_IsInstance(macAddress, (PyObject*) &PyNs3Ipv4Address_Type)) {
        macAddress2 = *((PyNs3Ipv4Address *) macAddress)->obj;
    } else if (PyObject_IsInstance(macAddress, (PyObject*) &PyNs3Ipv6Address_Type)) {
        macAddress2 = *((PyNs3Ipv6Address *) macAddress)->obj;
    } else if (PyObject_IsInstance(macAddress, (PyObject*) &PyNs3Mac48Address_Type)) {
        macAddress2 = *((PyNs3Mac48Address *) macAddress)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", macAddress->ob_type->tp_name);
        return NULL;
    }
    self->obj->MarkAlive(macAddress2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3ArpCacheEntry__copy__(PyNs3ArpCacheEntry *self)
{

    PyNs3ArpCacheEntry *py_copy;
    py_copy = PyObject_New(PyNs3ArpCacheEntry, &PyNs3ArpCacheEntry_Type);
    py_copy->obj = new ns3::ArpCache::Entry(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ArpCacheEntry_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3ArpCacheEntry_methods[] = {
    {(char *) "GetRetries", (PyCFunction) _wrap_PyNs3ArpCacheEntry_GetRetries, METH_NOARGS, NULL },
    {(char *) "DequeuePending", (PyCFunction) _wrap_PyNs3ArpCacheEntry_DequeuePending, METH_NOARGS, NULL },
    {(char *) "GetMacAddress", (PyCFunction) _wrap_PyNs3ArpCacheEntry_GetMacAddress, METH_NOARGS, NULL },
    {(char *) "ClearRetries", (PyCFunction) _wrap_PyNs3ArpCacheEntry_ClearRetries, METH_NOARGS, NULL },
    {(char *) "IsAlive", (PyCFunction) _wrap_PyNs3ArpCacheEntry_IsAlive, METH_NOARGS, NULL },
    {(char *) "MarkWaitReply", (PyCFunction) _wrap_PyNs3ArpCacheEntry_MarkWaitReply, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "MarkDead", (PyCFunction) _wrap_PyNs3ArpCacheEntry_MarkDead, METH_NOARGS, NULL },
    {(char *) "SetIpv4Address", (PyCFunction) _wrap_PyNs3ArpCacheEntry_SetIpv4Address, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "UpdateWaitReply", (PyCFunction) _wrap_PyNs3ArpCacheEntry_UpdateWaitReply, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IncrementRetries", (PyCFunction) _wrap_PyNs3ArpCacheEntry_IncrementRetries, METH_NOARGS, NULL },
    {(char *) "GetIpv4Address", (PyCFunction) _wrap_PyNs3ArpCacheEntry_GetIpv4Address, METH_NOARGS, NULL },
    {(char *) "IsDead", (PyCFunction) _wrap_PyNs3ArpCacheEntry_IsDead, METH_NOARGS, NULL },
    {(char *) "IsExpired", (PyCFunction) _wrap_PyNs3ArpCacheEntry_IsExpired, METH_NOARGS, NULL },
    {(char *) "IsWaitReply", (PyCFunction) _wrap_PyNs3ArpCacheEntry_IsWaitReply, METH_NOARGS, NULL },
    {(char *) "MarkAlive", (PyCFunction) _wrap_PyNs3ArpCacheEntry_MarkAlive, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3ArpCacheEntry__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3ArpCacheEntry__tp_dealloc(PyNs3ArpCacheEntry *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ArpCacheEntry_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ArpCacheEntry_wrapper_registry.end()) {
        PyNs3ArpCacheEntry_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::ArpCache::Entry *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3ArpCacheEntry__tp_richcompare (PyNs3ArpCacheEntry *PYBINDGEN_UNUSED(self), PyNs3ArpCacheEntry *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3ArpCacheEntry_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3ArpCacheEntry_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.ArpCache.Entry",            /* tp_name */
    sizeof(PyNs3ArpCacheEntry),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3ArpCacheEntry__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3ArpCacheEntry__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3ArpCacheEntry_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3ArpCacheEntry__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3ArpHeader__get_m_ipv4Dest(PyNs3ArpHeader *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(self->obj->m_ipv4Dest);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}
static int _wrap_PyNs3ArpHeader__set_m_ipv4Dest(PyNs3ArpHeader *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3Ipv4Address *tmp_Ipv4Address;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv4Address_Type, &tmp_Ipv4Address)) {
        Py_DECREF(py_retval);
        return -1;
    }
    self->obj->m_ipv4Dest = *tmp_Ipv4Address->obj;
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyNs3ArpHeader__get_m_ipv4Source(PyNs3ArpHeader *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(self->obj->m_ipv4Source);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}
static int _wrap_PyNs3ArpHeader__set_m_ipv4Source(PyNs3ArpHeader *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3Ipv4Address *tmp_Ipv4Address;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv4Address_Type, &tmp_Ipv4Address)) {
        Py_DECREF(py_retval);
        return -1;
    }
    self->obj->m_ipv4Source = *tmp_Ipv4Address->obj;
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyNs3ArpHeader__get_m_macDest(PyNs3ArpHeader *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(self->obj->m_macDest);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}
static int _wrap_PyNs3ArpHeader__set_m_macDest(PyNs3ArpHeader *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3Address *tmp_Address;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        Py_DECREF(py_retval);
        return -1;
    }
    self->obj->m_macDest = *tmp_Address->obj;
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyNs3ArpHeader__get_m_macSource(PyNs3ArpHeader *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(self->obj->m_macSource);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}
static int _wrap_PyNs3ArpHeader__set_m_macSource(PyNs3ArpHeader *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3Address *tmp_Address;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        Py_DECREF(py_retval);
        return -1;
    }
    self->obj->m_macSource = *tmp_Address->obj;
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyNs3ArpHeader__get_m_type(PyNs3ArpHeader *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", self->obj->m_type);
    return py_retval;
}
static int _wrap_PyNs3ArpHeader__set_m_type(PyNs3ArpHeader *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    int tmp;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        Py_DECREF(py_retval);
        return -1;
    }
    if (tmp > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        return -1;
    }
    self->obj->m_type = tmp;
    Py_DECREF(py_retval);
    return 0;
}
static PyGetSetDef PyNs3ArpHeader__getsets[] = {
    {
        (char*) "m_macSource", /* attribute name */
        (getter) _wrap_PyNs3ArpHeader__get_m_macSource, /* C function to get the attribute */
        (setter) _wrap_PyNs3ArpHeader__set_m_macSource, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "m_macDest", /* attribute name */
        (getter) _wrap_PyNs3ArpHeader__get_m_macDest, /* C function to get the attribute */
        (setter) _wrap_PyNs3ArpHeader__set_m_macDest, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "m_type", /* attribute name */
        (getter) _wrap_PyNs3ArpHeader__get_m_type, /* C function to get the attribute */
        (setter) _wrap_PyNs3ArpHeader__set_m_type, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "m_ipv4Source", /* attribute name */
        (getter) _wrap_PyNs3ArpHeader__get_m_ipv4Source, /* C function to get the attribute */
        (setter) _wrap_PyNs3ArpHeader__set_m_ipv4Source, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "m_ipv4Dest", /* attribute name */
        (getter) _wrap_PyNs3ArpHeader__get_m_ipv4Dest, /* C function to get the attribute */
        (setter) _wrap_PyNs3ArpHeader__set_m_ipv4Dest, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyNs3ArpHeader__tp_init__0(PyNs3ArpHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::ArpHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3ArpHeader__tp_init__1(PyNs3ArpHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3ArpHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3ArpHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::ArpHeader(*((PyNs3ArpHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3ArpHeader__tp_init(PyNs3ArpHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3ArpHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3ArpHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3ArpHeader_SetRequest(PyNs3ArpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *sourceHardwareAddress;
    ns3::Address sourceHardwareAddress2;
    PyNs3Ipv4Address *sourceProtocolAddress;
    PyObject *destinationHardwareAddress;
    ns3::Address destinationHardwareAddress2;
    PyNs3Ipv4Address *destinationProtocolAddress;
    const char *keywords[] = {"sourceHardwareAddress", "sourceProtocolAddress", "destinationHardwareAddress", "destinationProtocolAddress", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OO!OO!", (char **) keywords, &sourceHardwareAddress, &PyNs3Ipv4Address_Type, &sourceProtocolAddress, &destinationHardwareAddress, &PyNs3Ipv4Address_Type, &destinationProtocolAddress)) {
        return NULL;
    }
    if (PyObject_IsInstance(sourceHardwareAddress, (PyObject*) &PyNs3Address_Type)) {
        sourceHardwareAddress2 = *((PyNs3Address *) sourceHardwareAddress)->obj;
    } else if (PyObject_IsInstance(sourceHardwareAddress, (PyObject*) &PyNs3Ipv4Address_Type)) {
        sourceHardwareAddress2 = *((PyNs3Ipv4Address *) sourceHardwareAddress)->obj;
    } else if (PyObject_IsInstance(sourceHardwareAddress, (PyObject*) &PyNs3Ipv6Address_Type)) {
        sourceHardwareAddress2 = *((PyNs3Ipv6Address *) sourceHardwareAddress)->obj;
    } else if (PyObject_IsInstance(sourceHardwareAddress, (PyObject*) &PyNs3Mac48Address_Type)) {
        sourceHardwareAddress2 = *((PyNs3Mac48Address *) sourceHardwareAddress)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", sourceHardwareAddress->ob_type->tp_name);
        return NULL;
    }
    if (PyObject_IsInstance(destinationHardwareAddress, (PyObject*) &PyNs3Address_Type)) {
        destinationHardwareAddress2 = *((PyNs3Address *) destinationHardwareAddress)->obj;
    } else if (PyObject_IsInstance(destinationHardwareAddress, (PyObject*) &PyNs3Ipv4Address_Type)) {
        destinationHardwareAddress2 = *((PyNs3Ipv4Address *) destinationHardwareAddress)->obj;
    } else if (PyObject_IsInstance(destinationHardwareAddress, (PyObject*) &PyNs3Ipv6Address_Type)) {
        destinationHardwareAddress2 = *((PyNs3Ipv6Address *) destinationHardwareAddress)->obj;
    } else if (PyObject_IsInstance(destinationHardwareAddress, (PyObject*) &PyNs3Mac48Address_Type)) {
        destinationHardwareAddress2 = *((PyNs3Mac48Address *) destinationHardwareAddress)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", destinationHardwareAddress->ob_type->tp_name);
        return NULL;
    }
    self->obj->SetRequest(sourceHardwareAddress2, *((PyNs3Ipv4Address *) sourceProtocolAddress)->obj, destinationHardwareAddress2, *((PyNs3Ipv4Address *) destinationProtocolAddress)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpHeader_Deserialize(PyNs3ArpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpHeader_GetDestinationHardwareAddress(PyNs3ArpHeader *self)
{
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    ns3::Address retval = self->obj->GetDestinationHardwareAddress();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpHeader_GetSourceIpv4Address(PyNs3ArpHeader *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetSourceIpv4Address();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpHeader_Serialize(PyNs3ArpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpHeader_IsRequest(PyNs3ArpHeader *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsRequest();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpHeader_IsReply(PyNs3ArpHeader *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsReply();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpHeader_SetReply(PyNs3ArpHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *sourceHardwareAddress;
    ns3::Address sourceHardwareAddress2;
    PyNs3Ipv4Address *sourceProtocolAddress;
    PyObject *destinationHardwareAddress;
    ns3::Address destinationHardwareAddress2;
    PyNs3Ipv4Address *destinationProtocolAddress;
    const char *keywords[] = {"sourceHardwareAddress", "sourceProtocolAddress", "destinationHardwareAddress", "destinationProtocolAddress", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "OO!OO!", (char **) keywords, &sourceHardwareAddress, &PyNs3Ipv4Address_Type, &sourceProtocolAddress, &destinationHardwareAddress, &PyNs3Ipv4Address_Type, &destinationProtocolAddress)) {
        return NULL;
    }
    if (PyObject_IsInstance(sourceHardwareAddress, (PyObject*) &PyNs3Address_Type)) {
        sourceHardwareAddress2 = *((PyNs3Address *) sourceHardwareAddress)->obj;
    } else if (PyObject_IsInstance(sourceHardwareAddress, (PyObject*) &PyNs3Ipv4Address_Type)) {
        sourceHardwareAddress2 = *((PyNs3Ipv4Address *) sourceHardwareAddress)->obj;
    } else if (PyObject_IsInstance(sourceHardwareAddress, (PyObject*) &PyNs3Ipv6Address_Type)) {
        sourceHardwareAddress2 = *((PyNs3Ipv6Address *) sourceHardwareAddress)->obj;
    } else if (PyObject_IsInstance(sourceHardwareAddress, (PyObject*) &PyNs3Mac48Address_Type)) {
        sourceHardwareAddress2 = *((PyNs3Mac48Address *) sourceHardwareAddress)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", sourceHardwareAddress->ob_type->tp_name);
        return NULL;
    }
    if (PyObject_IsInstance(destinationHardwareAddress, (PyObject*) &PyNs3Address_Type)) {
        destinationHardwareAddress2 = *((PyNs3Address *) destinationHardwareAddress)->obj;
    } else if (PyObject_IsInstance(destinationHardwareAddress, (PyObject*) &PyNs3Ipv4Address_Type)) {
        destinationHardwareAddress2 = *((PyNs3Ipv4Address *) destinationHardwareAddress)->obj;
    } else if (PyObject_IsInstance(destinationHardwareAddress, (PyObject*) &PyNs3Ipv6Address_Type)) {
        destinationHardwareAddress2 = *((PyNs3Ipv6Address *) destinationHardwareAddress)->obj;
    } else if (PyObject_IsInstance(destinationHardwareAddress, (PyObject*) &PyNs3Mac48Address_Type)) {
        destinationHardwareAddress2 = *((PyNs3Mac48Address *) destinationHardwareAddress)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", destinationHardwareAddress->ob_type->tp_name);
        return NULL;
    }
    self->obj->SetReply(sourceHardwareAddress2, *((PyNs3Ipv4Address *) sourceProtocolAddress)->obj, destinationHardwareAddress2, *((PyNs3Ipv4Address *) destinationProtocolAddress)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpHeader_GetDestinationIpv4Address(PyNs3ArpHeader *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetDestinationIpv4Address();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpHeader_GetInstanceTypeId(PyNs3ArpHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpHeader_GetSerializedSize(PyNs3ArpHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpHeader_GetSourceHardwareAddress(PyNs3ArpHeader *self)
{
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    ns3::Address retval = self->obj->GetSourceHardwareAddress();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::ArpHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


static PyObject*
_wrap_PyNs3ArpHeader__copy__(PyNs3ArpHeader *self)
{

    PyNs3ArpHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3ArpHeader, &PyNs3ArpHeader_Type);
    py_copy->obj = new ns3::ArpHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3ArpHeader_methods[] = {
    {(char *) "SetRequest", (PyCFunction) _wrap_PyNs3ArpHeader_SetRequest, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3ArpHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDestinationHardwareAddress", (PyCFunction) _wrap_PyNs3ArpHeader_GetDestinationHardwareAddress, METH_NOARGS, NULL },
    {(char *) "GetSourceIpv4Address", (PyCFunction) _wrap_PyNs3ArpHeader_GetSourceIpv4Address, METH_NOARGS, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3ArpHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsRequest", (PyCFunction) _wrap_PyNs3ArpHeader_IsRequest, METH_NOARGS, NULL },
    {(char *) "IsReply", (PyCFunction) _wrap_PyNs3ArpHeader_IsReply, METH_NOARGS, NULL },
    {(char *) "SetReply", (PyCFunction) _wrap_PyNs3ArpHeader_SetReply, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDestinationIpv4Address", (PyCFunction) _wrap_PyNs3ArpHeader_GetDestinationIpv4Address, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3ArpHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3ArpHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetSourceHardwareAddress", (PyCFunction) _wrap_PyNs3ArpHeader_GetSourceHardwareAddress, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3ArpHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3ArpHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3ArpHeader__tp_clear(PyNs3ArpHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::ArpHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3ArpHeader__tp_traverse(PyNs3ArpHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3ArpHeader__tp_dealloc(PyNs3ArpHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3ArpHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3ArpHeader__tp_richcompare (PyNs3ArpHeader *PYBINDGEN_UNUSED(self), PyNs3ArpHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3ArpHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3ArpHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.ArpHeader",            /* tp_name */
    sizeof(PyNs3ArpHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3ArpHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3ArpHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3ArpHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3ArpHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3ArpHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    PyNs3ArpHeader__getsets,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3ArpHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3ArpHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3ArpL3Protocol__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3ArpL3Protocol *self)
{
    PyObject *py_retval;
    PyNs3ArpL3Protocol__PythonHelper *helper = dynamic_cast< PyNs3ArpL3Protocol__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3ArpL3Protocol__PythonHelper::_wrap_NotifyNewAggregate(PyNs3ArpL3Protocol *self)
{
    PyObject *py_retval;
    PyNs3ArpL3Protocol__PythonHelper *helper = dynamic_cast< PyNs3ArpL3Protocol__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class ArpL3Protocol is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3ArpL3Protocol__PythonHelper::_wrap_DoStart(PyNs3ArpL3Protocol *self)
{
    PyObject *py_retval;
    PyNs3ArpL3Protocol__PythonHelper *helper = dynamic_cast< PyNs3ArpL3Protocol__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3ArpL3Protocol__PythonHelper::_wrap_DoDispose(PyNs3ArpL3Protocol *self)
{
    PyObject *py_retval;
    PyNs3ArpL3Protocol__PythonHelper *helper = dynamic_cast< PyNs3ArpL3Protocol__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class ArpL3Protocol is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

void
PyNs3ArpL3Protocol__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ArpL3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ArpL3Protocol::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ArpL3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ArpL3Protocol* >(m_pyself)->obj = (ns3::ArpL3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ArpL3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ArpL3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ArpL3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3ArpL3Protocol__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ArpL3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ArpL3Protocol::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ArpL3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ArpL3Protocol* >(m_pyself)->obj = (ns3::ArpL3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ArpL3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ArpL3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ArpL3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3ArpL3Protocol__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3ArpL3Protocol__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3ArpL3Protocol__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}
static PyObject* _wrap_PyNs3ArpL3Protocol__get_PROT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", ns3::ArpL3Protocol::PROT_NUMBER);
    return py_retval;
}
static PyGetSetDef Ns3ArpL3ProtocolMeta__getsets[] = {
    {
        (char*) "PROT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3ArpL3Protocol__get_PROT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3ArpL3ProtocolMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3ArpL3ProtocolMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3ArpL3ProtocolMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};


static int
_wrap_PyNs3ArpL3Protocol__tp_init(PyNs3ArpL3Protocol *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    if (self->ob_type != &PyNs3ArpL3Protocol_Type)
    {
        self->obj = new PyNs3ArpL3Protocol__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3ArpL3Protocol__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::ArpL3Protocol();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}


PyObject *
_wrap_PyNs3ArpL3Protocol_Receive(PyNs3ArpL3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    int protocol;
    PyObject *from;
    ns3::Address from2;
    PyObject *to;
    ns3::Address to2;
    ns3::NetDevice::PacketType packetType;
    const char *keywords[] = {"device", "p", "protocol", "from", "to", "packetType", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!iOOi", (char **) keywords, &PyNs3NetDevice_Type, &device, &PyNs3Packet_Type, &p, &protocol, &from, &to, &packetType)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    p_ptr = (p ? p->obj : NULL);
    if (protocol > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (PyObject_IsInstance(from, (PyObject*) &PyNs3Address_Type)) {
        from2 = *((PyNs3Address *) from)->obj;
    } else if (PyObject_IsInstance(from, (PyObject*) &PyNs3Ipv4Address_Type)) {
        from2 = *((PyNs3Ipv4Address *) from)->obj;
    } else if (PyObject_IsInstance(from, (PyObject*) &PyNs3Ipv6Address_Type)) {
        from2 = *((PyNs3Ipv6Address *) from)->obj;
    } else if (PyObject_IsInstance(from, (PyObject*) &PyNs3Mac48Address_Type)) {
        from2 = *((PyNs3Mac48Address *) from)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", from->ob_type->tp_name);
        return NULL;
    }
    if (PyObject_IsInstance(to, (PyObject*) &PyNs3Address_Type)) {
        to2 = *((PyNs3Address *) to)->obj;
    } else if (PyObject_IsInstance(to, (PyObject*) &PyNs3Ipv4Address_Type)) {
        to2 = *((PyNs3Ipv4Address *) to)->obj;
    } else if (PyObject_IsInstance(to, (PyObject*) &PyNs3Ipv6Address_Type)) {
        to2 = *((PyNs3Ipv6Address *) to)->obj;
    } else if (PyObject_IsInstance(to, (PyObject*) &PyNs3Mac48Address_Type)) {
        to2 = *((PyNs3Mac48Address *) to)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", to->ob_type->tp_name);
        return NULL;
    }
    self->obj->Receive(ns3::Ptr< ns3::NetDevice  > (device_ptr), ns3::Ptr< ns3::Packet  > (p_ptr), protocol, from2, to2, packetType);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpL3Protocol_CreateCache(PyNs3ArpL3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::ArpCache > retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Ipv4Interface *interface;
    ns3::Ipv4Interface *interface_ptr;
    const char *keywords[] = {"device", "interface", NULL};
    PyNs3ArpCache *py_ArpCache;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3NetDevice_Type, &device, &PyNs3Ipv4Interface_Type, &interface)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    interface_ptr = (interface ? interface->obj : NULL);
    retval = self->obj->CreateCache(ns3::Ptr< ns3::NetDevice  > (device_ptr), ns3::Ptr< ns3::Ipv4Interface  > (interface_ptr));
    if (!(const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3ArpCache__PythonHelper).name())
    {
        py_ArpCache = reinterpret_cast< PyNs3ArpCache* >(reinterpret_cast< PyNs3ArpCache__PythonHelper* >(const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval)))->m_pyself);
        py_ArpCache->obj = const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval));
        Py_INCREF(py_ArpCache);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_ArpCache = NULL;
        } else {
            py_ArpCache = (PyNs3ArpCache *) wrapper_lookup_iter->second;
            Py_INCREF(py_ArpCache);
        }
    
        if (py_ArpCache == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval)))), &PyNs3ArpCache_Type);
            py_ArpCache = PyObject_GC_New(PyNs3ArpCache, wrapper_type);
            py_ArpCache->inst_dict = NULL;
            py_ArpCache->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval))->Ref();
            py_ArpCache->obj = const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_ArpCache->obj] = (PyObject *) py_ArpCache;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_ArpCache);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpL3Protocol_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::ArpL3Protocol::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3ArpL3Protocol_SetNode(PyNs3ArpL3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3ArpL3Protocol_methods[] = {
    {(char *) "Receive", (PyCFunction) _wrap_PyNs3ArpL3Protocol_Receive, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "CreateCache", (PyCFunction) _wrap_PyNs3ArpL3Protocol_CreateCache, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3ArpL3Protocol_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3ArpL3Protocol_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3ArpL3Protocol__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3ArpL3Protocol__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3ArpL3Protocol__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "DoDispose", (PyCFunction) PyNs3ArpL3Protocol__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3ArpL3Protocol__tp_clear(PyNs3ArpL3Protocol *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::ArpL3Protocol *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3ArpL3Protocol__tp_traverse(PyNs3ArpL3Protocol *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3ArpL3Protocol__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3ArpL3Protocol__tp_dealloc(PyNs3ArpL3Protocol *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3ArpL3Protocol__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3ArpL3Protocol__tp_richcompare (PyNs3ArpL3Protocol *PYBINDGEN_UNUSED(self), PyNs3ArpL3Protocol *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3ArpL3Protocol_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3ArpL3Protocol_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.ArpL3Protocol",            /* tp_name */
    sizeof(PyNs3ArpL3Protocol),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3ArpL3Protocol__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3ArpL3Protocol__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3ArpL3Protocol__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3ArpL3Protocol__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3ArpL3Protocol_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3ArpL3Protocol, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3ArpL3Protocol__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyNs3GlobalRouter__tp_init(PyNs3GlobalRouter *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    self->obj = new ns3::GlobalRouter();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyNs3GlobalRouter_GetNumLSAs(PyNs3GlobalRouter *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNumLSAs();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouter_GetNInjectedRoutes(PyNs3GlobalRouter *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNInjectedRoutes();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouter_GetRoutingProtocol(PyNs3GlobalRouter *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4GlobalRouting > retval;
    PyNs3Ipv4GlobalRouting *py_Ipv4GlobalRouting;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetRoutingProtocol();
    if (!(const_cast<ns3::Ipv4GlobalRouting *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4GlobalRouting *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv4GlobalRouting = NULL;
    } else {
        py_Ipv4GlobalRouting = (PyNs3Ipv4GlobalRouting *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4GlobalRouting);
    }
    
    if (py_Ipv4GlobalRouting == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4GlobalRouting *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4GlobalRouting_Type);
        py_Ipv4GlobalRouting = PyObject_GC_New(PyNs3Ipv4GlobalRouting, wrapper_type);
        py_Ipv4GlobalRouting->inst_dict = NULL;
        py_Ipv4GlobalRouting->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4GlobalRouting *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4GlobalRouting->obj = const_cast<ns3::Ipv4GlobalRouting *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4GlobalRouting->obj] = (PyObject *) py_Ipv4GlobalRouting;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4GlobalRouting);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouter_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::GlobalRouter::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouter_GetRouterId(PyNs3GlobalRouter *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetRouterId();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouter_DiscoverLSAs(PyNs3GlobalRouter *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->DiscoverLSAs();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouter_GetInjectedRoute(PyNs3GlobalRouter *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ipv4RoutingTableEntry *retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    PyNs3Ipv4RoutingTableEntry *py_Ipv4RoutingTableEntry;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = self->obj->GetInjectedRoute(i);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Ipv4RoutingTableEntry_wrapper_registry.find((void *) retval);
    if (wrapper_lookup_iter == PyNs3Ipv4RoutingTableEntry_wrapper_registry.end()) {
        py_Ipv4RoutingTableEntry = NULL;
    } else {
        py_Ipv4RoutingTableEntry = (PyNs3Ipv4RoutingTableEntry *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4RoutingTableEntry);
    }
    
    if (py_Ipv4RoutingTableEntry == NULL) {
        py_Ipv4RoutingTableEntry = PyObject_New(PyNs3Ipv4RoutingTableEntry, &PyNs3Ipv4RoutingTableEntry_Type);
        py_Ipv4RoutingTableEntry->obj = new ns3::Ipv4RoutingTableEntry((*retval));
        py_Ipv4RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        PyNs3Ipv4RoutingTableEntry_wrapper_registry[(void *) py_Ipv4RoutingTableEntry->obj] = (PyObject *) py_Ipv4RoutingTableEntry;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingTableEntry);
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouter_InjectRoute(PyNs3GlobalRouter *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *network;
    PyNs3Ipv4Mask *networkMask;
    const char *keywords[] = {"network", "networkMask", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv4Address_Type, &network, &PyNs3Ipv4Mask_Type, &networkMask)) {
        return NULL;
    }
    self->obj->InjectRoute(*((PyNs3Ipv4Address *) network)->obj, *((PyNs3Ipv4Mask *) networkMask)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouter_SetRoutingProtocol(PyNs3GlobalRouter *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4GlobalRouting *routing;
    ns3::Ipv4GlobalRouting *routing_ptr;
    const char *keywords[] = {"routing", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4GlobalRouting_Type, &routing)) {
        return NULL;
    }
    routing_ptr = (routing ? routing->obj : NULL);
    self->obj->SetRoutingProtocol(ns3::Ptr< ns3::Ipv4GlobalRouting  > (routing_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouter_RemoveInjectedRoute(PyNs3GlobalRouter *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    self->obj->RemoveInjectedRoute(i);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouter_WithdrawRoute(PyNs3GlobalRouter *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv4Address *network;
    PyNs3Ipv4Mask *networkMask;
    const char *keywords[] = {"network", "networkMask", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv4Address_Type, &network, &PyNs3Ipv4Mask_Type, &networkMask)) {
        return NULL;
    }
    retval = self->obj->WithdrawRoute(*((PyNs3Ipv4Address *) network)->obj, *((PyNs3Ipv4Mask *) networkMask)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3GlobalRouter_GetLSA(PyNs3GlobalRouter *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int n;
    PyNs3GlobalRoutingLSA *lsa;
    const char *keywords[] = {"n", "lsa", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &n, &PyNs3GlobalRoutingLSA_Type, &lsa)) {
        return NULL;
    }
    retval = self->obj->GetLSA(n, *((PyNs3GlobalRoutingLSA *) lsa)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

static PyMethodDef PyNs3GlobalRouter_methods[] = {
    {(char *) "GetNumLSAs", (PyCFunction) _wrap_PyNs3GlobalRouter_GetNumLSAs, METH_NOARGS, NULL },
    {(char *) "GetNInjectedRoutes", (PyCFunction) _wrap_PyNs3GlobalRouter_GetNInjectedRoutes, METH_NOARGS, NULL },
    {(char *) "GetRoutingProtocol", (PyCFunction) _wrap_PyNs3GlobalRouter_GetRoutingProtocol, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3GlobalRouter_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetRouterId", (PyCFunction) _wrap_PyNs3GlobalRouter_GetRouterId, METH_NOARGS, NULL },
    {(char *) "DiscoverLSAs", (PyCFunction) _wrap_PyNs3GlobalRouter_DiscoverLSAs, METH_NOARGS, NULL },
    {(char *) "GetInjectedRoute", (PyCFunction) _wrap_PyNs3GlobalRouter_GetInjectedRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "InjectRoute", (PyCFunction) _wrap_PyNs3GlobalRouter_InjectRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRoutingProtocol", (PyCFunction) _wrap_PyNs3GlobalRouter_SetRoutingProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RemoveInjectedRoute", (PyCFunction) _wrap_PyNs3GlobalRouter_RemoveInjectedRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "WithdrawRoute", (PyCFunction) _wrap_PyNs3GlobalRouter_WithdrawRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLSA", (PyCFunction) _wrap_PyNs3GlobalRouter_GetLSA, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3GlobalRouter__tp_dealloc(PyNs3GlobalRouter *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::GlobalRouter *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3GlobalRouter__tp_richcompare (PyNs3GlobalRouter *PYBINDGEN_UNUSED(self), PyNs3GlobalRouter *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3GlobalRouter_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3GlobalRouter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.GlobalRouter",            /* tp_name */
    sizeof(PyNs3GlobalRouter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3GlobalRouter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3GlobalRouter__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3GlobalRouter_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3GlobalRouter__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6DestinationUnreachable__tp_init__0(PyNs3Icmpv6DestinationUnreachable *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6DestinationUnreachable *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6DestinationUnreachable_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6DestinationUnreachable(*((PyNs3Icmpv6DestinationUnreachable *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6DestinationUnreachable__tp_init__1(PyNs3Icmpv6DestinationUnreachable *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6DestinationUnreachable();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6DestinationUnreachable__tp_init(PyNs3Icmpv6DestinationUnreachable *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6DestinationUnreachable__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6DestinationUnreachable__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6DestinationUnreachable_SetPacket(PyNs3Icmpv6DestinationUnreachable *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &p)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    self->obj->SetPacket(ns3::Ptr< ns3::Packet  > (p_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6DestinationUnreachable_Deserialize(PyNs3Icmpv6DestinationUnreachable *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6DestinationUnreachable_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6DestinationUnreachable::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6DestinationUnreachable_Serialize(PyNs3Icmpv6DestinationUnreachable *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6DestinationUnreachable_GetPacket(PyNs3Icmpv6DestinationUnreachable *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetPacket();
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (retval))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6DestinationUnreachable_GetInstanceTypeId(PyNs3Icmpv6DestinationUnreachable *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6DestinationUnreachable_GetSerializedSize(PyNs3Icmpv6DestinationUnreachable *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6DestinationUnreachable__copy__(PyNs3Icmpv6DestinationUnreachable *self)
{

    PyNs3Icmpv6DestinationUnreachable *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6DestinationUnreachable, &PyNs3Icmpv6DestinationUnreachable_Type);
    py_copy->obj = new ns3::Icmpv6DestinationUnreachable(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6DestinationUnreachable_methods[] = {
    {(char *) "SetPacket", (PyCFunction) _wrap_PyNs3Icmpv6DestinationUnreachable_SetPacket, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6DestinationUnreachable_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6DestinationUnreachable_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6DestinationUnreachable_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetPacket", (PyCFunction) _wrap_PyNs3Icmpv6DestinationUnreachable_GetPacket, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6DestinationUnreachable_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6DestinationUnreachable_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6DestinationUnreachable__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6DestinationUnreachable__tp_clear(PyNs3Icmpv6DestinationUnreachable *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6DestinationUnreachable *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6DestinationUnreachable__tp_traverse(PyNs3Icmpv6DestinationUnreachable *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6DestinationUnreachable__tp_dealloc(PyNs3Icmpv6DestinationUnreachable *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6DestinationUnreachable__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6DestinationUnreachable__tp_richcompare (PyNs3Icmpv6DestinationUnreachable *PYBINDGEN_UNUSED(self), PyNs3Icmpv6DestinationUnreachable *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6DestinationUnreachable_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6DestinationUnreachable_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6DestinationUnreachable",            /* tp_name */
    sizeof(PyNs3Icmpv6DestinationUnreachable),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6DestinationUnreachable__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6DestinationUnreachable__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6DestinationUnreachable__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6DestinationUnreachable__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6DestinationUnreachable_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6DestinationUnreachable, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6DestinationUnreachable__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Icmpv6Echo__tp_init__0(PyNs3Icmpv6Echo *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6Echo *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6Echo_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6Echo(*((PyNs3Icmpv6Echo *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6Echo__tp_init__1(PyNs3Icmpv6Echo *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6Echo();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6Echo__tp_init__2(PyNs3Icmpv6Echo *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    bool request;
    PyObject *py_request;
    const char *keywords[] = {"request", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_request)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    request = (bool) PyObject_IsTrue(py_request);
    self->obj = new ns3::Icmpv6Echo(request);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6Echo__tp_init(PyNs3Icmpv6Echo *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Icmpv6Echo__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6Echo__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6Echo__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6Echo_SetSeq(PyNs3Icmpv6Echo *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int seq;
    const char *keywords[] = {"seq", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &seq)) {
        return NULL;
    }
    if (seq > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetSeq(seq);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Echo_Deserialize(PyNs3Icmpv6Echo *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Echo_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6Echo::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Echo_Serialize(PyNs3Icmpv6Echo *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Echo_GetId(PyNs3Icmpv6Echo *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetId();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Echo_GetInstanceTypeId(PyNs3Icmpv6Echo *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Echo_GetSerializedSize(PyNs3Icmpv6Echo *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Echo_SetId(PyNs3Icmpv6Echo *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int id;
    const char *keywords[] = {"id", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &id)) {
        return NULL;
    }
    if (id > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetId(id);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6Echo_GetSeq(PyNs3Icmpv6Echo *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetSeq();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6Echo__copy__(PyNs3Icmpv6Echo *self)
{

    PyNs3Icmpv6Echo *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6Echo, &PyNs3Icmpv6Echo_Type);
    py_copy->obj = new ns3::Icmpv6Echo(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6Echo_methods[] = {
    {(char *) "SetSeq", (PyCFunction) _wrap_PyNs3Icmpv6Echo_SetSeq, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Icmpv6Echo_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6Echo_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Icmpv6Echo_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetId", (PyCFunction) _wrap_PyNs3Icmpv6Echo_GetId, METH_NOARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Icmpv6Echo_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Icmpv6Echo_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetId", (PyCFunction) _wrap_PyNs3Icmpv6Echo_SetId, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSeq", (PyCFunction) _wrap_PyNs3Icmpv6Echo_GetSeq, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6Echo__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6Echo__tp_clear(PyNs3Icmpv6Echo *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Icmpv6Echo *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Icmpv6Echo__tp_traverse(PyNs3Icmpv6Echo *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6Echo__tp_dealloc(PyNs3Icmpv6Echo *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6Echo__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6Echo__tp_richcompare (PyNs3Icmpv6Echo *PYBINDGEN_UNUSED(self), PyNs3Icmpv6Echo *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6Echo_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6Echo_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6Echo",            /* tp_name */
    sizeof(PyNs3Icmpv6Echo),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6Echo__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6Echo__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6Echo__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6Echo__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6Echo_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6Echo, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6Echo__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyNs3IpL4Protocol__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'IpL4Protocol' cannot be constructed (have pure virtual methods but no helper class)");
    return -1;
}



PyObject *
_wrap_PyNs3IpL4Protocol_Receive__0(PyNs3IpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    ns3::IpL4Protocol::RxStatus retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv4Header *header;
    PyNs3Ipv4Interface *incomingInterface;
    ns3::Ipv4Interface *incomingInterface_ptr;
    const char *keywords[] = {"p", "header", "incomingInterface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv4Header_Type, &header, &PyNs3Ipv4Interface_Type, &incomingInterface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    incomingInterface_ptr = (incomingInterface ? incomingInterface->obj : NULL);
    retval = self->obj->Receive(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv4Header *) header)->obj, ns3::Ptr< ns3::Ipv4Interface  > (incomingInterface_ptr));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
_wrap_PyNs3IpL4Protocol_Receive__1(PyNs3IpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    ns3::IpL4Protocol::RxStatus retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Interface *incomingInterface;
    ns3::Ipv6Interface *incomingInterface_ptr;
    const char *keywords[] = {"p", "src", "dst", "incomingInterface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Interface_Type, &incomingInterface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    incomingInterface_ptr = (incomingInterface ? incomingInterface->obj : NULL);
    retval = self->obj->Receive(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, ns3::Ptr< ns3::Ipv6Interface  > (incomingInterface_ptr));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject * _wrap_PyNs3IpL4Protocol_Receive(PyNs3IpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3IpL4Protocol_Receive__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3IpL4Protocol_Receive__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3IpL4Protocol_SetDownTarget(PyNs3IpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl8> cb_cb_impl;
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl8> (cb);
    self->obj->SetDownTarget(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::Ipv4Address, ns3::Ipv4Address, unsigned char, ns3::Ptr<ns3::Ipv4Route>, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3IpL4Protocol_GetProtocolNumber(PyNs3IpL4Protocol *self)
{
    PyObject *py_retval;
    int retval;
    
    retval = self->obj->GetProtocolNumber();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3IpL4Protocol_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::IpL4Protocol::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3IpL4Protocol_SetDownTarget6(PyNs3IpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl7> cb_cb_impl;
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl7> (cb);
    self->obj->SetDownTarget6(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::Ipv6Address, ns3::Ipv6Address, unsigned char, ns3::Ptr<ns3::Ipv6Route>, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3IpL4Protocol_methods[] = {
    {(char *) "Receive", (PyCFunction) _wrap_PyNs3IpL4Protocol_Receive, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDownTarget", (PyCFunction) _wrap_PyNs3IpL4Protocol_SetDownTarget, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetProtocolNumber", (PyCFunction) _wrap_PyNs3IpL4Protocol_GetProtocolNumber, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3IpL4Protocol_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "SetDownTarget6", (PyCFunction) _wrap_PyNs3IpL4Protocol_SetDownTarget6, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3IpL4Protocol__tp_clear(PyNs3IpL4Protocol *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::IpL4Protocol *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3IpL4Protocol__tp_traverse(PyNs3IpL4Protocol *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3IpL4Protocol__tp_dealloc(PyNs3IpL4Protocol *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3IpL4Protocol__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3IpL4Protocol__tp_richcompare (PyNs3IpL4Protocol *PYBINDGEN_UNUSED(self), PyNs3IpL4Protocol *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3IpL4Protocol_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3IpL4Protocol_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.IpL4Protocol",            /* tp_name */
    sizeof(PyNs3IpL4Protocol),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3IpL4Protocol__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3IpL4Protocol__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3IpL4Protocol__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3IpL4Protocol__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3IpL4Protocol_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3IpL4Protocol, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3IpL4Protocol__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3Ipv4__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3Ipv4 *self)
{
    PyObject *py_retval;
    PyNs3Ipv4__PythonHelper *helper = dynamic_cast< PyNs3Ipv4__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv4__PythonHelper::_wrap_NotifyNewAggregate(PyNs3Ipv4 *self)
{
    PyObject *py_retval;
    PyNs3Ipv4__PythonHelper *helper = dynamic_cast< PyNs3Ipv4__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv4__PythonHelper::_wrap_DoStart(PyNs3Ipv4 *self)
{
    PyObject *py_retval;
    PyNs3Ipv4__PythonHelper *helper = dynamic_cast< PyNs3Ipv4__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv4__PythonHelper::_wrap_DoDispose(PyNs3Ipv4 *self)
{
    PyObject *py_retval;
    PyNs3Ipv4__PythonHelper *helper = dynamic_cast< PyNs3Ipv4__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

bool
PyNs3Ipv4__PythonHelper::AddAddress(uint32_t interface, ns3::Ipv4InterfaceAddress address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv4InterfaceAddress *py_Ipv4InterfaceAddress;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "AddAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    py_Ipv4InterfaceAddress = PyObject_New(PyNs3Ipv4InterfaceAddress, &PyNs3Ipv4InterfaceAddress_Type);
    py_Ipv4InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4InterfaceAddress->obj = new ns3::Ipv4InterfaceAddress(address);
    PyNs3Ipv4InterfaceAddress_wrapper_registry[(void *) py_Ipv4InterfaceAddress->obj] = (PyObject *) py_Ipv4InterfaceAddress;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "AddAddress", (char *) "NN", PyLong_FromUnsignedLong(interface), py_Ipv4InterfaceAddress);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv4__PythonHelper::AddInterface(ns3::Ptr< ns3::NetDevice > device)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "AddInterface"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "AddInterface", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Socket >
PyNs3Ipv4__PythonHelper::CreateRawSocket()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Socket > retval;
    PyNs3Socket *tmp_Socket;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "CreateRawSocket"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "CreateRawSocket", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Socket_Type, &tmp_Socket)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Socket  > (tmp_Socket->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4__PythonHelper::DeleteRawSocket(ns3::Ptr< ns3::Socket > socket)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    PyNs3Socket *py_Socket;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DeleteRawSocket"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    if (typeid(*(const_cast<ns3::Socket *> (ns3::PeekPointer (socket)))).name() == typeid(PyNs3Socket__PythonHelper).name())
    {
        py_Socket = (PyNs3Socket*) (((PyNs3Socket__PythonHelper*) const_cast<ns3::Socket *> (ns3::PeekPointer (socket)))->m_pyself);
        py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (socket));
        Py_INCREF(py_Socket);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Socket *> (ns3::PeekPointer (socket)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Socket = NULL;
        } else {
            py_Socket = (PyNs3Socket *) wrapper_lookup_iter->second;
            Py_INCREF(py_Socket);
        }
    
        if (py_Socket == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Socket *> (ns3::PeekPointer (socket))), &PyNs3Socket_Type);
            py_Socket = PyObject_GC_New(PyNs3Socket, wrapper_type);
            py_Socket->inst_dict = NULL;
            py_Socket->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Socket *> (ns3::PeekPointer (socket))->Ref();
            py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (socket));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Socket->obj] = (PyObject *) py_Socket;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DeleteRawSocket", (char *) "N", py_Socket);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::Ipv4InterfaceAddress
PyNs3Ipv4__PythonHelper::GetAddress(uint32_t interface, uint32_t addressIndex) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv4InterfaceAddress *tmp_Ipv4InterfaceAddress;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4InterfaceAddress();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetAddress", (char *) "NN", PyLong_FromUnsignedLong(interface), PyLong_FromUnsignedLong(addressIndex));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4InterfaceAddress();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv4InterfaceAddress_Type, &tmp_Ipv4InterfaceAddress)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4InterfaceAddress();
    }
    ns3::Ipv4InterfaceAddress retval = *tmp_Ipv4InterfaceAddress->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3Ipv4__PythonHelper::GetInterfaceForAddress(ns3::Ipv4Address address) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInterfaceForAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(address);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInterfaceForAddress", (char *) "N", py_Ipv4Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3Ipv4__PythonHelper::GetInterfaceForDevice(ns3::Ptr< ns3::NetDevice const > device) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInterfaceForDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInterfaceForDevice", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3Ipv4__PythonHelper::GetInterfaceForPrefix(ns3::Ipv4Address address, ns3::Ipv4Mask mask) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    PyNs3Ipv4Mask *py_Ipv4Mask;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInterfaceForPrefix"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(address);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_Ipv4Mask = PyObject_New(PyNs3Ipv4Mask, &PyNs3Ipv4Mask_Type);
    py_Ipv4Mask->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Mask->obj = new ns3::Ipv4Mask(mask);
    PyNs3Ipv4Mask_wrapper_registry[(void *) py_Ipv4Mask->obj] = (PyObject *) py_Ipv4Mask;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInterfaceForPrefix", (char *) "NN", py_Ipv4Address, py_Ipv4Mask);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint16_t
PyNs3Ipv4__PythonHelper::GetMetric(uint32_t interface) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    uint16_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetMetric"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetMetric", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    if (tmp > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint16_t
PyNs3Ipv4__PythonHelper::GetMtu(uint32_t interface) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    uint16_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetMtu"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetMtu", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    if (tmp > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv4__PythonHelper::GetNAddresses(uint32_t interface) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNAddresses"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNAddresses", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv4__PythonHelper::GetNInterfaces() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNInterfaces"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNInterfaces", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::NetDevice >
PyNs3Ipv4__PythonHelper::GetNetDevice(uint32_t interface)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *tmp_NetDevice;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNetDevice", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3NetDevice_Type, &tmp_NetDevice)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::NetDevice  > (tmp_NetDevice->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::IpL4Protocol >
PyNs3Ipv4__PythonHelper::GetProtocol(int protocolNumber) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::IpL4Protocol > retval;
    PyNs3IpL4Protocol *tmp_IpL4Protocol;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetProtocol"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetProtocol", (char *) "i", protocolNumber);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3IpL4Protocol_Type, &tmp_IpL4Protocol)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::IpL4Protocol  > (tmp_IpL4Protocol->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Ipv4RoutingProtocol >
PyNs3Ipv4__PythonHelper::GetRoutingProtocol() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4RoutingProtocol > retval;
    PyNs3Ipv4RoutingProtocol *tmp_Ipv4RoutingProtocol;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetRoutingProtocol"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetRoutingProtocol", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv4RoutingProtocol_Type, &tmp_Ipv4RoutingProtocol)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Ipv4RoutingProtocol  > (tmp_Ipv4RoutingProtocol->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4__PythonHelper::Insert(ns3::Ptr< ns3::IpL4Protocol > protocol)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    PyNs3IpL4Protocol *py_IpL4Protocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Insert"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (protocol)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_IpL4Protocol = NULL;
    } else {
        py_IpL4Protocol = (PyNs3IpL4Protocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_IpL4Protocol);
    }
    
    if (py_IpL4Protocol == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (protocol))), &PyNs3IpL4Protocol_Type);
        py_IpL4Protocol = PyObject_GC_New(PyNs3IpL4Protocol, wrapper_type);
        py_IpL4Protocol->inst_dict = NULL;
        py_IpL4Protocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (protocol))->Ref();
        py_IpL4Protocol->obj = const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (protocol));
        PyNs3ObjectBase_wrapper_registry[(void *) py_IpL4Protocol->obj] = (PyObject *) py_IpL4Protocol;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Insert", (char *) "N", py_IpL4Protocol);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3Ipv4__PythonHelper::IsDestinationAddress(ns3::Ipv4Address address, uint32_t iif) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsDestinationAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(address);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsDestinationAddress", (char *) "NN", py_Ipv4Address, PyLong_FromUnsignedLong(iif));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv4__PythonHelper::IsForwarding(uint32_t interface) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsForwarding"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsForwarding", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv4__PythonHelper::IsUp(uint32_t interface) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsUp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsUp", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv4__PythonHelper::RemoveAddress(uint32_t interface, uint32_t addressIndex)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "RemoveAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "RemoveAddress", (char *) "NN", PyLong_FromUnsignedLong(interface), PyLong_FromUnsignedLong(addressIndex));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ipv4Address
PyNs3Ipv4__PythonHelper::SelectSourceAddress(ns3::Ptr< ns3::NetDevice const > device, ns3::Ipv4Address dst, ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e scope)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Ipv4Address *py_Ipv4Address;
    PyNs3Ipv4Address *tmp_Ipv4Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SelectSourceAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4Address();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(dst);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SelectSourceAddress", (char *) "NNi", py_NetDevice, py_Ipv4Address, scope);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4Address();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv4Address_Type, &tmp_Ipv4Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4Address();
    }
    ns3::Ipv4Address retval = *tmp_Ipv4Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4__PythonHelper::Send(ns3::Ptr< ns3::Packet > packet, ns3::Ipv4Address source, ns3::Ipv4Address destination, uint8_t protocol, ns3::Ptr< ns3::Ipv4Route > route)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Ipv4Address *py_Ipv4Address;
    PyNs3Ipv4Address *py_Ipv4Address2;
    PyNs3Ipv4Route *py_Ipv4Route;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter2;
    PyTypeObject *wrapper_type2 = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Send"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (packet)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (packet))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (packet))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (packet));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(source);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_Ipv4Address2 = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address2->obj = new ns3::Ipv4Address(destination);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address2->obj] = (PyObject *) py_Ipv4Address2;
    wrapper_lookup_iter2 = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route)));
    if (wrapper_lookup_iter2 == PyNs3Empty_wrapper_registry.end()) {
        py_Ipv4Route = NULL;
    } else {
        py_Ipv4Route = (PyNs3Ipv4Route *) wrapper_lookup_iter2->second;
        Py_INCREF(py_Ipv4Route);
    }
    
    if (py_Ipv4Route == NULL)
    {
        wrapper_type2 = PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route))), &PyNs3Ipv4Route_Type);
        py_Ipv4Route = PyObject_New(PyNs3Ipv4Route, wrapper_type2);
        py_Ipv4Route->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route))->Ref();
        py_Ipv4Route->obj = const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route));
        PyNs3Empty_wrapper_registry[(void *) py_Ipv4Route->obj] = (PyObject *) py_Ipv4Route;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Send", (char *) "NNNiN", py_Packet, py_Ipv4Address, py_Ipv4Address2, (int) protocol, py_Ipv4Route);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4__PythonHelper::SendWithHeader(ns3::Ptr< ns3::Packet > packet, ns3::Ipv4Header ipHeader, ns3::Ptr< ns3::Ipv4Route > route)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Ipv4Header *py_Ipv4Header;
    PyNs3Ipv4Route *py_Ipv4Route;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter2;
    PyTypeObject *wrapper_type2 = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SendWithHeader"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (packet)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (packet))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (packet))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (packet));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Ipv4Header = PyObject_GC_New(PyNs3Ipv4Header, &PyNs3Ipv4Header_Type);
    py_Ipv4Header->inst_dict = NULL;
    py_Ipv4Header->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Header->obj = new ns3::Ipv4Header(ipHeader);
    PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4Header->obj] = (PyObject *) py_Ipv4Header;
    wrapper_lookup_iter2 = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route)));
    if (wrapper_lookup_iter2 == PyNs3Empty_wrapper_registry.end()) {
        py_Ipv4Route = NULL;
    } else {
        py_Ipv4Route = (PyNs3Ipv4Route *) wrapper_lookup_iter2->second;
        Py_INCREF(py_Ipv4Route);
    }
    
    if (py_Ipv4Route == NULL)
    {
        wrapper_type2 = PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route))), &PyNs3Ipv4Route_Type);
        py_Ipv4Route = PyObject_New(PyNs3Ipv4Route, wrapper_type2);
        py_Ipv4Route->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route))->Ref();
        py_Ipv4Route->obj = const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route));
        PyNs3Empty_wrapper_registry[(void *) py_Ipv4Route->obj] = (PyObject *) py_Ipv4Route;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SendWithHeader", (char *) "NNN", py_Packet, py_Ipv4Header, py_Ipv4Route);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4__PythonHelper::SetDown(uint32_t interface)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetDown"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetDown", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4__PythonHelper::SetForwarding(uint32_t interface, bool val)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetForwarding"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetForwarding", (char *) "NN", PyLong_FromUnsignedLong(interface), PyBool_FromLong(val));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4__PythonHelper::SetMetric(uint32_t interface, uint16_t metric)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetMetric"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetMetric", (char *) "Ni", PyLong_FromUnsignedLong(interface), (int) metric);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4__PythonHelper::SetRoutingProtocol(ns3::Ptr< ns3::Ipv4RoutingProtocol > routingProtocol)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv4RoutingProtocol *py_Ipv4RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetRoutingProtocol"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (routingProtocol)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv4RoutingProtocol = NULL;
    } else {
        py_Ipv4RoutingProtocol = (PyNs3Ipv4RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4RoutingProtocol);
    }
    
    if (py_Ipv4RoutingProtocol == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (routingProtocol))), &PyNs3Ipv4RoutingProtocol_Type);
        py_Ipv4RoutingProtocol = PyObject_GC_New(PyNs3Ipv4RoutingProtocol, wrapper_type);
        py_Ipv4RoutingProtocol->inst_dict = NULL;
        py_Ipv4RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (routingProtocol))->Ref();
        py_Ipv4RoutingProtocol->obj = const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (routingProtocol));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4RoutingProtocol->obj] = (PyObject *) py_Ipv4RoutingProtocol;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetRoutingProtocol", (char *) "N", py_Ipv4RoutingProtocol);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4__PythonHelper::SetUp(uint32_t interface)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetUp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetUp", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3Ipv4__PythonHelper::GetIpForward() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetIpForward"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetIpForward", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv4__PythonHelper::GetWeakEsModel() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetWeakEsModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = const_cast< ns3::Ipv4* >((const ns3::Ipv4*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetWeakEsModel", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4__PythonHelper::SetIpForward(bool forward)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetIpForward"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetIpForward", (char *) "N", PyBool_FromLong(forward));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4__PythonHelper::SetWeakEsModel(bool model)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetWeakEsModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = (ns3::Ipv4*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetWeakEsModel", (char *) "N", PyBool_FromLong(model));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3Ipv4__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}
static PyObject* _wrap_PyNs3Ipv4__get_IF_ANY(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(ns3::Ipv4::IF_ANY));
    return py_retval;
}
static PyGetSetDef Ns3Ipv4Meta__getsets[] = {
    {
        (char*) "IF_ANY", /* attribute name */
        (getter) _wrap_PyNs3Ipv4__get_IF_ANY, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv4Meta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv4Meta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv4Meta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Ipv4__tp_init__0(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4 *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv4_Type)
    {
        self->obj = new PyNs3Ipv4__PythonHelper(*((PyNs3Ipv4 *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv4__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'Ipv4' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3Ipv4__tp_init__1(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv4_Type)
    {
        self->obj = new PyNs3Ipv4__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv4__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'Ipv4' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3Ipv4__tp_init(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4_GetInterfaceForAddress(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv4Address *address;
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &address)) {
        return NULL;
    }
    retval = self->obj->GetInterfaceForAddress(*((PyNs3Ipv4Address *) address)->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_GetNInterfaces(PyNs3Ipv4 *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNInterfaces();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_SetMetric(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    int metric;
    const char *keywords[] = {"interface", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "Ii", (char **) keywords, &interface, &metric)) {
        return NULL;
    }
    if (metric > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetMetric(interface, metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_GetInterfaceForDevice(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    const char *keywords[] = {"device", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &device)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    retval = self->obj->GetInterfaceForDevice(ns3::Ptr< ns3::NetDevice  > (device_ptr));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv4::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_Send(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv4Address *source;
    PyNs3Ipv4Address *destination;
    int protocol;
    PyNs3Ipv4Route *route;
    ns3::Ipv4Route *route_ptr;
    const char *keywords[] = {"packet", "source", "destination", "protocol", "route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!iO!", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv4Address_Type, &source, &PyNs3Ipv4Address_Type, &destination, &protocol, &PyNs3Ipv4Route_Type, &route)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (protocol > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    route_ptr = (route ? route->obj : NULL);
    self->obj->Send(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv4Address *) source)->obj, *((PyNs3Ipv4Address *) destination)->obj, protocol, ns3::Ptr< ns3::Ipv4Route  > (route_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_DeleteRawSocket(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Socket *socket;
    ns3::Socket *socket_ptr;
    const char *keywords[] = {"socket", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Socket_Type, &socket)) {
        return NULL;
    }
    socket_ptr = (socket ? socket->obj : NULL);
    self->obj->DeleteRawSocket(ns3::Ptr< ns3::Socket  > (socket_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_SetDown(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->SetDown(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_AddInterface(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    const char *keywords[] = {"device", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &device)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    retval = self->obj->AddInterface(ns3::Ptr< ns3::NetDevice  > (device_ptr));
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_IsDestinationAddress(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv4Address *address;
    unsigned int iif;
    const char *keywords[] = {"address", "iif", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &address, &iif)) {
        return NULL;
    }
    retval = self->obj->IsDestinationAddress(*((PyNs3Ipv4Address *) address)->obj, iif);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_SetForwarding(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    bool val;
    PyObject *py_val;
    const char *keywords[] = {"interface", "val", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO", (char **) keywords, &interface, &py_val)) {
        return NULL;
    }
    val = (bool) PyObject_IsTrue(py_val);
    self->obj->SetForwarding(interface, val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_GetNAddresses(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = self->obj->GetNAddresses(interface);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_GetProtocol(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::IpL4Protocol > retval;
    int protocolNumber;
    const char *keywords[] = {"protocolNumber", NULL};
    PyNs3IpL4Protocol *py_IpL4Protocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &protocolNumber)) {
        return NULL;
    }
    retval = self->obj->GetProtocol(protocolNumber);
    if (!(const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_IpL4Protocol = NULL;
    } else {
        py_IpL4Protocol = (PyNs3IpL4Protocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_IpL4Protocol);
    }
    
    if (py_IpL4Protocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval)))), &PyNs3IpL4Protocol_Type);
        py_IpL4Protocol = PyObject_GC_New(PyNs3IpL4Protocol, wrapper_type);
        py_IpL4Protocol->inst_dict = NULL;
        py_IpL4Protocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval))->Ref();
        py_IpL4Protocol->obj = const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_IpL4Protocol->obj] = (PyObject *) py_IpL4Protocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_IpL4Protocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_GetMtu(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint16_t retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = self->obj->GetMtu(interface);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_SetRoutingProtocol(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4RoutingProtocol *routingProtocol;
    ns3::Ipv4RoutingProtocol *routingProtocol_ptr;
    const char *keywords[] = {"routingProtocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4RoutingProtocol_Type, &routingProtocol)) {
        return NULL;
    }
    routingProtocol_ptr = (routingProtocol ? routingProtocol->obj : NULL);
    self->obj->SetRoutingProtocol(ns3::Ptr< ns3::Ipv4RoutingProtocol  > (routingProtocol_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_SelectSourceAddress(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Ipv4Address *dst;
    ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e scope;
    const char *keywords[] = {"device", "dst", "scope", NULL};
    PyNs3Ipv4Address *py_Ipv4Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!i", (char **) keywords, &PyNs3NetDevice_Type, &device, &PyNs3Ipv4Address_Type, &dst, &scope)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    ns3::Ipv4Address retval = self->obj->SelectSourceAddress(ns3::Ptr< ns3::NetDevice  > (device_ptr), *((PyNs3Ipv4Address *) dst)->obj, scope);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_AddAddress(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int interface;
    PyNs3Ipv4InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv4InterfaceAddress_Type, &address)) {
        return NULL;
    }
    retval = self->obj->AddAddress(interface, *((PyNs3Ipv4InterfaceAddress *) address)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_IsForwarding(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = self->obj->IsForwarding(interface);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_GetAddress(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    unsigned int addressIndex;
    const char *keywords[] = {"interface", "addressIndex", NULL};
    PyNs3Ipv4InterfaceAddress *py_Ipv4InterfaceAddress;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &interface, &addressIndex)) {
        return NULL;
    }
    ns3::Ipv4InterfaceAddress retval = self->obj->GetAddress(interface, addressIndex);
    py_Ipv4InterfaceAddress = PyObject_New(PyNs3Ipv4InterfaceAddress, &PyNs3Ipv4InterfaceAddress_Type);
    py_Ipv4InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4InterfaceAddress->obj = new ns3::Ipv4InterfaceAddress(retval);
    PyNs3Ipv4InterfaceAddress_wrapper_registry[(void *) py_Ipv4InterfaceAddress->obj] = (PyObject *) py_Ipv4InterfaceAddress;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4InterfaceAddress);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_Insert(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3IpL4Protocol *protocol;
    ns3::IpL4Protocol *protocol_ptr;
    const char *keywords[] = {"protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3IpL4Protocol_Type, &protocol)) {
        return NULL;
    }
    protocol_ptr = (protocol ? protocol->obj : NULL);
    self->obj->Insert(ns3::Ptr< ns3::IpL4Protocol  > (protocol_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_GetInterfaceForPrefix(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv4Address *address;
    PyNs3Ipv4Mask *mask;
    const char *keywords[] = {"address", "mask", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv4Address_Type, &address, &PyNs3Ipv4Mask_Type, &mask)) {
        return NULL;
    }
    retval = self->obj->GetInterfaceForPrefix(*((PyNs3Ipv4Address *) address)->obj, *((PyNs3Ipv4Mask *) mask)->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_GetNetDevice(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = self->obj->GetNetDevice(interface);
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_GetRoutingProtocol(PyNs3Ipv4 *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4RoutingProtocol > retval;
    PyNs3Ipv4RoutingProtocol *py_Ipv4RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetRoutingProtocol();
    if (!(const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv4RoutingProtocol = NULL;
    } else {
        py_Ipv4RoutingProtocol = (PyNs3Ipv4RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4RoutingProtocol);
    }
    
    if (py_Ipv4RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4RoutingProtocol_Type);
        py_Ipv4RoutingProtocol = PyObject_GC_New(PyNs3Ipv4RoutingProtocol, wrapper_type);
        py_Ipv4RoutingProtocol->inst_dict = NULL;
        py_Ipv4RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4RoutingProtocol->obj = const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4RoutingProtocol->obj] = (PyObject *) py_Ipv4RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingProtocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_RemoveAddress(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int interface;
    unsigned int addressIndex;
    const char *keywords[] = {"interface", "addressIndex", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &interface, &addressIndex)) {
        return NULL;
    }
    retval = self->obj->RemoveAddress(interface, addressIndex);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_GetMetric(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint16_t retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = self->obj->GetMetric(interface);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_SetUp(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->SetUp(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_CreateRawSocket(PyNs3Ipv4 *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Socket > retval;
    PyNs3Socket *py_Socket;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->CreateRawSocket();
    if (!(const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Socket__PythonHelper).name())
    {
        py_Socket = reinterpret_cast< PyNs3Socket* >(reinterpret_cast< PyNs3Socket__PythonHelper* >(const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Socket);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Socket *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Socket = NULL;
        } else {
            py_Socket = (PyNs3Socket *) wrapper_lookup_iter->second;
            Py_INCREF(py_Socket);
        }
    
        if (py_Socket == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))), &PyNs3Socket_Type);
            py_Socket = PyObject_GC_New(PyNs3Socket, wrapper_type);
            py_Socket->inst_dict = NULL;
            py_Socket->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Socket *> (ns3::PeekPointer (retval))->Ref();
            py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Socket->obj] = (PyObject *) py_Socket;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Socket);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_SendWithHeader(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv4Header *ipHeader;
    PyNs3Ipv4Route *route;
    ns3::Ipv4Route *route_ptr;
    const char *keywords[] = {"packet", "ipHeader", "route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv4Header_Type, &ipHeader, &PyNs3Ipv4Route_Type, &route)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    route_ptr = (route ? route->obj : NULL);
    self->obj->SendWithHeader(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv4Header *) ipHeader)->obj, ns3::Ptr< ns3::Ipv4Route  > (route_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4_IsUp(PyNs3Ipv4 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = self->obj->IsUp(interface);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

static PyMethodDef PyNs3Ipv4_methods[] = {
    {(char *) "GetInterfaceForAddress", (PyCFunction) _wrap_PyNs3Ipv4_GetInterfaceForAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNInterfaces", (PyCFunction) _wrap_PyNs3Ipv4_GetNInterfaces, METH_NOARGS, NULL },
    {(char *) "SetMetric", (PyCFunction) _wrap_PyNs3Ipv4_SetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInterfaceForDevice", (PyCFunction) _wrap_PyNs3Ipv4_GetInterfaceForDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv4_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Send", (PyCFunction) _wrap_PyNs3Ipv4_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "DeleteRawSocket", (PyCFunction) _wrap_PyNs3Ipv4_DeleteRawSocket, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDown", (PyCFunction) _wrap_PyNs3Ipv4_SetDown, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddInterface", (PyCFunction) _wrap_PyNs3Ipv4_AddInterface, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsDestinationAddress", (PyCFunction) _wrap_PyNs3Ipv4_IsDestinationAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetForwarding", (PyCFunction) _wrap_PyNs3Ipv4_SetForwarding, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNAddresses", (PyCFunction) _wrap_PyNs3Ipv4_GetNAddresses, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetProtocol", (PyCFunction) _wrap_PyNs3Ipv4_GetProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMtu", (PyCFunction) _wrap_PyNs3Ipv4_GetMtu, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRoutingProtocol", (PyCFunction) _wrap_PyNs3Ipv4_SetRoutingProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SelectSourceAddress", (PyCFunction) _wrap_PyNs3Ipv4_SelectSourceAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddAddress", (PyCFunction) _wrap_PyNs3Ipv4_AddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsForwarding", (PyCFunction) _wrap_PyNs3Ipv4_IsForwarding, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv4_GetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Insert", (PyCFunction) _wrap_PyNs3Ipv4_Insert, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInterfaceForPrefix", (PyCFunction) _wrap_PyNs3Ipv4_GetInterfaceForPrefix, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNetDevice", (PyCFunction) _wrap_PyNs3Ipv4_GetNetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetRoutingProtocol", (PyCFunction) _wrap_PyNs3Ipv4_GetRoutingProtocol, METH_NOARGS, NULL },
    {(char *) "RemoveAddress", (PyCFunction) _wrap_PyNs3Ipv4_RemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMetric", (PyCFunction) _wrap_PyNs3Ipv4_GetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetUp", (PyCFunction) _wrap_PyNs3Ipv4_SetUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "CreateRawSocket", (PyCFunction) _wrap_PyNs3Ipv4_CreateRawSocket, METH_NOARGS, NULL },
    {(char *) "SendWithHeader", (PyCFunction) _wrap_PyNs3Ipv4_SendWithHeader, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsUp", (PyCFunction) _wrap_PyNs3Ipv4_IsUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3Ipv4__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3Ipv4__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3Ipv4__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "DoDispose", (PyCFunction) PyNs3Ipv4__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4__tp_clear(PyNs3Ipv4 *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv4 *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv4__tp_traverse(PyNs3Ipv4 *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3Ipv4__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3Ipv4__tp_dealloc(PyNs3Ipv4 *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4__tp_richcompare (PyNs3Ipv4 *PYBINDGEN_UNUSED(self), PyNs3Ipv4 *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4",            /* tp_name */
    sizeof(PyNs3Ipv4),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3Ipv4Interface__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Interface__PythonHelper *helper = dynamic_cast< PyNs3Ipv4Interface__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv4Interface__PythonHelper::_wrap_NotifyNewAggregate(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Interface__PythonHelper *helper = dynamic_cast< PyNs3Ipv4Interface__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv4Interface__PythonHelper::_wrap_DoStart(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Interface__PythonHelper *helper = dynamic_cast< PyNs3Ipv4Interface__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv4Interface__PythonHelper::_wrap_DoDispose(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Interface__PythonHelper *helper = dynamic_cast< PyNs3Ipv4Interface__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Ipv4Interface is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

void
PyNs3Ipv4Interface__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4Interface *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv4Interface::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4Interface* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4Interface* >(m_pyself)->obj = (ns3::Ipv4Interface*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4Interface* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4Interface* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4Interface* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3Ipv4Interface__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4Interface__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4Interface__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4Interface__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3Ipv4Interface__tp_init__0(PyNs3Ipv4Interface *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4Interface *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Interface_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv4Interface_Type)
    {
        self->obj = new PyNs3Ipv4Interface__PythonHelper(*((PyNs3Ipv4Interface *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv4Interface__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::Ipv4Interface(*((PyNs3Ipv4Interface *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3Ipv4Interface__tp_init__1(PyNs3Ipv4Interface *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv4Interface_Type)
    {
        self->obj = new PyNs3Ipv4Interface__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv4Interface__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::Ipv4Interface();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3Ipv4Interface__tp_init(PyNs3Ipv4Interface *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4Interface__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4Interface__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4Interface_AddAddress(PyNs3Ipv4Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv4InterfaceAddress *address;
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4InterfaceAddress_Type, &address)) {
        return NULL;
    }
    retval = self->obj->AddAddress(*((PyNs3Ipv4InterfaceAddress *) address)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_SetDown(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    
    self->obj->SetDown();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_GetArpCache(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::ArpCache > retval;
    PyNs3ArpCache *py_ArpCache;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetArpCache();
    if (!(const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3ArpCache__PythonHelper).name())
    {
        py_ArpCache = reinterpret_cast< PyNs3ArpCache* >(reinterpret_cast< PyNs3ArpCache__PythonHelper* >(const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval)))->m_pyself);
        py_ArpCache->obj = const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval));
        Py_INCREF(py_ArpCache);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_ArpCache = NULL;
        } else {
            py_ArpCache = (PyNs3ArpCache *) wrapper_lookup_iter->second;
            Py_INCREF(py_ArpCache);
        }
    
        if (py_ArpCache == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval)))), &PyNs3ArpCache_Type);
            py_ArpCache = PyObject_GC_New(PyNs3ArpCache, wrapper_type);
            py_ArpCache->inst_dict = NULL;
            py_ArpCache->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval))->Ref();
            py_ArpCache->obj = const_cast<ns3::ArpCache *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_ArpCache->obj] = (PyObject *) py_ArpCache;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_ArpCache);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_IsForwarding(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsForwarding();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_SetUp(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    
    self->obj->SetUp();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv4Interface::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_GetAddress(PyNs3Ipv4Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int index;
    const char *keywords[] = {"index", NULL};
    PyNs3Ipv4InterfaceAddress *py_Ipv4InterfaceAddress;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    ns3::Ipv4InterfaceAddress retval = self->obj->GetAddress(index);
    py_Ipv4InterfaceAddress = PyObject_New(PyNs3Ipv4InterfaceAddress, &PyNs3Ipv4InterfaceAddress_Type);
    py_Ipv4InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4InterfaceAddress->obj = new ns3::Ipv4InterfaceAddress(retval);
    PyNs3Ipv4InterfaceAddress_wrapper_registry[(void *) py_Ipv4InterfaceAddress->obj] = (PyObject *) py_Ipv4InterfaceAddress;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4InterfaceAddress);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_GetNAddresses(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNAddresses();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_GetMetric(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetMetric();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_IsUp(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsUp();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_Send(PyNs3Ipv4Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv4Address *dest;
    const char *keywords[] = {"p", "dest", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv4Address_Type, &dest)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    self->obj->Send(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv4Address *) dest)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_SetNode(PyNs3Ipv4Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_SetDevice(PyNs3Ipv4Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    const char *keywords[] = {"device", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &device)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    self->obj->SetDevice(ns3::Ptr< ns3::NetDevice  > (device_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_SetArpCache(PyNs3Ipv4Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3ArpCache *arg0;
    ns3::ArpCache *arg0_ptr;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3ArpCache_Type, &arg0)) {
        return NULL;
    }
    arg0_ptr = (arg0 ? arg0->obj : NULL);
    self->obj->SetArpCache(ns3::Ptr< ns3::ArpCache  > (arg0_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_IsDown(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsDown();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_GetDevice(PyNs3Ipv4Interface *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetDevice();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_SetForwarding(PyNs3Ipv4Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool val;
    PyObject *py_val;
    const char *keywords[] = {"val", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_val)) {
        return NULL;
    }
    val = (bool) PyObject_IsTrue(py_val);
    self->obj->SetForwarding(val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_SetMetric(PyNs3Ipv4Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int metric;
    const char *keywords[] = {"metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &metric)) {
        return NULL;
    }
    if (metric > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetMetric(metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Interface_RemoveAddress(PyNs3Ipv4Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int index;
    const char *keywords[] = {"index", NULL};
    PyNs3Ipv4InterfaceAddress *py_Ipv4InterfaceAddress;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    ns3::Ipv4InterfaceAddress retval = self->obj->RemoveAddress(index);
    py_Ipv4InterfaceAddress = PyObject_New(PyNs3Ipv4InterfaceAddress, &PyNs3Ipv4InterfaceAddress_Type);
    py_Ipv4InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4InterfaceAddress->obj = new ns3::Ipv4InterfaceAddress(retval);
    PyNs3Ipv4InterfaceAddress_wrapper_registry[(void *) py_Ipv4InterfaceAddress->obj] = (PyObject *) py_Ipv4InterfaceAddress;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4InterfaceAddress);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4Interface__copy__(PyNs3Ipv4Interface *self)
{

    PyNs3Ipv4Interface *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv4Interface, &PyNs3Ipv4Interface_Type);
    py_copy->obj = new ns3::Ipv4Interface(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4Interface_methods[] = {
    {(char *) "AddAddress", (PyCFunction) _wrap_PyNs3Ipv4Interface_AddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDown", (PyCFunction) _wrap_PyNs3Ipv4Interface_SetDown, METH_NOARGS, NULL },
    {(char *) "GetArpCache", (PyCFunction) _wrap_PyNs3Ipv4Interface_GetArpCache, METH_NOARGS, NULL },
    {(char *) "IsForwarding", (PyCFunction) _wrap_PyNs3Ipv4Interface_IsForwarding, METH_NOARGS, NULL },
    {(char *) "SetUp", (PyCFunction) _wrap_PyNs3Ipv4Interface_SetUp, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv4Interface_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv4Interface_GetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNAddresses", (PyCFunction) _wrap_PyNs3Ipv4Interface_GetNAddresses, METH_NOARGS, NULL },
    {(char *) "GetMetric", (PyCFunction) _wrap_PyNs3Ipv4Interface_GetMetric, METH_NOARGS, NULL },
    {(char *) "IsUp", (PyCFunction) _wrap_PyNs3Ipv4Interface_IsUp, METH_NOARGS, NULL },
    {(char *) "Send", (PyCFunction) _wrap_PyNs3Ipv4Interface_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3Ipv4Interface_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDevice", (PyCFunction) _wrap_PyNs3Ipv4Interface_SetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetArpCache", (PyCFunction) _wrap_PyNs3Ipv4Interface_SetArpCache, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsDown", (PyCFunction) _wrap_PyNs3Ipv4Interface_IsDown, METH_NOARGS, NULL },
    {(char *) "GetDevice", (PyCFunction) _wrap_PyNs3Ipv4Interface_GetDevice, METH_NOARGS, NULL },
    {(char *) "SetForwarding", (PyCFunction) _wrap_PyNs3Ipv4Interface_SetForwarding, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetMetric", (PyCFunction) _wrap_PyNs3Ipv4Interface_SetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RemoveAddress", (PyCFunction) _wrap_PyNs3Ipv4Interface_RemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3Ipv4Interface__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3Ipv4Interface__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3Ipv4Interface__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "DoDispose", (PyCFunction) PyNs3Ipv4Interface__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4Interface__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4Interface__tp_clear(PyNs3Ipv4Interface *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv4Interface *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv4Interface__tp_traverse(PyNs3Ipv4Interface *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3Ipv4Interface__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3Ipv4Interface__tp_dealloc(PyNs3Ipv4Interface *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4Interface__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4Interface__tp_richcompare (PyNs3Ipv4Interface *PYBINDGEN_UNUSED(self), PyNs3Ipv4Interface *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4Interface_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4Interface_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4Interface",            /* tp_name */
    sizeof(PyNs3Ipv4Interface),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4Interface__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4Interface__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4Interface__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4Interface__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4Interface_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4Interface, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4Interface__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3Ipv4L3Protocol__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3Ipv4L3Protocol *self)
{
    PyObject *py_retval;
    PyNs3Ipv4L3Protocol__PythonHelper *helper = dynamic_cast< PyNs3Ipv4L3Protocol__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv4L3Protocol__PythonHelper::_wrap_NotifyNewAggregate(PyNs3Ipv4L3Protocol *self)
{
    PyObject *py_retval;
    PyNs3Ipv4L3Protocol__PythonHelper *helper = dynamic_cast< PyNs3Ipv4L3Protocol__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Ipv4L3Protocol is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv4L3Protocol__PythonHelper::_wrap_DoStart(PyNs3Ipv4L3Protocol *self)
{
    PyObject *py_retval;
    PyNs3Ipv4L3Protocol__PythonHelper *helper = dynamic_cast< PyNs3Ipv4L3Protocol__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv4L3Protocol__PythonHelper::_wrap_DoDispose(PyNs3Ipv4L3Protocol *self)
{
    PyObject *py_retval;
    PyNs3Ipv4L3Protocol__PythonHelper *helper = dynamic_cast< PyNs3Ipv4L3Protocol__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Ipv4L3Protocol is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

bool
PyNs3Ipv4L3Protocol__PythonHelper::AddAddress(uint32_t i, ns3::Ipv4InterfaceAddress address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv4InterfaceAddress *py_Ipv4InterfaceAddress;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "AddAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::AddAddress(i, address);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    py_Ipv4InterfaceAddress = PyObject_New(PyNs3Ipv4InterfaceAddress, &PyNs3Ipv4InterfaceAddress_Type);
    py_Ipv4InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4InterfaceAddress->obj = new ns3::Ipv4InterfaceAddress(address);
    PyNs3Ipv4InterfaceAddress_wrapper_registry[(void *) py_Ipv4InterfaceAddress->obj] = (PyObject *) py_Ipv4InterfaceAddress;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "AddAddress", (char *) "NN", PyLong_FromUnsignedLong(i), py_Ipv4InterfaceAddress);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::AddAddress(i, address);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::AddAddress(i, address);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv4L3Protocol__PythonHelper::AddInterface(ns3::Ptr< ns3::NetDevice > device)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "AddInterface"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::AddInterface(device);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "AddInterface", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::AddInterface(device);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::AddInterface(device);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Socket >
PyNs3Ipv4L3Protocol__PythonHelper::CreateRawSocket()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Socket > retval;
    PyNs3Socket *tmp_Socket;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "CreateRawSocket"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::CreateRawSocket();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "CreateRawSocket", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::CreateRawSocket();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Socket_Type, &tmp_Socket)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::CreateRawSocket();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Socket  > (tmp_Socket->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::DeleteRawSocket(ns3::Ptr< ns3::Socket > socket)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    PyNs3Socket *py_Socket;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DeleteRawSocket"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv4L3Protocol::DeleteRawSocket(socket);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    if (typeid(*(const_cast<ns3::Socket *> (ns3::PeekPointer (socket)))).name() == typeid(PyNs3Socket__PythonHelper).name())
    {
        py_Socket = (PyNs3Socket*) (((PyNs3Socket__PythonHelper*) const_cast<ns3::Socket *> (ns3::PeekPointer (socket)))->m_pyself);
        py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (socket));
        Py_INCREF(py_Socket);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Socket *> (ns3::PeekPointer (socket)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Socket = NULL;
        } else {
            py_Socket = (PyNs3Socket *) wrapper_lookup_iter->second;
            Py_INCREF(py_Socket);
        }
    
        if (py_Socket == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Socket *> (ns3::PeekPointer (socket))), &PyNs3Socket_Type);
            py_Socket = PyObject_GC_New(PyNs3Socket, wrapper_type);
            py_Socket->inst_dict = NULL;
            py_Socket->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Socket *> (ns3::PeekPointer (socket))->Ref();
            py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (socket));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Socket->obj] = (PyObject *) py_Socket;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DeleteRawSocket", (char *) "N", py_Socket);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::Ipv4InterfaceAddress
PyNs3Ipv4L3Protocol__PythonHelper::GetAddress(uint32_t interfaceIndex, uint32_t addressIndex) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv4InterfaceAddress *tmp_Ipv4InterfaceAddress;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetAddress(interfaceIndex, addressIndex);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetAddress", (char *) "NN", PyLong_FromUnsignedLong(interfaceIndex), PyLong_FromUnsignedLong(addressIndex));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetAddress(interfaceIndex, addressIndex);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv4InterfaceAddress_Type, &tmp_Ipv4InterfaceAddress)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetAddress(interfaceIndex, addressIndex);
    }
    ns3::Ipv4InterfaceAddress retval = *tmp_Ipv4InterfaceAddress->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3Ipv4L3Protocol__PythonHelper::GetInterfaceForAddress(ns3::Ipv4Address addr) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInterfaceForAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetInterfaceForAddress(addr);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(addr);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInterfaceForAddress", (char *) "N", py_Ipv4Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetInterfaceForAddress(addr);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetInterfaceForAddress(addr);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3Ipv4L3Protocol__PythonHelper::GetInterfaceForDevice(ns3::Ptr< ns3::NetDevice const > device) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInterfaceForDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetInterfaceForDevice(device);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInterfaceForDevice", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetInterfaceForDevice(device);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetInterfaceForDevice(device);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3Ipv4L3Protocol__PythonHelper::GetInterfaceForPrefix(ns3::Ipv4Address addr, ns3::Ipv4Mask mask) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    PyNs3Ipv4Mask *py_Ipv4Mask;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInterfaceForPrefix"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetInterfaceForPrefix(addr, mask);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(addr);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_Ipv4Mask = PyObject_New(PyNs3Ipv4Mask, &PyNs3Ipv4Mask_Type);
    py_Ipv4Mask->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Mask->obj = new ns3::Ipv4Mask(mask);
    PyNs3Ipv4Mask_wrapper_registry[(void *) py_Ipv4Mask->obj] = (PyObject *) py_Ipv4Mask;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInterfaceForPrefix", (char *) "NN", py_Ipv4Address, py_Ipv4Mask);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetInterfaceForPrefix(addr, mask);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetInterfaceForPrefix(addr, mask);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint16_t
PyNs3Ipv4L3Protocol__PythonHelper::GetMetric(uint32_t i) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    uint16_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetMetric"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetMetric(i);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetMetric", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetMetric(i);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetMetric(i);
    }
    if (tmp > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetMetric(i);
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint16_t
PyNs3Ipv4L3Protocol__PythonHelper::GetMtu(uint32_t i) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    uint16_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetMtu"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetMtu(i);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetMtu", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetMtu(i);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetMtu(i);
    }
    if (tmp > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetMtu(i);
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv4L3Protocol__PythonHelper::GetNAddresses(uint32_t interface) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNAddresses"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetNAddresses(interface);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNAddresses", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetNAddresses(interface);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetNAddresses(interface);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv4L3Protocol__PythonHelper::GetNInterfaces() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNInterfaces"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetNInterfaces();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNInterfaces", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetNInterfaces();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetNInterfaces();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::NetDevice >
PyNs3Ipv4L3Protocol__PythonHelper::GetNetDevice(uint32_t i)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *tmp_NetDevice;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetNetDevice(i);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNetDevice", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetNetDevice(i);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3NetDevice_Type, &tmp_NetDevice)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetNetDevice(i);
    }
    // dangerous!
    retval = ns3::Ptr< ns3::NetDevice  > (tmp_NetDevice->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::IpL4Protocol >
PyNs3Ipv4L3Protocol__PythonHelper::GetProtocol(int protocolNumber) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::IpL4Protocol > retval;
    PyNs3IpL4Protocol *tmp_IpL4Protocol;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetProtocol"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetProtocol(protocolNumber);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetProtocol", (char *) "i", protocolNumber);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetProtocol(protocolNumber);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3IpL4Protocol_Type, &tmp_IpL4Protocol)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetProtocol(protocolNumber);
    }
    // dangerous!
    retval = ns3::Ptr< ns3::IpL4Protocol  > (tmp_IpL4Protocol->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Ipv4RoutingProtocol >
PyNs3Ipv4L3Protocol__PythonHelper::GetRoutingProtocol() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4RoutingProtocol > retval;
    PyNs3Ipv4RoutingProtocol *tmp_Ipv4RoutingProtocol;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetRoutingProtocol"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetRoutingProtocol();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetRoutingProtocol", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetRoutingProtocol();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv4RoutingProtocol_Type, &tmp_Ipv4RoutingProtocol)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::GetRoutingProtocol();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Ipv4RoutingProtocol  > (tmp_Ipv4RoutingProtocol->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::Insert(ns3::Ptr< ns3::IpL4Protocol > protocol)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    PyNs3IpL4Protocol *py_IpL4Protocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Insert"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv4L3Protocol::Insert(protocol);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (protocol)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_IpL4Protocol = NULL;
    } else {
        py_IpL4Protocol = (PyNs3IpL4Protocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_IpL4Protocol);
    }
    
    if (py_IpL4Protocol == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (protocol))), &PyNs3IpL4Protocol_Type);
        py_IpL4Protocol = PyObject_GC_New(PyNs3IpL4Protocol, wrapper_type);
        py_IpL4Protocol->inst_dict = NULL;
        py_IpL4Protocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (protocol))->Ref();
        py_IpL4Protocol->obj = const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (protocol));
        PyNs3ObjectBase_wrapper_registry[(void *) py_IpL4Protocol->obj] = (PyObject *) py_IpL4Protocol;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Insert", (char *) "N", py_IpL4Protocol);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3Ipv4L3Protocol__PythonHelper::IsDestinationAddress(ns3::Ipv4Address address, uint32_t iif) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsDestinationAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::IsDestinationAddress(address, iif);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(address);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsDestinationAddress", (char *) "NN", py_Ipv4Address, PyLong_FromUnsignedLong(iif));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::IsDestinationAddress(address, iif);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::IsDestinationAddress(address, iif);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv4L3Protocol__PythonHelper::IsForwarding(uint32_t i) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsForwarding"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::IsForwarding(i);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsForwarding", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::IsForwarding(i);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::IsForwarding(i);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv4L3Protocol__PythonHelper::IsUp(uint32_t i) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsUp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::IsUp(i);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsUp", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::IsUp(i);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::IsUp(i);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv4L3Protocol__PythonHelper::RemoveAddress(uint32_t interfaceIndex, uint32_t addressIndex)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "RemoveAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::RemoveAddress(interfaceIndex, addressIndex);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "RemoveAddress", (char *) "NN", PyLong_FromUnsignedLong(interfaceIndex), PyLong_FromUnsignedLong(addressIndex));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::RemoveAddress(interfaceIndex, addressIndex);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::RemoveAddress(interfaceIndex, addressIndex);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ipv4Address
PyNs3Ipv4L3Protocol__PythonHelper::SelectSourceAddress(ns3::Ptr< ns3::NetDevice const > device, ns3::Ipv4Address dst, ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e scope)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Ipv4Address *py_Ipv4Address;
    PyNs3Ipv4Address *tmp_Ipv4Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SelectSourceAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::SelectSourceAddress(device, dst, scope);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(dst);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SelectSourceAddress", (char *) "NNi", py_NetDevice, py_Ipv4Address, scope);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::SelectSourceAddress(device, dst, scope);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv4Address_Type, &tmp_Ipv4Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4L3Protocol::SelectSourceAddress(device, dst, scope);
    }
    ns3::Ipv4Address retval = *tmp_Ipv4Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::Send(ns3::Ptr< ns3::Packet > packet, ns3::Ipv4Address source, ns3::Ipv4Address destination, uint8_t protocol, ns3::Ptr< ns3::Ipv4Route > route)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Ipv4Address *py_Ipv4Address;
    PyNs3Ipv4Address *py_Ipv4Address2;
    PyNs3Ipv4Route *py_Ipv4Route;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter2;
    PyTypeObject *wrapper_type2 = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Send"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv4L3Protocol::Send(packet, source, destination, protocol, route);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (packet)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (packet))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (packet))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (packet));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(source);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_Ipv4Address2 = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address2->obj = new ns3::Ipv4Address(destination);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address2->obj] = (PyObject *) py_Ipv4Address2;
    wrapper_lookup_iter2 = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route)));
    if (wrapper_lookup_iter2 == PyNs3Empty_wrapper_registry.end()) {
        py_Ipv4Route = NULL;
    } else {
        py_Ipv4Route = (PyNs3Ipv4Route *) wrapper_lookup_iter2->second;
        Py_INCREF(py_Ipv4Route);
    }
    
    if (py_Ipv4Route == NULL)
    {
        wrapper_type2 = PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route))), &PyNs3Ipv4Route_Type);
        py_Ipv4Route = PyObject_New(PyNs3Ipv4Route, wrapper_type2);
        py_Ipv4Route->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route))->Ref();
        py_Ipv4Route->obj = const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route));
        PyNs3Empty_wrapper_registry[(void *) py_Ipv4Route->obj] = (PyObject *) py_Ipv4Route;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Send", (char *) "NNNiN", py_Packet, py_Ipv4Address, py_Ipv4Address2, (int) protocol, py_Ipv4Route);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::SendWithHeader(ns3::Ptr< ns3::Packet > packet, ns3::Ipv4Header ipHeader, ns3::Ptr< ns3::Ipv4Route > route)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Ipv4Header *py_Ipv4Header;
    PyNs3Ipv4Route *py_Ipv4Route;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter2;
    PyTypeObject *wrapper_type2 = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SendWithHeader"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv4L3Protocol::SendWithHeader(packet, ipHeader, route);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (packet)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (packet))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (packet))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (packet));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Ipv4Header = PyObject_GC_New(PyNs3Ipv4Header, &PyNs3Ipv4Header_Type);
    py_Ipv4Header->inst_dict = NULL;
    py_Ipv4Header->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Header->obj = new ns3::Ipv4Header(ipHeader);
    PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4Header->obj] = (PyObject *) py_Ipv4Header;
    wrapper_lookup_iter2 = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route)));
    if (wrapper_lookup_iter2 == PyNs3Empty_wrapper_registry.end()) {
        py_Ipv4Route = NULL;
    } else {
        py_Ipv4Route = (PyNs3Ipv4Route *) wrapper_lookup_iter2->second;
        Py_INCREF(py_Ipv4Route);
    }
    
    if (py_Ipv4Route == NULL)
    {
        wrapper_type2 = PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route))), &PyNs3Ipv4Route_Type);
        py_Ipv4Route = PyObject_New(PyNs3Ipv4Route, wrapper_type2);
        py_Ipv4Route->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route))->Ref();
        py_Ipv4Route->obj = const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (route));
        PyNs3Empty_wrapper_registry[(void *) py_Ipv4Route->obj] = (PyObject *) py_Ipv4Route;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SendWithHeader", (char *) "NNN", py_Packet, py_Ipv4Header, py_Ipv4Route);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::SetDown(uint32_t i)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetDown"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv4L3Protocol::SetDown(i);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetDown", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::SetForwarding(uint32_t i, bool val)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetForwarding"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv4L3Protocol::SetForwarding(i, val);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetForwarding", (char *) "NN", PyLong_FromUnsignedLong(i), PyBool_FromLong(val));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::SetMetric(uint32_t i, uint16_t metric)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetMetric"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv4L3Protocol::SetMetric(i, metric);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetMetric", (char *) "Ni", PyLong_FromUnsignedLong(i), (int) metric);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::SetRoutingProtocol(ns3::Ptr< ns3::Ipv4RoutingProtocol > routingProtocol)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv4RoutingProtocol *py_Ipv4RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetRoutingProtocol"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv4L3Protocol::SetRoutingProtocol(routingProtocol);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (routingProtocol)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv4RoutingProtocol = NULL;
    } else {
        py_Ipv4RoutingProtocol = (PyNs3Ipv4RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4RoutingProtocol);
    }
    
    if (py_Ipv4RoutingProtocol == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (routingProtocol))), &PyNs3Ipv4RoutingProtocol_Type);
        py_Ipv4RoutingProtocol = PyObject_GC_New(PyNs3Ipv4RoutingProtocol, wrapper_type);
        py_Ipv4RoutingProtocol->inst_dict = NULL;
        py_Ipv4RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (routingProtocol))->Ref();
        py_Ipv4RoutingProtocol->obj = const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (routingProtocol));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4RoutingProtocol->obj] = (PyObject *) py_Ipv4RoutingProtocol;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetRoutingProtocol", (char *) "N", py_Ipv4RoutingProtocol);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::SetUp(uint32_t i)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetUp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv4L3Protocol::SetUp(i);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetUp", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv4L3Protocol::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv4L3Protocol::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3Ipv4L3Protocol__PythonHelper::GetIpForward() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetIpForward"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetIpForward", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv4L3Protocol__PythonHelper::GetWeakEsModel() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetWeakEsModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv4L3Protocol* >((const ns3::Ipv4L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetWeakEsModel", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::SetIpForward(bool forward)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetIpForward"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetIpForward", (char *) "N", PyBool_FromLong(forward));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::SetWeakEsModel(bool model)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetWeakEsModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = (ns3::Ipv4L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetWeakEsModel", (char *) "N", PyBool_FromLong(model));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3Ipv4L3Protocol__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4L3Protocol__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}
static PyObject* _wrap_PyNs3Ipv4L3Protocol__get_PROT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", ns3::Ipv4L3Protocol::PROT_NUMBER);
    return py_retval;
}
static PyGetSetDef Ns3Ipv4L3ProtocolMeta__getsets[] = {
    {
        (char*) "PROT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3Ipv4L3Protocol__get_PROT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv4L3ProtocolMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv4L3ProtocolMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv4L3ProtocolMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};


static int
_wrap_PyNs3Ipv4L3Protocol__tp_init(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv4L3Protocol_Type)
    {
        self->obj = new PyNs3Ipv4L3Protocol__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv4L3Protocol__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::Ipv4L3Protocol();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetInterfaceForAddress(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv4Address *addr;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetInterfaceForAddress(*((PyNs3Ipv4Address *) addr)->obj)) : (self->obj->ns3::Ipv4L3Protocol::GetInterfaceForAddress(*((PyNs3Ipv4Address *) addr)->obj));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetNInterfaces(PyNs3Ipv4L3Protocol *self)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->GetNInterfaces()) : (self->obj->ns3::Ipv4L3Protocol::GetNInterfaces());
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_SetMetric(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    int metric;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "Ii", (char **) keywords, &i, &metric)) {
        return NULL;
    }
    if (metric > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    (helper_class == NULL)? (self->obj->SetMetric(i, metric)) : (self->obj->ns3::Ipv4L3Protocol::SetMetric(i, metric));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetInterfaceForDevice(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"device", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &device)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    retval = (helper_class == NULL)? (self->obj->GetInterfaceForDevice(ns3::Ptr< ns3::NetDevice  > (device_ptr))) : (self->obj->ns3::Ipv4L3Protocol::GetInterfaceForDevice(ns3::Ptr< ns3::NetDevice  > (device_ptr)));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv4L3Protocol::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_Send(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv4Address *source;
    PyNs3Ipv4Address *destination;
    int protocol;
    PyNs3Ipv4Route *route;
    ns3::Ipv4Route *route_ptr;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"packet", "source", "destination", "protocol", "route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!iO!", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv4Address_Type, &source, &PyNs3Ipv4Address_Type, &destination, &protocol, &PyNs3Ipv4Route_Type, &route)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (protocol > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    route_ptr = (route ? route->obj : NULL);
    (helper_class == NULL)? (self->obj->Send(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv4Address *) source)->obj, *((PyNs3Ipv4Address *) destination)->obj, protocol, ns3::Ptr< ns3::Ipv4Route  > (route_ptr))) : (self->obj->ns3::Ipv4L3Protocol::Send(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv4Address *) source)->obj, *((PyNs3Ipv4Address *) destination)->obj, protocol, ns3::Ptr< ns3::Ipv4Route  > (route_ptr)));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_DeleteRawSocket(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Socket *socket;
    ns3::Socket *socket_ptr;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"socket", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Socket_Type, &socket)) {
        return NULL;
    }
    socket_ptr = (socket ? socket->obj : NULL);
    (helper_class == NULL)? (self->obj->DeleteRawSocket(ns3::Ptr< ns3::Socket  > (socket_ptr))) : (self->obj->ns3::Ipv4L3Protocol::DeleteRawSocket(ns3::Ptr< ns3::Socket  > (socket_ptr)));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_SetDown(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    (helper_class == NULL)? (self->obj->SetDown(i)) : (self->obj->ns3::Ipv4L3Protocol::SetDown(i));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_AddInterface(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"device", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &device)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    retval = (helper_class == NULL)? (self->obj->AddInterface(ns3::Ptr< ns3::NetDevice  > (device_ptr))) : (self->obj->ns3::Ipv4L3Protocol::AddInterface(ns3::Ptr< ns3::NetDevice  > (device_ptr)));
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_IsDestinationAddress(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv4Address *address;
    unsigned int iif;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"address", "iif", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &address, &iif)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->IsDestinationAddress(*((PyNs3Ipv4Address *) address)->obj, iif)) : (self->obj->ns3::Ipv4L3Protocol::IsDestinationAddress(*((PyNs3Ipv4Address *) address)->obj, iif));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_SetDefaultTtl(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int ttl;
    const char *keywords[] = {"ttl", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &ttl)) {
        return NULL;
    }
    if (ttl > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetDefaultTtl(ttl);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetNAddresses(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    unsigned int interface;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetNAddresses(interface)) : (self->obj->ns3::Ipv4L3Protocol::GetNAddresses(interface));
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetProtocol(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::IpL4Protocol > retval;
    int protocolNumber;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"protocolNumber", NULL};
    PyNs3IpL4Protocol *py_IpL4Protocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &protocolNumber)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetProtocol(protocolNumber)) : (self->obj->ns3::Ipv4L3Protocol::GetProtocol(protocolNumber));
    if (!(const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_IpL4Protocol = NULL;
    } else {
        py_IpL4Protocol = (PyNs3IpL4Protocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_IpL4Protocol);
    }
    
    if (py_IpL4Protocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval)))), &PyNs3IpL4Protocol_Type);
        py_IpL4Protocol = PyObject_GC_New(PyNs3IpL4Protocol, wrapper_type);
        py_IpL4Protocol->inst_dict = NULL;
        py_IpL4Protocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval))->Ref();
        py_IpL4Protocol->obj = const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_IpL4Protocol->obj] = (PyObject *) py_IpL4Protocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_IpL4Protocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetMtu(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint16_t retval;
    unsigned int i;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetMtu(i)) : (self->obj->ns3::Ipv4L3Protocol::GetMtu(i));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_SetRoutingProtocol(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4RoutingProtocol *routingProtocol;
    ns3::Ipv4RoutingProtocol *routingProtocol_ptr;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"routingProtocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4RoutingProtocol_Type, &routingProtocol)) {
        return NULL;
    }
    routingProtocol_ptr = (routingProtocol ? routingProtocol->obj : NULL);
    (helper_class == NULL)? (self->obj->SetRoutingProtocol(ns3::Ptr< ns3::Ipv4RoutingProtocol  > (routingProtocol_ptr))) : (self->obj->ns3::Ipv4L3Protocol::SetRoutingProtocol(ns3::Ptr< ns3::Ipv4RoutingProtocol  > (routingProtocol_ptr)));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_SelectSourceAddress(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Ipv4Address *dst;
    ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e scope;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"device", "dst", "scope", NULL};
    PyNs3Ipv4Address *py_Ipv4Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!i", (char **) keywords, &PyNs3NetDevice_Type, &device, &PyNs3Ipv4Address_Type, &dst, &scope)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    ns3::Ipv4Address retval = (helper_class == NULL)? (self->obj->SelectSourceAddress(ns3::Ptr< ns3::NetDevice  > (device_ptr), *((PyNs3Ipv4Address *) dst)->obj, scope)) : (self->obj->ns3::Ipv4L3Protocol::SelectSourceAddress(ns3::Ptr< ns3::NetDevice  > (device_ptr), *((PyNs3Ipv4Address *) dst)->obj, scope));
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_AddAddress(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int i;
    PyNs3Ipv4InterfaceAddress *address;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &i, &PyNs3Ipv4InterfaceAddress_Type, &address)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->AddAddress(i, *((PyNs3Ipv4InterfaceAddress *) address)->obj)) : (self->obj->ns3::Ipv4L3Protocol::AddAddress(i, *((PyNs3Ipv4InterfaceAddress *) address)->obj));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_SetNode(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_IsForwarding(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int i;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->IsForwarding(i)) : (self->obj->ns3::Ipv4L3Protocol::IsForwarding(i));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_Receive(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    int protocol;
    PyObject *from;
    ns3::Address from2;
    PyObject *to;
    ns3::Address to2;
    ns3::NetDevice::PacketType packetType;
    const char *keywords[] = {"device", "p", "protocol", "from", "to", "packetType", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!iOOi", (char **) keywords, &PyNs3NetDevice_Type, &device, &PyNs3Packet_Type, &p, &protocol, &from, &to, &packetType)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    p_ptr = (p ? p->obj : NULL);
    if (protocol > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (PyObject_IsInstance(from, (PyObject*) &PyNs3Address_Type)) {
        from2 = *((PyNs3Address *) from)->obj;
    } else if (PyObject_IsInstance(from, (PyObject*) &PyNs3Ipv4Address_Type)) {
        from2 = *((PyNs3Ipv4Address *) from)->obj;
    } else if (PyObject_IsInstance(from, (PyObject*) &PyNs3Ipv6Address_Type)) {
        from2 = *((PyNs3Ipv6Address *) from)->obj;
    } else if (PyObject_IsInstance(from, (PyObject*) &PyNs3Mac48Address_Type)) {
        from2 = *((PyNs3Mac48Address *) from)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", from->ob_type->tp_name);
        return NULL;
    }
    if (PyObject_IsInstance(to, (PyObject*) &PyNs3Address_Type)) {
        to2 = *((PyNs3Address *) to)->obj;
    } else if (PyObject_IsInstance(to, (PyObject*) &PyNs3Ipv4Address_Type)) {
        to2 = *((PyNs3Ipv4Address *) to)->obj;
    } else if (PyObject_IsInstance(to, (PyObject*) &PyNs3Ipv6Address_Type)) {
        to2 = *((PyNs3Ipv6Address *) to)->obj;
    } else if (PyObject_IsInstance(to, (PyObject*) &PyNs3Mac48Address_Type)) {
        to2 = *((PyNs3Mac48Address *) to)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", to->ob_type->tp_name);
        return NULL;
    }
    self->obj->Receive(ns3::Ptr< ns3::NetDevice  > (device_ptr), ns3::Ptr< ns3::Packet  > (p_ptr), protocol, from2, to2, packetType);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetAddress(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interfaceIndex;
    unsigned int addressIndex;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"interfaceIndex", "addressIndex", NULL};
    PyNs3Ipv4InterfaceAddress *py_Ipv4InterfaceAddress;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &interfaceIndex, &addressIndex)) {
        return NULL;
    }
    ns3::Ipv4InterfaceAddress retval = (helper_class == NULL)? (self->obj->GetAddress(interfaceIndex, addressIndex)) : (self->obj->ns3::Ipv4L3Protocol::GetAddress(interfaceIndex, addressIndex));
    py_Ipv4InterfaceAddress = PyObject_New(PyNs3Ipv4InterfaceAddress, &PyNs3Ipv4InterfaceAddress_Type);
    py_Ipv4InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4InterfaceAddress->obj = new ns3::Ipv4InterfaceAddress(retval);
    PyNs3Ipv4InterfaceAddress_wrapper_registry[(void *) py_Ipv4InterfaceAddress->obj] = (PyObject *) py_Ipv4InterfaceAddress;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4InterfaceAddress);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_Insert(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3IpL4Protocol *protocol;
    ns3::IpL4Protocol *protocol_ptr;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3IpL4Protocol_Type, &protocol)) {
        return NULL;
    }
    protocol_ptr = (protocol ? protocol->obj : NULL);
    (helper_class == NULL)? (self->obj->Insert(ns3::Ptr< ns3::IpL4Protocol  > (protocol_ptr))) : (self->obj->ns3::Ipv4L3Protocol::Insert(ns3::Ptr< ns3::IpL4Protocol  > (protocol_ptr)));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_Remove(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3IpL4Protocol *protocol;
    ns3::IpL4Protocol *protocol_ptr;
    const char *keywords[] = {"protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3IpL4Protocol_Type, &protocol)) {
        return NULL;
    }
    protocol_ptr = (protocol ? protocol->obj : NULL);
    self->obj->Remove(ns3::Ptr< ns3::IpL4Protocol  > (protocol_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetInterfaceForPrefix(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv4Address *addr;
    PyNs3Ipv4Mask *mask;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"addr", "mask", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr, &PyNs3Ipv4Mask_Type, &mask)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetInterfaceForPrefix(*((PyNs3Ipv4Address *) addr)->obj, *((PyNs3Ipv4Mask *) mask)->obj)) : (self->obj->ns3::Ipv4L3Protocol::GetInterfaceForPrefix(*((PyNs3Ipv4Address *) addr)->obj, *((PyNs3Ipv4Mask *) mask)->obj));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetNetDevice(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    unsigned int i;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetNetDevice(i)) : (self->obj->ns3::Ipv4L3Protocol::GetNetDevice(i));
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetRoutingProtocol(PyNs3Ipv4L3Protocol *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4RoutingProtocol > retval;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    PyNs3Ipv4RoutingProtocol *py_Ipv4RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = (helper_class == NULL)? (self->obj->GetRoutingProtocol()) : (self->obj->ns3::Ipv4L3Protocol::GetRoutingProtocol());
    if (!(const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv4RoutingProtocol = NULL;
    } else {
        py_Ipv4RoutingProtocol = (PyNs3Ipv4RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4RoutingProtocol);
    }
    
    if (py_Ipv4RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4RoutingProtocol_Type);
        py_Ipv4RoutingProtocol = PyObject_GC_New(PyNs3Ipv4RoutingProtocol, wrapper_type);
        py_Ipv4RoutingProtocol->inst_dict = NULL;
        py_Ipv4RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4RoutingProtocol->obj = const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4RoutingProtocol->obj] = (PyObject *) py_Ipv4RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingProtocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_RemoveAddress(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int interfaceIndex;
    unsigned int addressIndex;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"interfaceIndex", "addressIndex", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &interfaceIndex, &addressIndex)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->RemoveAddress(interfaceIndex, addressIndex)) : (self->obj->ns3::Ipv4L3Protocol::RemoveAddress(interfaceIndex, addressIndex));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetMetric(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint16_t retval;
    unsigned int i;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetMetric(i)) : (self->obj->ns3::Ipv4L3Protocol::GetMetric(i));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_SetUp(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    (helper_class == NULL)? (self->obj->SetUp(i)) : (self->obj->ns3::Ipv4L3Protocol::SetUp(i));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_CreateRawSocket(PyNs3Ipv4L3Protocol *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Socket > retval;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    PyNs3Socket *py_Socket;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = (helper_class == NULL)? (self->obj->CreateRawSocket()) : (self->obj->ns3::Ipv4L3Protocol::CreateRawSocket());
    if (!(const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Socket__PythonHelper).name())
    {
        py_Socket = reinterpret_cast< PyNs3Socket* >(reinterpret_cast< PyNs3Socket__PythonHelper* >(const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Socket);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Socket *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Socket = NULL;
        } else {
            py_Socket = (PyNs3Socket *) wrapper_lookup_iter->second;
            Py_INCREF(py_Socket);
        }
    
        if (py_Socket == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))), &PyNs3Socket_Type);
            py_Socket = PyObject_GC_New(PyNs3Socket, wrapper_type);
            py_Socket->inst_dict = NULL;
            py_Socket->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Socket *> (ns3::PeekPointer (retval))->Ref();
            py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Socket->obj] = (PyObject *) py_Socket;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Socket);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_SendWithHeader(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv4Header *ipHeader;
    PyNs3Ipv4Route *route;
    ns3::Ipv4Route *route_ptr;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"packet", "ipHeader", "route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv4Header_Type, &ipHeader, &PyNs3Ipv4Route_Type, &route)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    route_ptr = (route ? route->obj : NULL);
    (helper_class == NULL)? (self->obj->SendWithHeader(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv4Header *) ipHeader)->obj, ns3::Ptr< ns3::Ipv4Route  > (route_ptr))) : (self->obj->ns3::Ipv4L3Protocol::SendWithHeader(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv4Header *) ipHeader)->obj, ns3::Ptr< ns3::Ipv4Route  > (route_ptr)));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_IsUp(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int i;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->IsUp(i)) : (self->obj->ns3::Ipv4L3Protocol::IsUp(i));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_GetInterface(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4Interface > retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    PyNs3Ipv4Interface *py_Ipv4Interface;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = self->obj->GetInterface(i);
    if (!(const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Ipv4Interface__PythonHelper).name())
    {
        py_Ipv4Interface = reinterpret_cast< PyNs3Ipv4Interface* >(reinterpret_cast< PyNs3Ipv4Interface__PythonHelper* >(const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Ipv4Interface->obj = const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Ipv4Interface);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Ipv4Interface = NULL;
        } else {
            py_Ipv4Interface = (PyNs3Ipv4Interface *) wrapper_lookup_iter->second;
            Py_INCREF(py_Ipv4Interface);
        }
    
        if (py_Ipv4Interface == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4Interface_Type);
            py_Ipv4Interface = PyObject_GC_New(PyNs3Ipv4Interface, wrapper_type);
            py_Ipv4Interface->inst_dict = NULL;
            py_Ipv4Interface->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval))->Ref();
            py_Ipv4Interface->obj = const_cast<ns3::Ipv4Interface *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4Interface->obj] = (PyObject *) py_Ipv4Interface;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Interface);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4L3Protocol_SetForwarding(PyNs3Ipv4L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    bool val;
    PyObject *py_val;
    PyNs3Ipv4L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", "val", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO", (char **) keywords, &i, &py_val)) {
        return NULL;
    }
    val = (bool) PyObject_IsTrue(py_val);
    (helper_class == NULL)? (self->obj->SetForwarding(i, val)) : (self->obj->ns3::Ipv4L3Protocol::SetForwarding(i, val));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3Ipv4L3Protocol_methods[] = {
    {(char *) "GetInterfaceForAddress", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetInterfaceForAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNInterfaces", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetNInterfaces, METH_NOARGS, NULL },
    {(char *) "SetMetric", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_SetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInterfaceForDevice", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetInterfaceForDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Send", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "DeleteRawSocket", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_DeleteRawSocket, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDown", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_SetDown, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddInterface", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_AddInterface, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsDestinationAddress", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_IsDestinationAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDefaultTtl", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_SetDefaultTtl, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNAddresses", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetNAddresses, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetProtocol", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMtu", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetMtu, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRoutingProtocol", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_SetRoutingProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SelectSourceAddress", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_SelectSourceAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddAddress", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_AddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsForwarding", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_IsForwarding, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Receive", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_Receive, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Insert", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_Insert, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Remove", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_Remove, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInterfaceForPrefix", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetInterfaceForPrefix, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNetDevice", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetNetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetRoutingProtocol", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetRoutingProtocol, METH_NOARGS, NULL },
    {(char *) "RemoveAddress", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_RemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMetric", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetUp", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_SetUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "CreateRawSocket", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_CreateRawSocket, METH_NOARGS, NULL },
    {(char *) "SendWithHeader", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_SendWithHeader, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsUp", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_IsUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInterface", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_GetInterface, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetForwarding", (PyCFunction) _wrap_PyNs3Ipv4L3Protocol_SetForwarding, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3Ipv4L3Protocol__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3Ipv4L3Protocol__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3Ipv4L3Protocol__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "DoDispose", (PyCFunction) PyNs3Ipv4L3Protocol__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4L3Protocol__tp_clear(PyNs3Ipv4L3Protocol *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv4L3Protocol *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv4L3Protocol__tp_traverse(PyNs3Ipv4L3Protocol *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3Ipv4L3Protocol__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3Ipv4L3Protocol__tp_dealloc(PyNs3Ipv4L3Protocol *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4L3Protocol__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4L3Protocol__tp_richcompare (PyNs3Ipv4L3Protocol *PYBINDGEN_UNUSED(self), PyNs3Ipv4L3Protocol *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4L3Protocol_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4L3Protocol_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4L3Protocol",            /* tp_name */
    sizeof(PyNs3Ipv4L3Protocol),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4L3Protocol__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4L3Protocol__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4L3Protocol__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4L3Protocol__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4L3Protocol_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4L3Protocol, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4L3Protocol__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3Ipv4MulticastRoute__get_MAX_INTERFACES(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(ns3::Ipv4MulticastRoute::MAX_INTERFACES));
    return py_retval;
}
static PyObject* _wrap_PyNs3Ipv4MulticastRoute__get_MAX_TTL(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(ns3::Ipv4MulticastRoute::MAX_TTL));
    return py_retval;
}
static PyGetSetDef Ns3Ipv4MulticastRouteMeta__getsets[] = {
    {
        (char*) "MAX_TTL", /* attribute name */
        (getter) _wrap_PyNs3Ipv4MulticastRoute__get_MAX_TTL, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MAX_INTERFACES", /* attribute name */
        (getter) _wrap_PyNs3Ipv4MulticastRoute__get_MAX_INTERFACES, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv4MulticastRouteMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv4MulticastRouteMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv4MulticastRouteMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Ipv4MulticastRoute__tp_init__0(PyNs3Ipv4MulticastRoute *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4MulticastRoute *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4MulticastRoute_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4MulticastRoute(*((PyNs3Ipv4MulticastRoute *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4MulticastRoute__tp_init__1(PyNs3Ipv4MulticastRoute *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4MulticastRoute();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4MulticastRoute__tp_init(PyNs3Ipv4MulticastRoute *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4MulticastRoute__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4MulticastRoute__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoute_GetParent(PyNs3Ipv4MulticastRoute *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetParent();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoute_SetGroup(PyNs3Ipv4MulticastRoute *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *group;
    const char *keywords[] = {"group", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &group)) {
        return NULL;
    }
    self->obj->SetGroup(*((PyNs3Ipv4Address *) group)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoute_GetOrigin(PyNs3Ipv4MulticastRoute *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetOrigin();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoute_SetOutputTtl(PyNs3Ipv4MulticastRoute *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int oif;
    unsigned int ttl;
    const char *keywords[] = {"oif", "ttl", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &oif, &ttl)) {
        return NULL;
    }
    self->obj->SetOutputTtl(oif, ttl);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoute_SetOrigin(PyNs3Ipv4MulticastRoute *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *origin;
    const char *keywords[] = {"origin", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &origin)) {
        return NULL;
    }
    self->obj->SetOrigin(*((PyNs3Ipv4Address *) origin)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoute_GetOutputTtl(PyNs3Ipv4MulticastRoute *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    unsigned int oif;
    const char *keywords[] = {"oif", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &oif)) {
        return NULL;
    }
    if (PyErr_Warn(PyExc_DeprecationWarning, (char *) "Deprecated")) {
        return NULL;
    }
    retval = self->obj->GetOutputTtl(oif);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoute_GetOutputTtlMap(PyNs3Ipv4MulticastRoute *self)
{
    PyObject *py_retval;
    std::map< unsigned int, unsigned int > retval;
    Pystd__map__lt___unsigned_int__unsigned_int___gt__ *py_std__map__lt___unsigned_int__unsigned_int___gt__;
    
    retval = self->obj->GetOutputTtlMap();
    py_std__map__lt___unsigned_int__unsigned_int___gt__ = PyObject_New(Pystd__map__lt___unsigned_int__unsigned_int___gt__, &Pystd__map__lt___unsigned_int__unsigned_int___gt___Type);
    py_std__map__lt___unsigned_int__unsigned_int___gt__->obj = new std::map< unsigned int, unsigned int >(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__map__lt___unsigned_int__unsigned_int___gt__);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoute_SetParent(PyNs3Ipv4MulticastRoute *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int iif;
    const char *keywords[] = {"iif", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &iif)) {
        return NULL;
    }
    self->obj->SetParent(iif);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4MulticastRoute_GetGroup(PyNs3Ipv4MulticastRoute *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetGroup();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4MulticastRoute__copy__(PyNs3Ipv4MulticastRoute *self)
{

    PyNs3Ipv4MulticastRoute *py_copy;
    py_copy = PyObject_New(PyNs3Ipv4MulticastRoute, &PyNs3Ipv4MulticastRoute_Type);
    py_copy->obj = new ns3::Ipv4MulticastRoute(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4MulticastRoute_methods[] = {
    {(char *) "GetParent", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoute_GetParent, METH_NOARGS, NULL },
    {(char *) "SetGroup", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoute_SetGroup, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOrigin", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoute_GetOrigin, METH_NOARGS, NULL },
    {(char *) "SetOutputTtl", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoute_SetOutputTtl, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetOrigin", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoute_SetOrigin, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOutputTtl", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoute_GetOutputTtl, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOutputTtlMap", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoute_GetOutputTtlMap, METH_NOARGS, NULL },
    {(char *) "SetParent", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoute_SetParent, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetGroup", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoute_GetGroup, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4MulticastRoute__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv4MulticastRoute__tp_dealloc(PyNs3Ipv4MulticastRoute *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::Ipv4MulticastRoute *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4MulticastRoute__tp_richcompare (PyNs3Ipv4MulticastRoute *PYBINDGEN_UNUSED(self), PyNs3Ipv4MulticastRoute *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4MulticastRoute_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4MulticastRoute_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4MulticastRoute",            /* tp_name */
    sizeof(PyNs3Ipv4MulticastRoute),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4MulticastRoute__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4MulticastRoute__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4MulticastRoute_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4MulticastRoute__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyNs3Ipv4RawSocketFactory__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'Ipv4RawSocketFactory' cannot be constructed (have pure virtual methods but no helper class)");
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketFactory_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv4RawSocketFactory::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

static PyMethodDef PyNs3Ipv4RawSocketFactory_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv4RawSocketFactory_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4RawSocketFactory__tp_clear(PyNs3Ipv4RawSocketFactory *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv4RawSocketFactory *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv4RawSocketFactory__tp_traverse(PyNs3Ipv4RawSocketFactory *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv4RawSocketFactory__tp_dealloc(PyNs3Ipv4RawSocketFactory *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4RawSocketFactory__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4RawSocketFactory__tp_richcompare (PyNs3Ipv4RawSocketFactory *PYBINDGEN_UNUSED(self), PyNs3Ipv4RawSocketFactory *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4RawSocketFactory_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4RawSocketFactory_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4RawSocketFactory",            /* tp_name */
    sizeof(PyNs3Ipv4RawSocketFactory),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4RawSocketFactory__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4RawSocketFactory__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4RawSocketFactory__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4RawSocketFactory__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4RawSocketFactory_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4RawSocketFactory, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4RawSocketFactory__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3Ipv4RawSocketImpl__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper = dynamic_cast< PyNs3Ipv4RawSocketImpl__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv4RawSocketImpl__PythonHelper::_wrap_NotifyNewAggregate(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper = dynamic_cast< PyNs3Ipv4RawSocketImpl__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv4RawSocketImpl__PythonHelper::_wrap_DoStart(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper = dynamic_cast< PyNs3Ipv4RawSocketImpl__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

int
PyNs3Ipv4RawSocketImpl__PythonHelper::Bind(ns3::Address const & address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Bind"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Bind(address);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(address);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Bind", (char *) "N", py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Bind(address);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Bind(address);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3Ipv4RawSocketImpl__PythonHelper::Bind()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Bind"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Bind();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Bind", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Bind();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Bind();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3Ipv4RawSocketImpl__PythonHelper::Bind6()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Bind6"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Bind6();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Bind6", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Bind6();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Bind6();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3Ipv4RawSocketImpl__PythonHelper::Close()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Close"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Close();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Close", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Close();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Close();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3Ipv4RawSocketImpl__PythonHelper::Connect(ns3::Address const & address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Connect"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Connect(address);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(address);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Connect", (char *) "N", py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Connect(address);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Connect(address);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv4RawSocketImpl__PythonHelper::GetAllowBroadcast() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetAllowBroadcast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetAllowBroadcast();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = const_cast< ns3::Ipv4RawSocketImpl* >((const ns3::Ipv4RawSocketImpl*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetAllowBroadcast", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetAllowBroadcast();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetAllowBroadcast();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Socket::SocketErrno
PyNs3Ipv4RawSocketImpl__PythonHelper::GetErrno() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    ns3::Socket::SocketErrno retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetErrno"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetErrno();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = const_cast< ns3::Ipv4RawSocketImpl* >((const ns3::Ipv4RawSocketImpl*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetErrno", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetErrno();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetErrno();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Node >
PyNs3Ipv4RawSocketImpl__PythonHelper::GetNode() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3Node *tmp_Node;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNode"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetNode();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = const_cast< ns3::Ipv4RawSocketImpl* >((const ns3::Ipv4RawSocketImpl*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNode", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetNode();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Node_Type, &tmp_Node)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetNode();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Node  > (tmp_Node->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv4RawSocketImpl__PythonHelper::GetRxAvailable() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetRxAvailable"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetRxAvailable();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = const_cast< ns3::Ipv4RawSocketImpl* >((const ns3::Ipv4RawSocketImpl*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetRxAvailable", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetRxAvailable();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetRxAvailable();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3Ipv4RawSocketImpl__PythonHelper::GetSockName(ns3::Address & address) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetSockName"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetSockName(address);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = const_cast< ns3::Ipv4RawSocketImpl* >((const ns3::Ipv4RawSocketImpl*) this);
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(address);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetSockName", (char *) "N", py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetSockName(address);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetSockName(address);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Socket::SocketType
PyNs3Ipv4RawSocketImpl__PythonHelper::GetSocketType() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    ns3::Socket::SocketType retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetSocketType"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetSocketType();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = const_cast< ns3::Ipv4RawSocketImpl* >((const ns3::Ipv4RawSocketImpl*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetSocketType", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetSocketType();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetSocketType();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv4RawSocketImpl__PythonHelper::GetTxAvailable() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetTxAvailable"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetTxAvailable();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = const_cast< ns3::Ipv4RawSocketImpl* >((const ns3::Ipv4RawSocketImpl*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetTxAvailable", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetTxAvailable();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::GetTxAvailable();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3Ipv4RawSocketImpl__PythonHelper::Listen()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Listen"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Listen();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Listen", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Listen();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Listen();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Packet >
PyNs3Ipv4RawSocketImpl__PythonHelper::Recv(uint32_t maxSize, uint32_t flags)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Packet *tmp_Packet;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Recv"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Recv(maxSize, flags);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Recv", (char *) "NN", PyLong_FromUnsignedLong(maxSize), PyLong_FromUnsignedLong(flags));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Recv(maxSize, flags);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Packet_Type, &tmp_Packet)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Recv(maxSize, flags);
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Packet  > (tmp_Packet->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Packet >
PyNs3Ipv4RawSocketImpl__PythonHelper::RecvFrom(uint32_t maxSize, uint32_t flags, ns3::Address & fromAddress)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Address *py_Address;
    PyNs3Packet *tmp_Packet;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "RecvFrom"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::RecvFrom(maxSize, flags, fromAddress);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(fromAddress);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "RecvFrom", (char *) "NNN", PyLong_FromUnsignedLong(maxSize), PyLong_FromUnsignedLong(flags), py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::RecvFrom(maxSize, flags, fromAddress);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Packet_Type, &tmp_Packet)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::RecvFrom(maxSize, flags, fromAddress);
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Packet  > (tmp_Packet->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3Ipv4RawSocketImpl__PythonHelper::Send(ns3::Ptr< ns3::Packet > p, uint32_t flags)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Send"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Send(p, flags);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (p)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (p))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (p))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (p));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Send", (char *) "NN", py_Packet, PyLong_FromUnsignedLong(flags));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Send(p, flags);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::Send(p, flags);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3Ipv4RawSocketImpl__PythonHelper::SendTo(ns3::Ptr< ns3::Packet > p, uint32_t flags, ns3::Address const & toAddress)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    int retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SendTo"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::SendTo(p, flags, toAddress);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (p)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (p))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (p))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (p));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(toAddress);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SendTo", (char *) "NNN", py_Packet, PyLong_FromUnsignedLong(flags), py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::SendTo(p, flags, toAddress);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::SendTo(p, flags, toAddress);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv4RawSocketImpl__PythonHelper::SetAllowBroadcast(bool allowBroadcast)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetAllowBroadcast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::SetAllowBroadcast(allowBroadcast);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetAllowBroadcast", (char *) "N", PyBool_FromLong(allowBroadcast));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::SetAllowBroadcast(allowBroadcast);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::SetAllowBroadcast(allowBroadcast);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3Ipv4RawSocketImpl__PythonHelper::ShutdownRecv()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "ShutdownRecv"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::ShutdownRecv();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "ShutdownRecv", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::ShutdownRecv();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::ShutdownRecv();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int
PyNs3Ipv4RawSocketImpl__PythonHelper::ShutdownSend()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    int retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "ShutdownSend"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::ShutdownSend();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "ShutdownSend", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::ShutdownSend();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv4RawSocketImpl::ShutdownSend();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4RawSocketImpl__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv4RawSocketImpl *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = (ns3::Ipv4RawSocketImpl*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv4RawSocketImpl* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4RawSocketImpl__PythonHelper::BindToNetDevice(ns3::Ptr< ns3::NetDevice > netdevice)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Socket *self_obj_before;
    PyObject *py_retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "BindToNetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Socket::BindToNetDevice(netdevice);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Socket* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = (ns3::Socket*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (netdevice));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "BindToNetDevice", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Socket* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3Ipv4RawSocketImpl__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv4RawSocketImpl__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4RawSocketImpl__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv4RawSocketImpl__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3Ipv4RawSocketImpl__tp_init__0(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4RawSocketImpl *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4RawSocketImpl_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv4RawSocketImpl_Type)
    {
        self->obj = new PyNs3Ipv4RawSocketImpl__PythonHelper(*((PyNs3Ipv4RawSocketImpl *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv4RawSocketImpl__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::Ipv4RawSocketImpl(*((PyNs3Ipv4RawSocketImpl *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3Ipv4RawSocketImpl__tp_init__1(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv4RawSocketImpl_Type)
    {
        self->obj = new PyNs3Ipv4RawSocketImpl__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv4RawSocketImpl__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::Ipv4RawSocketImpl();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3Ipv4RawSocketImpl__tp_init(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4RawSocketImpl__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4RawSocketImpl__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_GetRxAvailable(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->GetRxAvailable()) : (self->obj->ns3::Ipv4RawSocketImpl::GetRxAvailable());
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_SetProtocol(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int protocol;
    const char *keywords[] = {"protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &protocol)) {
        return NULL;
    }
    if (protocol > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetProtocol(protocol);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_SetAllowBroadcast(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    bool allowBroadcast;
    PyObject *py_allowBroadcast;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    const char *keywords[] = {"allowBroadcast", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_allowBroadcast)) {
        return NULL;
    }
    allowBroadcast = (bool) PyObject_IsTrue(py_allowBroadcast);
    retval = (helper_class == NULL)? (self->obj->SetAllowBroadcast(allowBroadcast)) : (self->obj->ns3::Ipv4RawSocketImpl::SetAllowBroadcast(allowBroadcast));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_GetSocketType(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    ns3::Socket::SocketType retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->GetSocketType()) : (self->obj->ns3::Ipv4RawSocketImpl::GetSocketType());
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_Send(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    unsigned int flags;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    const char *keywords[] = {"p", "flags", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3Packet_Type, &p, &flags)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    retval = (helper_class == NULL)? (self->obj->Send(ns3::Ptr< ns3::Packet  > (p_ptr), flags)) : (self->obj->ns3::Ipv4RawSocketImpl::Send(ns3::Ptr< ns3::Packet  > (p_ptr), flags));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_Bind6(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    int retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->Bind6()) : (self->obj->ns3::Ipv4RawSocketImpl::Bind6());
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_GetAllowBroadcast(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->GetAllowBroadcast()) : (self->obj->ns3::Ipv4RawSocketImpl::GetAllowBroadcast());
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_GetErrno(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    ns3::Socket::SocketErrno retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->GetErrno()) : (self->obj->ns3::Ipv4RawSocketImpl::GetErrno());
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_GetNode(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    PyNs3Node *py_Node;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = (helper_class == NULL)? (self->obj->GetNode()) : (self->obj->ns3::Ipv4RawSocketImpl::GetNode());
    if (!(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Node__PythonHelper).name())
    {
        py_Node = reinterpret_cast< PyNs3Node* >(reinterpret_cast< PyNs3Node__PythonHelper* >(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Node);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Node *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Node = NULL;
        } else {
            py_Node = (PyNs3Node *) wrapper_lookup_iter->second;
            Py_INCREF(py_Node);
        }
    
        if (py_Node == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))), &PyNs3Node_Type);
            py_Node = PyObject_GC_New(PyNs3Node, wrapper_type);
            py_Node->inst_dict = NULL;
            py_Node->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Node *> (ns3::PeekPointer (retval))->Ref();
            py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Node->obj] = (PyObject *) py_Node;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Node);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_ForwardUp(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv4Header *ipHeader;
    PyNs3Ipv4Interface *incomingInterface;
    ns3::Ipv4Interface *incomingInterface_ptr;
    const char *keywords[] = {"p", "ipHeader", "incomingInterface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv4Header_Type, &ipHeader, &PyNs3Ipv4Interface_Type, &incomingInterface)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    incomingInterface_ptr = (incomingInterface ? incomingInterface->obj : NULL);
    retval = self->obj->ForwardUp(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv4Header *) ipHeader)->obj, ns3::Ptr< ns3::Ipv4Interface  > (incomingInterface_ptr));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_ShutdownRecv(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    int retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->ShutdownRecv()) : (self->obj->ns3::Ipv4RawSocketImpl::ShutdownRecv());
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_ShutdownSend(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    int retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->ShutdownSend()) : (self->obj->ns3::Ipv4RawSocketImpl::ShutdownSend());
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_GetSockName(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    PyNs3Address *address;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Address_Type, &address)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetSockName(*((PyNs3Address *) address)->obj)) : (self->obj->ns3::Ipv4RawSocketImpl::GetSockName(*((PyNs3Address *) address)->obj));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_SendTo(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    unsigned int flags;
    PyObject *toAddress;
    ns3::Address toAddress2;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    const char *keywords[] = {"p", "flags", "toAddress", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!IO", (char **) keywords, &PyNs3Packet_Type, &p, &flags, &toAddress)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    if (PyObject_IsInstance(toAddress, (PyObject*) &PyNs3Address_Type)) {
        toAddress2 = *((PyNs3Address *) toAddress)->obj;
    } else if (PyObject_IsInstance(toAddress, (PyObject*) &PyNs3Ipv4Address_Type)) {
        toAddress2 = *((PyNs3Ipv4Address *) toAddress)->obj;
    } else if (PyObject_IsInstance(toAddress, (PyObject*) &PyNs3Ipv6Address_Type)) {
        toAddress2 = *((PyNs3Ipv6Address *) toAddress)->obj;
    } else if (PyObject_IsInstance(toAddress, (PyObject*) &PyNs3Mac48Address_Type)) {
        toAddress2 = *((PyNs3Mac48Address *) toAddress)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", toAddress->ob_type->tp_name);
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->SendTo(ns3::Ptr< ns3::Packet  > (p_ptr), flags, toAddress2)) : (self->obj->ns3::Ipv4RawSocketImpl::SendTo(ns3::Ptr< ns3::Packet  > (p_ptr), flags, toAddress2));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_Listen(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    int retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->Listen()) : (self->obj->ns3::Ipv4RawSocketImpl::Listen());
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_Recv(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    unsigned int maxSize;
    unsigned int flags;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    const char *keywords[] = {"maxSize", "flags", NULL};
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &maxSize, &flags)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->Recv(maxSize, flags)) : (self->obj->ns3::Ipv4RawSocketImpl::Recv(maxSize, flags));
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (retval))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv4RawSocketImpl::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_SetNode(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_Bind__0(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int retval;
    PyObject *address;
    ns3::Address address2;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &address)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (PyObject_IsInstance(address, (PyObject*) &PyNs3Address_Type)) {
        address2 = *((PyNs3Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv4Address_Type)) {
        address2 = *((PyNs3Ipv4Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv6Address_Type)) {
        address2 = *((PyNs3Ipv6Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Mac48Address_Type)) {
        address2 = *((PyNs3Mac48Address *) address)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", address->ob_type->tp_name);
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->Bind(address2)) : (self->obj->ns3::Ipv4RawSocketImpl::Bind(address2));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_Bind__1(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->Bind()) : (self->obj->ns3::Ipv4RawSocketImpl::Bind());
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv4RawSocketImpl_Bind(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4RawSocketImpl_Bind__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4RawSocketImpl_Bind__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_GetTxAvailable(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->GetTxAvailable()) : (self->obj->ns3::Ipv4RawSocketImpl::GetTxAvailable());
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_RecvFrom(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    unsigned int maxSize;
    unsigned int flags;
    PyNs3Address *fromAddress;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    const char *keywords[] = {"maxSize", "flags", "fromAddress", NULL};
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IIO!", (char **) keywords, &maxSize, &flags, &PyNs3Address_Type, &fromAddress)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->RecvFrom(maxSize, flags, *((PyNs3Address *) fromAddress)->obj)) : (self->obj->ns3::Ipv4RawSocketImpl::RecvFrom(maxSize, flags, *((PyNs3Address *) fromAddress)->obj));
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (retval))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_Connect(PyNs3Ipv4RawSocketImpl *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    PyObject *address;
    ns3::Address address2;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &address)) {
        return NULL;
    }
    if (PyObject_IsInstance(address, (PyObject*) &PyNs3Address_Type)) {
        address2 = *((PyNs3Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv4Address_Type)) {
        address2 = *((PyNs3Ipv4Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv6Address_Type)) {
        address2 = *((PyNs3Ipv6Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Mac48Address_Type)) {
        address2 = *((PyNs3Mac48Address *) address)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", address->ob_type->tp_name);
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->Connect(address2)) : (self->obj->ns3::Ipv4RawSocketImpl::Connect(address2));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RawSocketImpl_Close(PyNs3Ipv4RawSocketImpl *self)
{
    PyObject *py_retval;
    int retval;
    PyNs3Ipv4RawSocketImpl__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv4RawSocketImpl__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->Close()) : (self->obj->ns3::Ipv4RawSocketImpl::Close());
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4RawSocketImpl__copy__(PyNs3Ipv4RawSocketImpl *self)
{

    PyNs3Ipv4RawSocketImpl *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv4RawSocketImpl, &PyNs3Ipv4RawSocketImpl_Type);
    py_copy->obj = new ns3::Ipv4RawSocketImpl(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4RawSocketImpl_methods[] = {
    {(char *) "GetRxAvailable", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_GetRxAvailable, METH_NOARGS, NULL },
    {(char *) "SetProtocol", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_SetProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetAllowBroadcast", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_SetAllowBroadcast, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSocketType", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_GetSocketType, METH_NOARGS, NULL },
    {(char *) "Send", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Bind6", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_Bind6, METH_NOARGS, NULL },
    {(char *) "GetAllowBroadcast", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_GetAllowBroadcast, METH_NOARGS, NULL },
    {(char *) "GetErrno", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_GetErrno, METH_NOARGS, NULL },
    {(char *) "GetNode", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_GetNode, METH_NOARGS, NULL },
    {(char *) "ForwardUp", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_ForwardUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "ShutdownRecv", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_ShutdownRecv, METH_NOARGS, NULL },
    {(char *) "ShutdownSend", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_ShutdownSend, METH_NOARGS, NULL },
    {(char *) "GetSockName", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_GetSockName, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SendTo", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_SendTo, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Listen", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_Listen, METH_NOARGS, NULL },
    {(char *) "Recv", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_Recv, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Bind", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_Bind, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTxAvailable", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_GetTxAvailable, METH_NOARGS, NULL },
    {(char *) "RecvFrom", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_RecvFrom, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Connect", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_Connect, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Close", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl_Close, METH_NOARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3Ipv4RawSocketImpl__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3Ipv4RawSocketImpl__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3Ipv4RawSocketImpl__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4RawSocketImpl__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4RawSocketImpl__tp_clear(PyNs3Ipv4RawSocketImpl *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv4RawSocketImpl *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv4RawSocketImpl__tp_traverse(PyNs3Ipv4RawSocketImpl *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3Ipv4RawSocketImpl__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3Ipv4RawSocketImpl__tp_dealloc(PyNs3Ipv4RawSocketImpl *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4RawSocketImpl__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4RawSocketImpl__tp_richcompare (PyNs3Ipv4RawSocketImpl *PYBINDGEN_UNUSED(self), PyNs3Ipv4RawSocketImpl *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4RawSocketImpl_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4RawSocketImpl_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4RawSocketImpl",            /* tp_name */
    sizeof(PyNs3Ipv4RawSocketImpl),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4RawSocketImpl__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4RawSocketImpl__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4RawSocketImpl__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4RawSocketImpl__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4RawSocketImpl_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4RawSocketImpl, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4RawSocketImpl__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv4Route__tp_init__0(PyNs3Ipv4Route *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4Route *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Route_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4Route(*((PyNs3Ipv4Route *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4Route__tp_init__1(PyNs3Ipv4Route *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4Route();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4Route__tp_init(PyNs3Ipv4Route *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4Route__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4Route__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4Route_GetOutputDevice(PyNs3Ipv4Route *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetOutputDevice();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Route_GetGateway(PyNs3Ipv4Route *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetGateway();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Route_SetDestination(PyNs3Ipv4Route *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *dest;
    const char *keywords[] = {"dest", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &dest)) {
        return NULL;
    }
    self->obj->SetDestination(*((PyNs3Ipv4Address *) dest)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Route_SetGateway(PyNs3Ipv4Route *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *gw;
    const char *keywords[] = {"gw", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &gw)) {
        return NULL;
    }
    self->obj->SetGateway(*((PyNs3Ipv4Address *) gw)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Route_SetOutputDevice(PyNs3Ipv4Route *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *outputDevice;
    ns3::NetDevice *outputDevice_ptr;
    const char *keywords[] = {"outputDevice", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &outputDevice)) {
        return NULL;
    }
    outputDevice_ptr = (outputDevice ? outputDevice->obj : NULL);
    self->obj->SetOutputDevice(ns3::Ptr< ns3::NetDevice  > (outputDevice_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Route_GetSource(PyNs3Ipv4Route *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetSource();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Route_GetDestination(PyNs3Ipv4Route *self)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    
    ns3::Ipv4Address retval = self->obj->GetDestination();
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(retval);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4Route_SetSource(PyNs3Ipv4Route *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *src;
    const char *keywords[] = {"src", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &src)) {
        return NULL;
    }
    self->obj->SetSource(*((PyNs3Ipv4Address *) src)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4Route__copy__(PyNs3Ipv4Route *self)
{

    PyNs3Ipv4Route *py_copy;
    py_copy = PyObject_New(PyNs3Ipv4Route, &PyNs3Ipv4Route_Type);
    py_copy->obj = new ns3::Ipv4Route(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4Route_methods[] = {
    {(char *) "GetOutputDevice", (PyCFunction) _wrap_PyNs3Ipv4Route_GetOutputDevice, METH_NOARGS, NULL },
    {(char *) "GetGateway", (PyCFunction) _wrap_PyNs3Ipv4Route_GetGateway, METH_NOARGS, NULL },
    {(char *) "SetDestination", (PyCFunction) _wrap_PyNs3Ipv4Route_SetDestination, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetGateway", (PyCFunction) _wrap_PyNs3Ipv4Route_SetGateway, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetOutputDevice", (PyCFunction) _wrap_PyNs3Ipv4Route_SetOutputDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSource", (PyCFunction) _wrap_PyNs3Ipv4Route_GetSource, METH_NOARGS, NULL },
    {(char *) "GetDestination", (PyCFunction) _wrap_PyNs3Ipv4Route_GetDestination, METH_NOARGS, NULL },
    {(char *) "SetSource", (PyCFunction) _wrap_PyNs3Ipv4Route_SetSource, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4Route__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv4Route__tp_dealloc(PyNs3Ipv4Route *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::Ipv4Route *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyNs3Ipv4Route__tp_str(PyNs3Ipv4Route *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyNs3Ipv4Route__tp_richcompare (PyNs3Ipv4Route *PYBINDGEN_UNUSED(self), PyNs3Ipv4Route *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4Route_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4Route_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4Route",            /* tp_name */
    sizeof(PyNs3Ipv4Route),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4Route__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyNs3Ipv4Route__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4Route__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4Route_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4Route__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyNs3Ipv4RoutingProtocol__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'Ipv4RoutingProtocol' cannot be constructed (have pure virtual methods but no helper class)");
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4RoutingProtocol_NotifyAddAddress(PyNs3Ipv4RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv4InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv4InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyAddAddress(interface, *((PyNs3Ipv4InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingProtocol_NotifyInterfaceUp(PyNs3Ipv4RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceUp(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingProtocol_NotifyInterfaceDown(PyNs3Ipv4RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceDown(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingProtocol_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv4RoutingProtocol::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingProtocol_RouteOutput(PyNs3Ipv4RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4Route > retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv4Header *header;
    PyNs3NetDevice *oif;
    ns3::NetDevice *oif_ptr;
    ns3::Socket::SocketErrno  sockerr;
    const char *keywords[] = {"p", "header", "oif", "sockerr", NULL};
    PyNs3Ipv4Route *py_Ipv4Route;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!i", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv4Header_Type, &header, &PyNs3NetDevice_Type, &oif, &sockerr)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    oif_ptr = (oif ? oif->obj : NULL);
    retval = self->obj->RouteOutput(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv4Header *) header)->obj, ns3::Ptr< ns3::NetDevice  > (oif_ptr), sockerr);
    if (!(const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Ipv4Route = NULL;
    } else {
        py_Ipv4Route = (PyNs3Ipv4Route *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4Route);
    }
    
    if (py_Ipv4Route == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4Route_Type);
        py_Ipv4Route = PyObject_New(PyNs3Ipv4Route, wrapper_type);
        py_Ipv4Route->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4Route->obj = const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Ipv4Route->obj] = (PyObject *) py_Ipv4Route;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Route);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingProtocol_SetIpv4(PyNs3Ipv4RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    const char *keywords[] = {"ipv4", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4_Type, &ipv4)) {
        return NULL;
    }
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    self->obj->SetIpv4(ns3::Ptr< ns3::Ipv4  > (ipv4_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingProtocol_PrintRoutingTable(PyNs3Ipv4RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTable(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4RoutingProtocol_NotifyRemoveAddress(PyNs3Ipv4RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv4InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv4InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyRemoveAddress(interface, *((PyNs3Ipv4InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3Ipv4RoutingProtocol_methods[] = {
    {(char *) "NotifyAddAddress", (PyCFunction) _wrap_PyNs3Ipv4RoutingProtocol_NotifyAddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceUp", (PyCFunction) _wrap_PyNs3Ipv4RoutingProtocol_NotifyInterfaceUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceDown", (PyCFunction) _wrap_PyNs3Ipv4RoutingProtocol_NotifyInterfaceDown, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv4RoutingProtocol_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "RouteOutput", (PyCFunction) _wrap_PyNs3Ipv4RoutingProtocol_RouteOutput, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetIpv4", (PyCFunction) _wrap_PyNs3Ipv4RoutingProtocol_SetIpv4, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTable", (PyCFunction) _wrap_PyNs3Ipv4RoutingProtocol_PrintRoutingTable, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyRemoveAddress", (PyCFunction) _wrap_PyNs3Ipv4RoutingProtocol_NotifyRemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4RoutingProtocol__tp_clear(PyNs3Ipv4RoutingProtocol *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv4RoutingProtocol *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv4RoutingProtocol__tp_traverse(PyNs3Ipv4RoutingProtocol *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv4RoutingProtocol__tp_dealloc(PyNs3Ipv4RoutingProtocol *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4RoutingProtocol__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4RoutingProtocol__tp_richcompare (PyNs3Ipv4RoutingProtocol *PYBINDGEN_UNUSED(self), PyNs3Ipv4RoutingProtocol *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4RoutingProtocol_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4RoutingProtocol_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4RoutingProtocol",            /* tp_name */
    sizeof(PyNs3Ipv4RoutingProtocol),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4RoutingProtocol__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4RoutingProtocol__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4RoutingProtocol__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4RoutingProtocol__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4RoutingProtocol_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4RoutingProtocol, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4RoutingProtocol__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv4StaticRouting__tp_init__0(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4StaticRouting *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4StaticRouting_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4StaticRouting(*((PyNs3Ipv4StaticRouting *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4StaticRouting__tp_init__1(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4StaticRouting();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4StaticRouting__tp_init(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4StaticRouting__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4StaticRouting__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_NotifyAddAddress(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv4InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv4InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyAddAddress(interface, *((PyNs3Ipv4InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv4StaticRouting_RemoveMulticastRoute__0(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv4Address *origin;
    PyNs3Ipv4Address *group;
    unsigned int inputInterface;
    const char *keywords[] = {"origin", "group", "inputInterface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &origin, &PyNs3Ipv4Address_Type, &group, &inputInterface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->RemoveMulticastRoute(*((PyNs3Ipv4Address *) origin)->obj, *((PyNs3Ipv4Address *) group)->obj, inputInterface);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4StaticRouting_RemoveMulticastRoute__1(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    unsigned int index;
    const char *keywords[] = {"index", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->RemoveMulticastRoute(index);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv4StaticRouting_RemoveMulticastRoute(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4StaticRouting_RemoveMulticastRoute__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4StaticRouting_RemoveMulticastRoute__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_NotifyInterfaceUp(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceUp(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_NotifyInterfaceDown(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceDown(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_SetIpv4(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    const char *keywords[] = {"ipv4", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4_Type, &ipv4)) {
        return NULL;
    }
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    self->obj->SetIpv4(ns3::Ptr< ns3::Ipv4  > (ipv4_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_GetNRoutes(PyNs3Ipv4StaticRouting *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNRoutes();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv4StaticRouting_AddHostRouteTo__0(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *dest;
    PyNs3Ipv4Address *nextHop;
    unsigned int interface;
    unsigned int metric = 0;
    const char *keywords[] = {"dest", "nextHop", "interface", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I|I", (char **) keywords, &PyNs3Ipv4Address_Type, &dest, &PyNs3Ipv4Address_Type, &nextHop, &interface, &metric)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddHostRouteTo(*((PyNs3Ipv4Address *) dest)->obj, *((PyNs3Ipv4Address *) nextHop)->obj, interface, metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4StaticRouting_AddHostRouteTo__1(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *dest;
    unsigned int interface;
    unsigned int metric = 0;
    const char *keywords[] = {"dest", "interface", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I|I", (char **) keywords, &PyNs3Ipv4Address_Type, &dest, &interface, &metric)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddHostRouteTo(*((PyNs3Ipv4Address *) dest)->obj, interface, metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv4StaticRouting_AddHostRouteTo(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4StaticRouting_AddHostRouteTo__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4StaticRouting_AddHostRouteTo__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_GetMulticastRoute(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    PyNs3Ipv4MulticastRoutingTableEntry *py_Ipv4MulticastRoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    ns3::Ipv4MulticastRoutingTableEntry retval = self->obj->GetMulticastRoute(i);
    py_Ipv4MulticastRoutingTableEntry = PyObject_New(PyNs3Ipv4MulticastRoutingTableEntry, &PyNs3Ipv4MulticastRoutingTableEntry_Type);
    py_Ipv4MulticastRoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4MulticastRoutingTableEntry->obj = new ns3::Ipv4MulticastRoutingTableEntry(retval);
    PyNs3Ipv4MulticastRoutingTableEntry_wrapper_registry[(void *) py_Ipv4MulticastRoutingTableEntry->obj] = (PyObject *) py_Ipv4MulticastRoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4MulticastRoutingTableEntry);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_AddMulticastRoute(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *origin;
    PyNs3Ipv4Address *group;
    unsigned int inputInterface;
    std::vector< unsigned int > outputInterfaces_value;
    const char *keywords[] = {"origin", "group", "inputInterface", "outputInterfaces", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!IO&", (char **) keywords, &PyNs3Ipv4Address_Type, &origin, &PyNs3Ipv4Address_Type, &group, &inputInterface, _wrap_convert_py2c__std__vector__lt___unsigned_int___gt__, &outputInterfaces_value)) {
        return NULL;
    }
    self->obj->AddMulticastRoute(*((PyNs3Ipv4Address *) origin)->obj, *((PyNs3Ipv4Address *) group)->obj, inputInterface, outputInterfaces_value);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv4StaticRouting_AddNetworkRouteTo__0(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *network;
    PyNs3Ipv4Mask *networkMask;
    PyNs3Ipv4Address *nextHop;
    unsigned int interface;
    unsigned int metric = 0;
    const char *keywords[] = {"network", "networkMask", "nextHop", "interface", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!I|I", (char **) keywords, &PyNs3Ipv4Address_Type, &network, &PyNs3Ipv4Mask_Type, &networkMask, &PyNs3Ipv4Address_Type, &nextHop, &interface, &metric)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddNetworkRouteTo(*((PyNs3Ipv4Address *) network)->obj, *((PyNs3Ipv4Mask *) networkMask)->obj, *((PyNs3Ipv4Address *) nextHop)->obj, interface, metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4StaticRouting_AddNetworkRouteTo__1(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *network;
    PyNs3Ipv4Mask *networkMask;
    unsigned int interface;
    unsigned int metric = 0;
    const char *keywords[] = {"network", "networkMask", "interface", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I|I", (char **) keywords, &PyNs3Ipv4Address_Type, &network, &PyNs3Ipv4Mask_Type, &networkMask, &interface, &metric)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddNetworkRouteTo(*((PyNs3Ipv4Address *) network)->obj, *((PyNs3Ipv4Mask *) networkMask)->obj, interface, metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv4StaticRouting_AddNetworkRouteTo(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4StaticRouting_AddNetworkRouteTo__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4StaticRouting_AddNetworkRouteTo__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_GetNMulticastRoutes(PyNs3Ipv4StaticRouting *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNMulticastRoutes();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_RouteOutput(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4Route > retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv4Header *header;
    PyNs3NetDevice *oif;
    ns3::NetDevice *oif_ptr;
    ns3::Socket::SocketErrno  sockerr;
    const char *keywords[] = {"p", "header", "oif", "sockerr", NULL};
    PyNs3Ipv4Route *py_Ipv4Route;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!i", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv4Header_Type, &header, &PyNs3NetDevice_Type, &oif, &sockerr)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    oif_ptr = (oif ? oif->obj : NULL);
    retval = self->obj->RouteOutput(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv4Header *) header)->obj, ns3::Ptr< ns3::NetDevice  > (oif_ptr), sockerr);
    if (!(const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Ipv4Route = NULL;
    } else {
        py_Ipv4Route = (PyNs3Ipv4Route *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4Route);
    }
    
    if (py_Ipv4Route == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4Route_Type);
        py_Ipv4Route = PyObject_New(PyNs3Ipv4Route, wrapper_type);
        py_Ipv4Route->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4Route->obj = const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Ipv4Route->obj] = (PyObject *) py_Ipv4Route;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Route);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_GetMetric(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    unsigned int index;
    const char *keywords[] = {"index", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    retval = self->obj->GetMetric(index);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_GetRoute(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    PyNs3Ipv4RoutingTableEntry *py_Ipv4RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    ns3::Ipv4RoutingTableEntry retval = self->obj->GetRoute(i);
    py_Ipv4RoutingTableEntry = PyObject_New(PyNs3Ipv4RoutingTableEntry, &PyNs3Ipv4RoutingTableEntry_Type);
    py_Ipv4RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4RoutingTableEntry->obj = new ns3::Ipv4RoutingTableEntry(retval);
    PyNs3Ipv4RoutingTableEntry_wrapper_registry[(void *) py_Ipv4RoutingTableEntry->obj] = (PyObject *) py_Ipv4RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingTableEntry);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_SetDefaultMulticastRoute(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int outputInterface;
    const char *keywords[] = {"outputInterface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &outputInterface)) {
        return NULL;
    }
    self->obj->SetDefaultMulticastRoute(outputInterface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_GetDefaultRoute(PyNs3Ipv4StaticRouting *self)
{
    PyObject *py_retval;
    PyNs3Ipv4RoutingTableEntry *py_Ipv4RoutingTableEntry;
    
    ns3::Ipv4RoutingTableEntry retval = self->obj->GetDefaultRoute();
    py_Ipv4RoutingTableEntry = PyObject_New(PyNs3Ipv4RoutingTableEntry, &PyNs3Ipv4RoutingTableEntry_Type);
    py_Ipv4RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4RoutingTableEntry->obj = new ns3::Ipv4RoutingTableEntry(retval);
    PyNs3Ipv4RoutingTableEntry_wrapper_registry[(void *) py_Ipv4RoutingTableEntry->obj] = (PyObject *) py_Ipv4RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingTableEntry);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_SetDefaultRoute(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *nextHop;
    unsigned int interface;
    unsigned int metric = 0;
    const char *keywords[] = {"nextHop", "interface", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I|I", (char **) keywords, &PyNs3Ipv4Address_Type, &nextHop, &interface, &metric)) {
        return NULL;
    }
    self->obj->SetDefaultRoute(*((PyNs3Ipv4Address *) nextHop)->obj, interface, metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_PrintRoutingTable(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTable(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_RemoveRoute(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    self->obj->RemoveRoute(i);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv4StaticRouting::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4StaticRouting_NotifyRemoveAddress(PyNs3Ipv4StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv4InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv4InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyRemoveAddress(interface, *((PyNs3Ipv4InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4StaticRouting__copy__(PyNs3Ipv4StaticRouting *self)
{

    PyNs3Ipv4StaticRouting *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv4StaticRouting, &PyNs3Ipv4StaticRouting_Type);
    py_copy->obj = new ns3::Ipv4StaticRouting(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4StaticRouting_methods[] = {
    {(char *) "NotifyAddAddress", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_NotifyAddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RemoveMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_RemoveMulticastRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceUp", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_NotifyInterfaceUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceDown", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_NotifyInterfaceDown, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetIpv4", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_SetIpv4, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNRoutes", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_GetNRoutes, METH_NOARGS, NULL },
    {(char *) "AddHostRouteTo", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_AddHostRouteTo, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_GetMulticastRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_AddMulticastRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddNetworkRouteTo", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_AddNetworkRouteTo, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNMulticastRoutes", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_GetNMulticastRoutes, METH_NOARGS, NULL },
    {(char *) "RouteOutput", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_RouteOutput, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMetric", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_GetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetRoute", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_GetRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDefaultMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_SetDefaultMulticastRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDefaultRoute", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_GetDefaultRoute, METH_NOARGS, NULL },
    {(char *) "SetDefaultRoute", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_SetDefaultRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTable", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_PrintRoutingTable, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RemoveRoute", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_RemoveRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "NotifyRemoveAddress", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting_NotifyRemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4StaticRouting__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4StaticRouting__tp_clear(PyNs3Ipv4StaticRouting *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv4StaticRouting *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv4StaticRouting__tp_traverse(PyNs3Ipv4StaticRouting *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv4StaticRouting__tp_dealloc(PyNs3Ipv4StaticRouting *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4StaticRouting__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4StaticRouting__tp_richcompare (PyNs3Ipv4StaticRouting *PYBINDGEN_UNUSED(self), PyNs3Ipv4StaticRouting *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4StaticRouting_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4StaticRouting_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4StaticRouting",            /* tp_name */
    sizeof(PyNs3Ipv4StaticRouting),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4StaticRouting__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4StaticRouting__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4StaticRouting__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4StaticRouting__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4StaticRouting_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4StaticRouting, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4StaticRouting__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3Ipv6__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3Ipv6 *self)
{
    PyObject *py_retval;
    PyNs3Ipv6__PythonHelper *helper = dynamic_cast< PyNs3Ipv6__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6__PythonHelper::_wrap_NotifyNewAggregate(PyNs3Ipv6 *self)
{
    PyObject *py_retval;
    PyNs3Ipv6__PythonHelper *helper = dynamic_cast< PyNs3Ipv6__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6__PythonHelper::_wrap_DoStart(PyNs3Ipv6 *self)
{
    PyObject *py_retval;
    PyNs3Ipv6__PythonHelper *helper = dynamic_cast< PyNs3Ipv6__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6__PythonHelper::_wrap_DoDispose(PyNs3Ipv6 *self)
{
    PyObject *py_retval;
    PyNs3Ipv6__PythonHelper *helper = dynamic_cast< PyNs3Ipv6__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

bool
PyNs3Ipv6__PythonHelper::AddAddress(uint32_t interface, ns3::Ipv6InterfaceAddress address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv6InterfaceAddress *py_Ipv6InterfaceAddress;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "AddAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = (ns3::Ipv6*) this;
    py_Ipv6InterfaceAddress = PyObject_New(PyNs3Ipv6InterfaceAddress, &PyNs3Ipv6InterfaceAddress_Type);
    py_Ipv6InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6InterfaceAddress->obj = new ns3::Ipv6InterfaceAddress(address);
    PyNs3Ipv6InterfaceAddress_wrapper_registry[(void *) py_Ipv6InterfaceAddress->obj] = (PyObject *) py_Ipv6InterfaceAddress;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "AddAddress", (char *) "NN", PyLong_FromUnsignedLong(interface), py_Ipv6InterfaceAddress);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv6__PythonHelper::AddInterface(ns3::Ptr< ns3::NetDevice > device)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "AddInterface"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = (ns3::Ipv6*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "AddInterface", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ipv6InterfaceAddress
PyNs3Ipv6__PythonHelper::GetAddress(uint32_t interface, uint32_t addressIndex) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv6InterfaceAddress *tmp_Ipv6InterfaceAddress;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6InterfaceAddress();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = const_cast< ns3::Ipv6* >((const ns3::Ipv6*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetAddress", (char *) "NN", PyLong_FromUnsignedLong(interface), PyLong_FromUnsignedLong(addressIndex));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6InterfaceAddress();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv6InterfaceAddress_Type, &tmp_Ipv6InterfaceAddress)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6InterfaceAddress();
    }
    ns3::Ipv6InterfaceAddress retval = *tmp_Ipv6InterfaceAddress->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3Ipv6__PythonHelper::GetInterfaceForAddress(ns3::Ipv6Address address) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInterfaceForAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = const_cast< ns3::Ipv6* >((const ns3::Ipv6*) this);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(address);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInterfaceForAddress", (char *) "N", py_Ipv6Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3Ipv6__PythonHelper::GetInterfaceForDevice(ns3::Ptr< ns3::NetDevice const > device) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInterfaceForDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = const_cast< ns3::Ipv6* >((const ns3::Ipv6*) this);
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInterfaceForDevice", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3Ipv6__PythonHelper::GetInterfaceForPrefix(ns3::Ipv6Address address, ns3::Ipv6Prefix mask) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    PyNs3Ipv6Prefix *py_Ipv6Prefix;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInterfaceForPrefix"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = const_cast< ns3::Ipv6* >((const ns3::Ipv6*) this);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(address);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_Ipv6Prefix = PyObject_New(PyNs3Ipv6Prefix, &PyNs3Ipv6Prefix_Type);
    py_Ipv6Prefix->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Prefix->obj = new ns3::Ipv6Prefix(mask);
    PyNs3Ipv6Prefix_wrapper_registry[(void *) py_Ipv6Prefix->obj] = (PyObject *) py_Ipv6Prefix;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInterfaceForPrefix", (char *) "NN", py_Ipv6Address, py_Ipv6Prefix);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint16_t
PyNs3Ipv6__PythonHelper::GetMetric(uint32_t interface) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    uint16_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetMetric"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = const_cast< ns3::Ipv6* >((const ns3::Ipv6*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetMetric", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    if (tmp > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint16_t
PyNs3Ipv6__PythonHelper::GetMtu(uint32_t interface) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    uint16_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetMtu"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = const_cast< ns3::Ipv6* >((const ns3::Ipv6*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetMtu", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    if (tmp > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv6__PythonHelper::GetNAddresses(uint32_t interface) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNAddresses"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = const_cast< ns3::Ipv6* >((const ns3::Ipv6*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNAddresses", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv6__PythonHelper::GetNInterfaces() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNInterfaces"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = const_cast< ns3::Ipv6* >((const ns3::Ipv6*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNInterfaces", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::NetDevice >
PyNs3Ipv6__PythonHelper::GetNetDevice(uint32_t interface)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *tmp_NetDevice;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = (ns3::Ipv6*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNetDevice", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3NetDevice_Type, &tmp_NetDevice)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::NetDevice  > (tmp_NetDevice->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Ipv6RoutingProtocol >
PyNs3Ipv6__PythonHelper::GetRoutingProtocol() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6RoutingProtocol > retval;
    PyNs3Ipv6RoutingProtocol *tmp_Ipv6RoutingProtocol;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetRoutingProtocol"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = const_cast< ns3::Ipv6* >((const ns3::Ipv6*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetRoutingProtocol", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv6RoutingProtocol_Type, &tmp_Ipv6RoutingProtocol)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Ipv6RoutingProtocol  > (tmp_Ipv6RoutingProtocol->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv6__PythonHelper::IsForwarding(uint32_t interface) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsForwarding"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = const_cast< ns3::Ipv6* >((const ns3::Ipv6*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsForwarding", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv6__PythonHelper::IsUp(uint32_t interface) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsUp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = const_cast< ns3::Ipv6* >((const ns3::Ipv6*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsUp", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6__PythonHelper::RegisterExtensions()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "RegisterExtensions"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = (ns3::Ipv6*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "RegisterExtensions", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6__PythonHelper::RegisterOptions()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "RegisterOptions"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = (ns3::Ipv6*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "RegisterOptions", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3Ipv6__PythonHelper::RemoveAddress(uint32_t interface, uint32_t addressIndex)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "RemoveAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = (ns3::Ipv6*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "RemoveAddress", (char *) "NN", PyLong_FromUnsignedLong(interface), PyLong_FromUnsignedLong(addressIndex));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6__PythonHelper::SetDown(uint32_t interface)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetDown"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = (ns3::Ipv6*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetDown", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6__PythonHelper::SetForwarding(uint32_t interface, bool val)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetForwarding"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = (ns3::Ipv6*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetForwarding", (char *) "NN", PyLong_FromUnsignedLong(interface), PyBool_FromLong(val));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6__PythonHelper::SetMetric(uint32_t interface, uint16_t metric)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetMetric"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = (ns3::Ipv6*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetMetric", (char *) "Ni", PyLong_FromUnsignedLong(interface), (int) metric);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6__PythonHelper::SetRoutingProtocol(ns3::Ptr< ns3::Ipv6RoutingProtocol > routingProtocol)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv6RoutingProtocol *py_Ipv6RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetRoutingProtocol"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = (ns3::Ipv6*) this;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (routingProtocol)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv6RoutingProtocol = NULL;
    } else {
        py_Ipv6RoutingProtocol = (PyNs3Ipv6RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6RoutingProtocol);
    }
    
    if (py_Ipv6RoutingProtocol == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (routingProtocol))), &PyNs3Ipv6RoutingProtocol_Type);
        py_Ipv6RoutingProtocol = PyObject_GC_New(PyNs3Ipv6RoutingProtocol, wrapper_type);
        py_Ipv6RoutingProtocol->inst_dict = NULL;
        py_Ipv6RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (routingProtocol))->Ref();
        py_Ipv6RoutingProtocol->obj = const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (routingProtocol));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6RoutingProtocol->obj] = (PyObject *) py_Ipv6RoutingProtocol;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetRoutingProtocol", (char *) "N", py_Ipv6RoutingProtocol);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6__PythonHelper::SetUp(uint32_t interface)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetUp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = (ns3::Ipv6*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetUp", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3Ipv6__PythonHelper::GetIpForward() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetIpForward"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = const_cast< ns3::Ipv6* >((const ns3::Ipv6*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetIpForward", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6__PythonHelper::SetIpForward(bool forward)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6 *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetIpForward"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = (ns3::Ipv6*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetIpForward", (char *) "N", PyBool_FromLong(forward));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3Ipv6__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}
static PyObject* _wrap_PyNs3Ipv6__get_IF_ANY(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(ns3::Ipv6::IF_ANY));
    return py_retval;
}
static PyGetSetDef Ns3Ipv6Meta__getsets[] = {
    {
        (char*) "IF_ANY", /* attribute name */
        (getter) _wrap_PyNs3Ipv6__get_IF_ANY, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv6Meta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv6Meta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv6Meta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Ipv6__tp_init__0(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6 *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv6_Type)
    {
        self->obj = new PyNs3Ipv6__PythonHelper(*((PyNs3Ipv6 *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv6__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'Ipv6' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3Ipv6__tp_init__1(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv6_Type)
    {
        self->obj = new PyNs3Ipv6__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv6__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'Ipv6' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3Ipv6__tp_init(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6_GetInterfaceForAddress(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv6Address *address;
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &address)) {
        return NULL;
    }
    retval = self->obj->GetInterfaceForAddress(*((PyNs3Ipv6Address *) address)->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_GetNInterfaces(PyNs3Ipv6 *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNInterfaces();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_SetMetric(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    int metric;
    const char *keywords[] = {"interface", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "Ii", (char **) keywords, &interface, &metric)) {
        return NULL;
    }
    if (metric > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetMetric(interface, metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_GetInterfaceForDevice(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    const char *keywords[] = {"device", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &device)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    retval = self->obj->GetInterfaceForDevice(ns3::Ptr< ns3::NetDevice  > (device_ptr));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_GetMetric(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint16_t retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = self->obj->GetMetric(interface);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_SetDown(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->SetDown(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_RegisterOptions(PyNs3Ipv6 *self)
{
    PyObject *py_retval;
    
    self->obj->RegisterOptions();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_AddInterface(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    const char *keywords[] = {"device", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &device)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    retval = self->obj->AddInterface(ns3::Ptr< ns3::NetDevice  > (device_ptr));
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_SetForwarding(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    bool val;
    PyObject *py_val;
    const char *keywords[] = {"interface", "val", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO", (char **) keywords, &interface, &py_val)) {
        return NULL;
    }
    val = (bool) PyObject_IsTrue(py_val);
    self->obj->SetForwarding(interface, val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_RegisterExtensions(PyNs3Ipv6 *self)
{
    PyObject *py_retval;
    
    self->obj->RegisterExtensions();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_GetNAddresses(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = self->obj->GetNAddresses(interface);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_GetMtu(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint16_t retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = self->obj->GetMtu(interface);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_SetRoutingProtocol(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6RoutingProtocol *routingProtocol;
    ns3::Ipv6RoutingProtocol *routingProtocol_ptr;
    const char *keywords[] = {"routingProtocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6RoutingProtocol_Type, &routingProtocol)) {
        return NULL;
    }
    routingProtocol_ptr = (routingProtocol ? routingProtocol->obj : NULL);
    self->obj->SetRoutingProtocol(ns3::Ptr< ns3::Ipv6RoutingProtocol  > (routingProtocol_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_AddAddress(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int interface;
    PyNs3Ipv6InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv6InterfaceAddress_Type, &address)) {
        return NULL;
    }
    retval = self->obj->AddAddress(interface, *((PyNs3Ipv6InterfaceAddress *) address)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_IsForwarding(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = self->obj->IsForwarding(interface);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_GetAddress(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    unsigned int addressIndex;
    const char *keywords[] = {"interface", "addressIndex", NULL};
    PyNs3Ipv6InterfaceAddress *py_Ipv6InterfaceAddress;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &interface, &addressIndex)) {
        return NULL;
    }
    ns3::Ipv6InterfaceAddress retval = self->obj->GetAddress(interface, addressIndex);
    py_Ipv6InterfaceAddress = PyObject_New(PyNs3Ipv6InterfaceAddress, &PyNs3Ipv6InterfaceAddress_Type);
    py_Ipv6InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6InterfaceAddress->obj = new ns3::Ipv6InterfaceAddress(retval);
    PyNs3Ipv6InterfaceAddress_wrapper_registry[(void *) py_Ipv6InterfaceAddress->obj] = (PyObject *) py_Ipv6InterfaceAddress;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6InterfaceAddress);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_GetInterfaceForPrefix(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv6Address *address;
    PyNs3Ipv6Prefix *mask;
    const char *keywords[] = {"address", "mask", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv6Address_Type, &address, &PyNs3Ipv6Prefix_Type, &mask)) {
        return NULL;
    }
    retval = self->obj->GetInterfaceForPrefix(*((PyNs3Ipv6Address *) address)->obj, *((PyNs3Ipv6Prefix *) mask)->obj);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_GetNetDevice(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = self->obj->GetNetDevice(interface);
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_GetRoutingProtocol(PyNs3Ipv6 *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6RoutingProtocol > retval;
    PyNs3Ipv6RoutingProtocol *py_Ipv6RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetRoutingProtocol();
    if (!(const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv6RoutingProtocol = NULL;
    } else {
        py_Ipv6RoutingProtocol = (PyNs3Ipv6RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6RoutingProtocol);
    }
    
    if (py_Ipv6RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6RoutingProtocol_Type);
        py_Ipv6RoutingProtocol = PyObject_GC_New(PyNs3Ipv6RoutingProtocol, wrapper_type);
        py_Ipv6RoutingProtocol->inst_dict = NULL;
        py_Ipv6RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv6RoutingProtocol->obj = const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6RoutingProtocol->obj] = (PyObject *) py_Ipv6RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingProtocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_RemoveAddress(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int interface;
    unsigned int addressIndex;
    const char *keywords[] = {"interface", "addressIndex", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &interface, &addressIndex)) {
        return NULL;
    }
    retval = self->obj->RemoveAddress(interface, addressIndex);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_SetUp(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->SetUp(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6_IsUp(PyNs3Ipv6 *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = self->obj->IsUp(interface);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

static PyMethodDef PyNs3Ipv6_methods[] = {
    {(char *) "GetInterfaceForAddress", (PyCFunction) _wrap_PyNs3Ipv6_GetInterfaceForAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNInterfaces", (PyCFunction) _wrap_PyNs3Ipv6_GetNInterfaces, METH_NOARGS, NULL },
    {(char *) "SetMetric", (PyCFunction) _wrap_PyNs3Ipv6_SetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInterfaceForDevice", (PyCFunction) _wrap_PyNs3Ipv6_GetInterfaceForDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetMetric", (PyCFunction) _wrap_PyNs3Ipv6_GetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDown", (PyCFunction) _wrap_PyNs3Ipv6_SetDown, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RegisterOptions", (PyCFunction) _wrap_PyNs3Ipv6_RegisterOptions, METH_NOARGS, NULL },
    {(char *) "AddInterface", (PyCFunction) _wrap_PyNs3Ipv6_AddInterface, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetForwarding", (PyCFunction) _wrap_PyNs3Ipv6_SetForwarding, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RegisterExtensions", (PyCFunction) _wrap_PyNs3Ipv6_RegisterExtensions, METH_NOARGS, NULL },
    {(char *) "GetNAddresses", (PyCFunction) _wrap_PyNs3Ipv6_GetNAddresses, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMtu", (PyCFunction) _wrap_PyNs3Ipv6_GetMtu, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRoutingProtocol", (PyCFunction) _wrap_PyNs3Ipv6_SetRoutingProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddAddress", (PyCFunction) _wrap_PyNs3Ipv6_AddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsForwarding", (PyCFunction) _wrap_PyNs3Ipv6_IsForwarding, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv6_GetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInterfaceForPrefix", (PyCFunction) _wrap_PyNs3Ipv6_GetInterfaceForPrefix, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNetDevice", (PyCFunction) _wrap_PyNs3Ipv6_GetNetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetRoutingProtocol", (PyCFunction) _wrap_PyNs3Ipv6_GetRoutingProtocol, METH_NOARGS, NULL },
    {(char *) "RemoveAddress", (PyCFunction) _wrap_PyNs3Ipv6_RemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetUp", (PyCFunction) _wrap_PyNs3Ipv6_SetUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsUp", (PyCFunction) _wrap_PyNs3Ipv6_IsUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3Ipv6__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3Ipv6__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3Ipv6__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "DoDispose", (PyCFunction) PyNs3Ipv6__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6__tp_clear(PyNs3Ipv6 *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6 *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6__tp_traverse(PyNs3Ipv6 *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3Ipv6__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3Ipv6__tp_dealloc(PyNs3Ipv6 *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6__tp_richcompare (PyNs3Ipv6 *PYBINDGEN_UNUSED(self), PyNs3Ipv6 *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6",            /* tp_name */
    sizeof(PyNs3Ipv6),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyNs3Ipv6Extension__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'Ipv6Extension' cannot be constructed (have pure virtual methods but no helper class)");
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6Extension_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6Extension::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Extension_GetNode(PyNs3Ipv6Extension *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3Node *py_Node;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetNode();
    if (!(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Node__PythonHelper).name())
    {
        py_Node = reinterpret_cast< PyNs3Node* >(reinterpret_cast< PyNs3Node__PythonHelper* >(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Node);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Node *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Node = NULL;
        } else {
            py_Node = (PyNs3Node *) wrapper_lookup_iter->second;
            Py_INCREF(py_Node);
        }
    
        if (py_Node == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))), &PyNs3Node_Type);
            py_Node = PyObject_GC_New(PyNs3Node, wrapper_type);
            py_Node->inst_dict = NULL;
            py_Node->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Node *> (ns3::PeekPointer (retval))->Ref();
            py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Node->obj] = (PyObject *) py_Node;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Node);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Extension_SetNode(PyNs3Ipv6Extension *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Extension_GetExtensionNumber(PyNs3Ipv6Extension *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetExtensionNumber();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Extension_AssignStreams(PyNs3Ipv6Extension *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int64_t retval;
    int64_t stream;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "L", (char **) keywords, &stream)) {
        return NULL;
    }
    retval = self->obj->AssignStreams(stream);
    py_retval = Py_BuildValue((char *) "L", retval);
    return py_retval;
}

static PyMethodDef PyNs3Ipv6Extension_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6Extension_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetNode", (PyCFunction) _wrap_PyNs3Ipv6Extension_GetNode, METH_NOARGS, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3Ipv6Extension_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetExtensionNumber", (PyCFunction) _wrap_PyNs3Ipv6Extension_GetExtensionNumber, METH_NOARGS, NULL },
    {(char *) "AssignStreams", (PyCFunction) _wrap_PyNs3Ipv6Extension_AssignStreams, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6Extension__tp_clear(PyNs3Ipv6Extension *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6Extension *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6Extension__tp_traverse(PyNs3Ipv6Extension *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6Extension__tp_dealloc(PyNs3Ipv6Extension *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6Extension__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6Extension__tp_richcompare (PyNs3Ipv6Extension *PYBINDGEN_UNUSED(self), PyNs3Ipv6Extension *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6Extension_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6Extension_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6Extension",            /* tp_name */
    sizeof(PyNs3Ipv6Extension),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6Extension__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6Extension__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6Extension__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6Extension__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6Extension_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6Extension, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6Extension__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3Ipv6ExtensionAH__get_EXT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Ipv6ExtensionAH::EXT_NUMBER);
    return py_retval;
}
static PyGetSetDef Ns3Ipv6ExtensionAHMeta__getsets[] = {
    {
        (char*) "EXT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3Ipv6ExtensionAH__get_EXT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv6ExtensionAHMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv6ExtensionAHMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv6ExtensionAHMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Ipv6ExtensionAH__tp_init__0(PyNs3Ipv6ExtensionAH *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionAH *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionAH_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionAH(*((PyNs3Ipv6ExtensionAH *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionAH__tp_init__1(PyNs3Ipv6ExtensionAH *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionAH();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionAH__tp_init(PyNs3Ipv6ExtensionAH *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionAH__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionAH__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionAH_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionAH::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionAH_GetExtensionNumber(PyNs3Ipv6ExtensionAH *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetExtensionNumber();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionAH__copy__(PyNs3Ipv6ExtensionAH *self)
{

    PyNs3Ipv6ExtensionAH *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionAH, &PyNs3Ipv6ExtensionAH_Type);
    py_copy->obj = new ns3::Ipv6ExtensionAH(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionAH_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionAH_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetExtensionNumber", (PyCFunction) _wrap_PyNs3Ipv6ExtensionAH_GetExtensionNumber, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionAH__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionAH__tp_clear(PyNs3Ipv6ExtensionAH *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6ExtensionAH *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6ExtensionAH__tp_traverse(PyNs3Ipv6ExtensionAH *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionAH__tp_dealloc(PyNs3Ipv6ExtensionAH *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionAH__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionAH__tp_richcompare (PyNs3Ipv6ExtensionAH *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionAH *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionAH_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionAH_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionAH",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionAH),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionAH__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionAH__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionAH__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionAH__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionAH_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionAH, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionAH__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6ExtensionAHHeader__tp_init__0(PyNs3Ipv6ExtensionAHHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionAHHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionAHHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionAHHeader(*((PyNs3Ipv6ExtensionAHHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionAHHeader__tp_init__1(PyNs3Ipv6ExtensionAHHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionAHHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionAHHeader__tp_init(PyNs3Ipv6ExtensionAHHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionAHHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionAHHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionAHHeader_GetSerializedSize(PyNs3Ipv6ExtensionAHHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionAHHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionAHHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionAHHeader_Serialize(PyNs3Ipv6ExtensionAHHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionAHHeader_Deserialize(PyNs3Ipv6ExtensionAHHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionAHHeader_GetInstanceTypeId(PyNs3Ipv6ExtensionAHHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionAHHeader__copy__(PyNs3Ipv6ExtensionAHHeader *self)
{

    PyNs3Ipv6ExtensionAHHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionAHHeader, &PyNs3Ipv6ExtensionAHHeader_Type);
    py_copy->obj = new ns3::Ipv6ExtensionAHHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionAHHeader_methods[] = {
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionAHHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionAHHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionAHHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionAHHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionAHHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionAHHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionAHHeader__tp_clear(PyNs3Ipv6ExtensionAHHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6ExtensionAHHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6ExtensionAHHeader__tp_traverse(PyNs3Ipv6ExtensionAHHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionAHHeader__tp_dealloc(PyNs3Ipv6ExtensionAHHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionAHHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionAHHeader__tp_richcompare (PyNs3Ipv6ExtensionAHHeader *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionAHHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionAHHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionAHHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionAHHeader",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionAHHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionAHHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionAHHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionAHHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionAHHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionAHHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionAHHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionAHHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3Ipv6ExtensionDemux__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3Ipv6ExtensionDemux *self)
{
    PyObject *py_retval;
    PyNs3Ipv6ExtensionDemux__PythonHelper *helper = dynamic_cast< PyNs3Ipv6ExtensionDemux__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6ExtensionDemux__PythonHelper::_wrap_NotifyNewAggregate(PyNs3Ipv6ExtensionDemux *self)
{
    PyObject *py_retval;
    PyNs3Ipv6ExtensionDemux__PythonHelper *helper = dynamic_cast< PyNs3Ipv6ExtensionDemux__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6ExtensionDemux__PythonHelper::_wrap_DoStart(PyNs3Ipv6ExtensionDemux *self)
{
    PyObject *py_retval;
    PyNs3Ipv6ExtensionDemux__PythonHelper *helper = dynamic_cast< PyNs3Ipv6ExtensionDemux__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6ExtensionDemux__PythonHelper::_wrap_DoDispose(PyNs3Ipv6ExtensionDemux *self)
{
    PyObject *py_retval;
    PyNs3Ipv6ExtensionDemux__PythonHelper *helper = dynamic_cast< PyNs3Ipv6ExtensionDemux__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Ipv6ExtensionDemux is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

void
PyNs3Ipv6ExtensionDemux__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6ExtensionDemux *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv6ExtensionDemux::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6ExtensionDemux* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6ExtensionDemux* >(m_pyself)->obj = (ns3::Ipv6ExtensionDemux*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6ExtensionDemux* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6ExtensionDemux* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6ExtensionDemux* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3Ipv6ExtensionDemux__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6ExtensionDemux__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6ExtensionDemux__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6ExtensionDemux__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3Ipv6ExtensionDemux__tp_init__0(PyNs3Ipv6ExtensionDemux *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionDemux *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionDemux_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv6ExtensionDemux_Type)
    {
        self->obj = new PyNs3Ipv6ExtensionDemux__PythonHelper(*((PyNs3Ipv6ExtensionDemux *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv6ExtensionDemux__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::Ipv6ExtensionDemux(*((PyNs3Ipv6ExtensionDemux *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionDemux__tp_init__1(PyNs3Ipv6ExtensionDemux *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv6ExtensionDemux_Type)
    {
        self->obj = new PyNs3Ipv6ExtensionDemux__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv6ExtensionDemux__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::Ipv6ExtensionDemux();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionDemux__tp_init(PyNs3Ipv6ExtensionDemux *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionDemux__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionDemux__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionDemux_Insert(PyNs3Ipv6ExtensionDemux *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Extension *extension;
    ns3::Ipv6Extension *extension_ptr;
    const char *keywords[] = {"extension", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Extension_Type, &extension)) {
        return NULL;
    }
    extension_ptr = (extension ? extension->obj : NULL);
    self->obj->Insert(ns3::Ptr< ns3::Ipv6Extension  > (extension_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionDemux_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionDemux::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionDemux_SetNode(PyNs3Ipv6ExtensionDemux *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionDemux_Remove(PyNs3Ipv6ExtensionDemux *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Extension *extension;
    ns3::Ipv6Extension *extension_ptr;
    const char *keywords[] = {"extension", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Extension_Type, &extension)) {
        return NULL;
    }
    extension_ptr = (extension ? extension->obj : NULL);
    self->obj->Remove(ns3::Ptr< ns3::Ipv6Extension  > (extension_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionDemux_GetExtension(PyNs3Ipv6ExtensionDemux *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6Extension > retval;
    int extensionNumber;
    const char *keywords[] = {"extensionNumber", NULL};
    PyNs3Ipv6Extension *py_Ipv6Extension;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &extensionNumber)) {
        return NULL;
    }
    if (extensionNumber > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    retval = self->obj->GetExtension(extensionNumber);
    if (!(const_cast<ns3::Ipv6Extension *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6Extension *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv6Extension = NULL;
    } else {
        py_Ipv6Extension = (PyNs3Ipv6Extension *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6Extension);
    }
    
    if (py_Ipv6Extension == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6Extension *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6Extension_Type);
        py_Ipv6Extension = PyObject_GC_New(PyNs3Ipv6Extension, wrapper_type);
        py_Ipv6Extension->inst_dict = NULL;
        py_Ipv6Extension->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6Extension *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv6Extension->obj = const_cast<ns3::Ipv6Extension *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6Extension->obj] = (PyObject *) py_Ipv6Extension;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Extension);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionDemux__copy__(PyNs3Ipv6ExtensionDemux *self)
{

    PyNs3Ipv6ExtensionDemux *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionDemux, &PyNs3Ipv6ExtensionDemux_Type);
    py_copy->obj = new ns3::Ipv6ExtensionDemux(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionDemux_methods[] = {
    {(char *) "Insert", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDemux_Insert, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDemux_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDemux_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Remove", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDemux_Remove, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetExtension", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDemux_GetExtension, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3Ipv6ExtensionDemux__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3Ipv6ExtensionDemux__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3Ipv6ExtensionDemux__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "DoDispose", (PyCFunction) PyNs3Ipv6ExtensionDemux__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDemux__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionDemux__tp_clear(PyNs3Ipv6ExtensionDemux *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6ExtensionDemux *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6ExtensionDemux__tp_traverse(PyNs3Ipv6ExtensionDemux *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3Ipv6ExtensionDemux__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionDemux__tp_dealloc(PyNs3Ipv6ExtensionDemux *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionDemux__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionDemux__tp_richcompare (PyNs3Ipv6ExtensionDemux *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionDemux *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionDemux_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionDemux_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionDemux",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionDemux),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionDemux__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionDemux__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionDemux__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionDemux__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionDemux_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionDemux, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionDemux__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3Ipv6ExtensionDestination__get_EXT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Ipv6ExtensionDestination::EXT_NUMBER);
    return py_retval;
}
static PyGetSetDef Ns3Ipv6ExtensionDestinationMeta__getsets[] = {
    {
        (char*) "EXT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3Ipv6ExtensionDestination__get_EXT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv6ExtensionDestinationMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv6ExtensionDestinationMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv6ExtensionDestinationMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Ipv6ExtensionDestination__tp_init__0(PyNs3Ipv6ExtensionDestination *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionDestination *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionDestination_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionDestination(*((PyNs3Ipv6ExtensionDestination *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionDestination__tp_init__1(PyNs3Ipv6ExtensionDestination *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionDestination();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionDestination__tp_init(PyNs3Ipv6ExtensionDestination *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionDestination__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionDestination__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionDestination_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionDestination::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionDestination_GetExtensionNumber(PyNs3Ipv6ExtensionDestination *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetExtensionNumber();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionDestination__copy__(PyNs3Ipv6ExtensionDestination *self)
{

    PyNs3Ipv6ExtensionDestination *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionDestination, &PyNs3Ipv6ExtensionDestination_Type);
    py_copy->obj = new ns3::Ipv6ExtensionDestination(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionDestination_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestination_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetExtensionNumber", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestination_GetExtensionNumber, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestination__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionDestination__tp_clear(PyNs3Ipv6ExtensionDestination *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6ExtensionDestination *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6ExtensionDestination__tp_traverse(PyNs3Ipv6ExtensionDestination *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionDestination__tp_dealloc(PyNs3Ipv6ExtensionDestination *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionDestination__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionDestination__tp_richcompare (PyNs3Ipv6ExtensionDestination *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionDestination *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionDestination_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionDestination_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionDestination",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionDestination),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionDestination__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionDestination__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionDestination__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionDestination__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionDestination_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionDestination, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionDestination__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6ExtensionDestinationHeader__tp_init__0(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionDestinationHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionDestinationHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionDestinationHeader(*((PyNs3Ipv6ExtensionDestinationHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionDestinationHeader__tp_init__1(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionDestinationHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionDestinationHeader__tp_init(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionDestinationHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionDestinationHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_GetSerializedSize(PyNs3Ipv6ExtensionDestinationHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionDestinationHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_Serialize(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_Deserialize(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_GetInstanceTypeId(PyNs3Ipv6ExtensionDestinationHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_GetOptionsOffset(PyNs3Ipv6ExtensionDestinationHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetOptionsOffset();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_AddOption(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6OptionHeader *option;
    const char *keywords[] = {"option", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6OptionHeader_Type, &option)) {
        return NULL;
    }
    self->obj->AddOption(*((PyNs3Ipv6OptionHeader *) option)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_GetAttribute(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3AttributeValue *value;
    const char *keywords[] = {"name", "value", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3AttributeValue_Type, &value)) {
        return NULL;
    }
    self->obj->GetAttribute(std::string(name, name_len), *((PyNs3AttributeValue *) value)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_GetLength(PyNs3Ipv6ExtensionDestinationHeader *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetLength();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_SetAttribute(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3AttributeValue *value;
    const char *keywords[] = {"name", "value", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3AttributeValue_Type, &value)) {
        return NULL;
    }
    self->obj->SetAttribute(std::string(name, name_len), *((PyNs3AttributeValue *) value)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_GetNextHeader(PyNs3Ipv6ExtensionDestinationHeader *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetNextHeader();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_TraceDisconnect(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    const char *context;
    Py_ssize_t context_len;
    PyNs3CallbackBase *cb;
    const char *keywords[] = {"name", "context", "cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#O!", (char **) keywords, &name, &name_len, &context, &context_len, &PyNs3CallbackBase_Type, &cb)) {
        return NULL;
    }
    retval = self->obj->TraceDisconnect(std::string(name, name_len), std::string(context, context_len), *((PyNs3CallbackBase *) cb)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_TraceDisconnectWithoutContext(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3CallbackBase *cb;
    const char *keywords[] = {"name", "cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3CallbackBase_Type, &cb)) {
        return NULL;
    }
    retval = self->obj->TraceDisconnectWithoutContext(std::string(name, name_len), *((PyNs3CallbackBase *) cb)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_SetNextHeader(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int nextHeader;
    const char *keywords[] = {"nextHeader", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &nextHeader)) {
        return NULL;
    }
    if (nextHeader > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetNextHeader(nextHeader);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_TraceConnect(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    const char *context;
    Py_ssize_t context_len;
    PyNs3CallbackBase *cb;
    const char *keywords[] = {"name", "context", "cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#O!", (char **) keywords, &name, &name_len, &context, &context_len, &PyNs3CallbackBase_Type, &cb)) {
        return NULL;
    }
    retval = self->obj->TraceConnect(std::string(name, name_len), std::string(context, context_len), *((PyNs3CallbackBase *) cb)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_GetOptionBuffer(PyNs3Ipv6ExtensionDestinationHeader *self)
{
    PyObject *py_retval;
    PyNs3Buffer *py_Buffer;
    
    ns3::Buffer retval = self->obj->GetOptionBuffer();
    py_Buffer = PyObject_New(PyNs3Buffer, &PyNs3Buffer_Type);
    py_Buffer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Buffer->obj = new ns3::Buffer(retval);
    PyNs3Buffer_wrapper_registry[(void *) py_Buffer->obj] = (PyObject *) py_Buffer;
    py_retval = Py_BuildValue((char *) "N", py_Buffer);
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_SetAttributeFailSafe(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3AttributeValue *value;
    const char *keywords[] = {"name", "value", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3AttributeValue_Type, &value)) {
        return NULL;
    }
    retval = self->obj->SetAttributeFailSafe(std::string(name, name_len), *((PyNs3AttributeValue *) value)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_TraceConnectWithoutContext(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3CallbackBase *cb;
    const char *keywords[] = {"name", "cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3CallbackBase_Type, &cb)) {
        return NULL;
    }
    retval = self->obj->TraceConnectWithoutContext(std::string(name, name_len), *((PyNs3CallbackBase *) cb)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_SetLength(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int length;
    const char *keywords[] = {"length", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &length)) {
        return NULL;
    }
    if (length > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetLength(length);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6ExtensionDestinationHeader_GetAttributeFailSafe(PyNs3Ipv6ExtensionDestinationHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3AttributeValue *attribute;
    const char *keywords[] = {"name", "attribute", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3AttributeValue_Type, &attribute)) {
        return NULL;
    }
    retval = self->obj->GetAttributeFailSafe(std::string(name, name_len), *((PyNs3AttributeValue *) attribute)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionDestinationHeader__copy__(PyNs3Ipv6ExtensionDestinationHeader *self)
{

    PyNs3Ipv6ExtensionDestinationHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionDestinationHeader, &PyNs3Ipv6ExtensionDestinationHeader_Type);
    py_copy->obj = new ns3::Ipv6ExtensionDestinationHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionDestinationHeader_methods[] = {
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetOptionsOffset", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_GetOptionsOffset, METH_NOARGS, NULL },
    {(char *) "AddOption", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_AddOption, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAttribute", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_GetAttribute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetLength", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_GetLength, METH_NOARGS, NULL },
    {(char *) "SetAttribute", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_SetAttribute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNextHeader", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_GetNextHeader, METH_NOARGS, NULL },
    {(char *) "TraceDisconnect", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_TraceDisconnect, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "TraceDisconnectWithoutContext", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_TraceDisconnectWithoutContext, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNextHeader", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_SetNextHeader, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "TraceConnect", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_TraceConnect, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOptionBuffer", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_GetOptionBuffer, METH_NOARGS, NULL },
    {(char *) "SetAttributeFailSafe", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_SetAttributeFailSafe, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "TraceConnectWithoutContext", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_TraceConnectWithoutContext, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetLength", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_SetLength, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAttributeFailSafe", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader_GetAttributeFailSafe, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionDestinationHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionDestinationHeader__tp_clear(PyNs3Ipv6ExtensionDestinationHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6ExtensionDestinationHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6ExtensionDestinationHeader__tp_traverse(PyNs3Ipv6ExtensionDestinationHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionDestinationHeader__tp_dealloc(PyNs3Ipv6ExtensionDestinationHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionDestinationHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionDestinationHeader__tp_richcompare (PyNs3Ipv6ExtensionDestinationHeader *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionDestinationHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionDestinationHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionDestinationHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionDestinationHeader",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionDestinationHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionDestinationHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionDestinationHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionDestinationHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionDestinationHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionDestinationHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionDestinationHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionDestinationHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3Ipv6ExtensionESP__get_EXT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Ipv6ExtensionESP::EXT_NUMBER);
    return py_retval;
}
static PyGetSetDef Ns3Ipv6ExtensionESPMeta__getsets[] = {
    {
        (char*) "EXT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3Ipv6ExtensionESP__get_EXT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv6ExtensionESPMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv6ExtensionESPMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv6ExtensionESPMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Ipv6ExtensionESP__tp_init__0(PyNs3Ipv6ExtensionESP *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionESP *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionESP_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionESP(*((PyNs3Ipv6ExtensionESP *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionESP__tp_init__1(PyNs3Ipv6ExtensionESP *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionESP();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionESP__tp_init(PyNs3Ipv6ExtensionESP *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionESP__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionESP__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionESP_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionESP::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionESP_GetExtensionNumber(PyNs3Ipv6ExtensionESP *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetExtensionNumber();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionESP__copy__(PyNs3Ipv6ExtensionESP *self)
{

    PyNs3Ipv6ExtensionESP *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionESP, &PyNs3Ipv6ExtensionESP_Type);
    py_copy->obj = new ns3::Ipv6ExtensionESP(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionESP_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionESP_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetExtensionNumber", (PyCFunction) _wrap_PyNs3Ipv6ExtensionESP_GetExtensionNumber, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionESP__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionESP__tp_clear(PyNs3Ipv6ExtensionESP *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6ExtensionESP *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6ExtensionESP__tp_traverse(PyNs3Ipv6ExtensionESP *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionESP__tp_dealloc(PyNs3Ipv6ExtensionESP *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionESP__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionESP__tp_richcompare (PyNs3Ipv6ExtensionESP *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionESP *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionESP_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionESP_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionESP",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionESP),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionESP__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionESP__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionESP__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionESP__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionESP_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionESP, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionESP__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6ExtensionESPHeader__tp_init__0(PyNs3Ipv6ExtensionESPHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionESPHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionESPHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionESPHeader(*((PyNs3Ipv6ExtensionESPHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionESPHeader__tp_init__1(PyNs3Ipv6ExtensionESPHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionESPHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionESPHeader__tp_init(PyNs3Ipv6ExtensionESPHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionESPHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionESPHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionESPHeader_GetSerializedSize(PyNs3Ipv6ExtensionESPHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionESPHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionESPHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionESPHeader_Serialize(PyNs3Ipv6ExtensionESPHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionESPHeader_Deserialize(PyNs3Ipv6ExtensionESPHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionESPHeader_GetInstanceTypeId(PyNs3Ipv6ExtensionESPHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionESPHeader__copy__(PyNs3Ipv6ExtensionESPHeader *self)
{

    PyNs3Ipv6ExtensionESPHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionESPHeader, &PyNs3Ipv6ExtensionESPHeader_Type);
    py_copy->obj = new ns3::Ipv6ExtensionESPHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionESPHeader_methods[] = {
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionESPHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionESPHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionESPHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionESPHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionESPHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionESPHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionESPHeader__tp_clear(PyNs3Ipv6ExtensionESPHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6ExtensionESPHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6ExtensionESPHeader__tp_traverse(PyNs3Ipv6ExtensionESPHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionESPHeader__tp_dealloc(PyNs3Ipv6ExtensionESPHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionESPHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionESPHeader__tp_richcompare (PyNs3Ipv6ExtensionESPHeader *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionESPHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionESPHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionESPHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionESPHeader",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionESPHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionESPHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionESPHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionESPHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionESPHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionESPHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionESPHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionESPHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3Ipv6ExtensionFragment__get_EXT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Ipv6ExtensionFragment::EXT_NUMBER);
    return py_retval;
}
static PyGetSetDef Ns3Ipv6ExtensionFragmentMeta__getsets[] = {
    {
        (char*) "EXT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3Ipv6ExtensionFragment__get_EXT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv6ExtensionFragmentMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv6ExtensionFragmentMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv6ExtensionFragmentMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Ipv6ExtensionFragment__tp_init__0(PyNs3Ipv6ExtensionFragment *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionFragment *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionFragment_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionFragment(*((PyNs3Ipv6ExtensionFragment *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionFragment__tp_init__1(PyNs3Ipv6ExtensionFragment *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionFragment();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionFragment__tp_init(PyNs3Ipv6ExtensionFragment *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionFragment__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionFragment__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragment_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionFragment::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragment_GetFragments(PyNs3Ipv6ExtensionFragment *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    unsigned int fragmentSize;
    std::list< ns3::Ptr< ns3::Packet > > listFragments_value;
    const char *keywords[] = {"packet", "fragmentSize", "listFragments", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!IO&", (char **) keywords, &PyNs3Packet_Type, &packet, &fragmentSize, _wrap_convert_py2c__std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__, &listFragments_value)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    self->obj->GetFragments(ns3::Ptr< ns3::Packet  > (packet_ptr), fragmentSize, listFragments_value);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragment_GetExtensionNumber(PyNs3Ipv6ExtensionFragment *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetExtensionNumber();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionFragment__copy__(PyNs3Ipv6ExtensionFragment *self)
{

    PyNs3Ipv6ExtensionFragment *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionFragment, &PyNs3Ipv6ExtensionFragment_Type);
    py_copy->obj = new ns3::Ipv6ExtensionFragment(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionFragment_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragment_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetFragments", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragment_GetFragments, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetExtensionNumber", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragment_GetExtensionNumber, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragment__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionFragment__tp_clear(PyNs3Ipv6ExtensionFragment *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6ExtensionFragment *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6ExtensionFragment__tp_traverse(PyNs3Ipv6ExtensionFragment *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionFragment__tp_dealloc(PyNs3Ipv6ExtensionFragment *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionFragment__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionFragment__tp_richcompare (PyNs3Ipv6ExtensionFragment *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionFragment *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionFragment_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionFragment_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionFragment",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionFragment),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionFragment__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionFragment__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionFragment__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionFragment__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionFragment_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionFragment, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionFragment__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6ExtensionFragmentHeader__tp_init__0(PyNs3Ipv6ExtensionFragmentHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionFragmentHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionFragmentHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionFragmentHeader(*((PyNs3Ipv6ExtensionFragmentHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionFragmentHeader__tp_init__1(PyNs3Ipv6ExtensionFragmentHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionFragmentHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionFragmentHeader__tp_init(PyNs3Ipv6ExtensionFragmentHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionFragmentHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionFragmentHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragmentHeader_GetMoreFragment(PyNs3Ipv6ExtensionFragmentHeader *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->GetMoreFragment();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragmentHeader_SetIdentification(PyNs3Ipv6ExtensionFragmentHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int identification;
    const char *keywords[] = {"identification", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &identification)) {
        return NULL;
    }
    self->obj->SetIdentification(identification);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragmentHeader_GetOffset(PyNs3Ipv6ExtensionFragmentHeader *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetOffset();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragmentHeader_Deserialize(PyNs3Ipv6ExtensionFragmentHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragmentHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionFragmentHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragmentHeader_Serialize(PyNs3Ipv6ExtensionFragmentHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragmentHeader_GetIdentification(PyNs3Ipv6ExtensionFragmentHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetIdentification();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragmentHeader_SetOffset(PyNs3Ipv6ExtensionFragmentHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int offset;
    const char *keywords[] = {"offset", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &offset)) {
        return NULL;
    }
    if (offset > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetOffset(offset);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragmentHeader_GetInstanceTypeId(PyNs3Ipv6ExtensionFragmentHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragmentHeader_GetSerializedSize(PyNs3Ipv6ExtensionFragmentHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionFragmentHeader_SetMoreFragment(PyNs3Ipv6ExtensionFragmentHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool moreFragment;
    PyObject *py_moreFragment;
    const char *keywords[] = {"moreFragment", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_moreFragment)) {
        return NULL;
    }
    moreFragment = (bool) PyObject_IsTrue(py_moreFragment);
    self->obj->SetMoreFragment(moreFragment);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionFragmentHeader__copy__(PyNs3Ipv6ExtensionFragmentHeader *self)
{

    PyNs3Ipv6ExtensionFragmentHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionFragmentHeader, &PyNs3Ipv6ExtensionFragmentHeader_Type);
    py_copy->obj = new ns3::Ipv6ExtensionFragmentHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionFragmentHeader_methods[] = {
    {(char *) "GetMoreFragment", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragmentHeader_GetMoreFragment, METH_NOARGS, NULL },
    {(char *) "SetIdentification", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragmentHeader_SetIdentification, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOffset", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragmentHeader_GetOffset, METH_NOARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragmentHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragmentHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragmentHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetIdentification", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragmentHeader_GetIdentification, METH_NOARGS, NULL },
    {(char *) "SetOffset", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragmentHeader_SetOffset, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragmentHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragmentHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetMoreFragment", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragmentHeader_SetMoreFragment, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionFragmentHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionFragmentHeader__tp_clear(PyNs3Ipv6ExtensionFragmentHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6ExtensionFragmentHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6ExtensionFragmentHeader__tp_traverse(PyNs3Ipv6ExtensionFragmentHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionFragmentHeader__tp_dealloc(PyNs3Ipv6ExtensionFragmentHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionFragmentHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionFragmentHeader__tp_richcompare (PyNs3Ipv6ExtensionFragmentHeader *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionFragmentHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionFragmentHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionFragmentHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionFragmentHeader",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionFragmentHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionFragmentHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionFragmentHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionFragmentHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionFragmentHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionFragmentHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionFragmentHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionFragmentHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3Ipv6ExtensionHopByHop__get_EXT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Ipv6ExtensionHopByHop::EXT_NUMBER);
    return py_retval;
}
static PyGetSetDef Ns3Ipv6ExtensionHopByHopMeta__getsets[] = {
    {
        (char*) "EXT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3Ipv6ExtensionHopByHop__get_EXT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv6ExtensionHopByHopMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv6ExtensionHopByHopMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv6ExtensionHopByHopMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Ipv6ExtensionHopByHop__tp_init__0(PyNs3Ipv6ExtensionHopByHop *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionHopByHop *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionHopByHop_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionHopByHop(*((PyNs3Ipv6ExtensionHopByHop *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionHopByHop__tp_init__1(PyNs3Ipv6ExtensionHopByHop *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionHopByHop();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionHopByHop__tp_init(PyNs3Ipv6ExtensionHopByHop *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionHopByHop__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionHopByHop__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHop_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionHopByHop::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionHopByHop_GetExtensionNumber(PyNs3Ipv6ExtensionHopByHop *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetExtensionNumber();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionHopByHop__copy__(PyNs3Ipv6ExtensionHopByHop *self)
{

    PyNs3Ipv6ExtensionHopByHop *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionHopByHop, &PyNs3Ipv6ExtensionHopByHop_Type);
    py_copy->obj = new ns3::Ipv6ExtensionHopByHop(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionHopByHop_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHop_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetExtensionNumber", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHop_GetExtensionNumber, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionHopByHop__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionHopByHop__tp_clear(PyNs3Ipv6ExtensionHopByHop *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6ExtensionHopByHop *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6ExtensionHopByHop__tp_traverse(PyNs3Ipv6ExtensionHopByHop *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionHopByHop__tp_dealloc(PyNs3Ipv6ExtensionHopByHop *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionHopByHop__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionHopByHop__tp_richcompare (PyNs3Ipv6ExtensionHopByHop *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionHopByHop *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionHopByHop_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionHopByHop_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionHopByHop",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionHopByHop),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionHopByHop__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionHopByHop__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionHopByHop__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionHopByHop__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionHopByHop_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionHopByHop, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionHopByHop__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader__tp_init__0(PyNs3Ipv6ExtensionLooseRoutingHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionLooseRoutingHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionLooseRoutingHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionLooseRoutingHeader(*((PyNs3Ipv6ExtensionLooseRoutingHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader__tp_init__1(PyNs3Ipv6ExtensionLooseRoutingHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionLooseRoutingHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader__tp_init(PyNs3Ipv6ExtensionLooseRoutingHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_GetRoutersAddress(PyNs3Ipv6ExtensionLooseRoutingHeader *self)
{
    PyObject *py_retval;
    std::vector< ns3::Ipv6Address > retval;
    Pystd__vector__lt___ns3__Ipv6Address___gt__ *py_std__vector__lt___ns3__Ipv6Address___gt__;
    
    retval = self->obj->GetRoutersAddress();
    py_std__vector__lt___ns3__Ipv6Address___gt__ = PyObject_New(Pystd__vector__lt___ns3__Ipv6Address___gt__, &Pystd__vector__lt___ns3__Ipv6Address___gt___Type);
    py_std__vector__lt___ns3__Ipv6Address___gt__->obj = new std::vector< ns3::Ipv6Address >(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__vector__lt___ns3__Ipv6Address___gt__);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_SetNumberAddress(PyNs3Ipv6ExtensionLooseRoutingHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int n;
    const char *keywords[] = {"n", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &n)) {
        return NULL;
    }
    if (n > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetNumberAddress(n);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_Deserialize(PyNs3Ipv6ExtensionLooseRoutingHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionLooseRoutingHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_Serialize(PyNs3Ipv6ExtensionLooseRoutingHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_GetRouterAddress(PyNs3Ipv6ExtensionLooseRoutingHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int index;
    const char *keywords[] = {"index", NULL};
    PyNs3Ipv6Address *py_Ipv6Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &index)) {
        return NULL;
    }
    if (index > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    ns3::Ipv6Address retval = self->obj->GetRouterAddress(index);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_SetRoutersAddress(PyNs3Ipv6ExtensionLooseRoutingHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::vector< ns3::Ipv6Address > routersAddress_value;
    const char *keywords[] = {"routersAddress", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O&", (char **) keywords, _wrap_convert_py2c__std__vector__lt___ns3__Ipv6Address___gt__, &routersAddress_value)) {
        return NULL;
    }
    self->obj->SetRoutersAddress(routersAddress_value);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_GetInstanceTypeId(PyNs3Ipv6ExtensionLooseRoutingHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_GetSerializedSize(PyNs3Ipv6ExtensionLooseRoutingHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_SetRouterAddress(PyNs3Ipv6ExtensionLooseRoutingHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int index;
    PyNs3Ipv6Address *addr;
    const char *keywords[] = {"index", "addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iO!", (char **) keywords, &index, &PyNs3Ipv6Address_Type, &addr)) {
        return NULL;
    }
    if (index > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetRouterAddress(index, *((PyNs3Ipv6Address *) addr)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader__copy__(PyNs3Ipv6ExtensionLooseRoutingHeader *self)
{

    PyNs3Ipv6ExtensionLooseRoutingHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionLooseRoutingHeader, &PyNs3Ipv6ExtensionLooseRoutingHeader_Type);
    py_copy->obj = new ns3::Ipv6ExtensionLooseRoutingHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionLooseRoutingHeader_methods[] = {
    {(char *) "GetRoutersAddress", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_GetRoutersAddress, METH_NOARGS, NULL },
    {(char *) "SetNumberAddress", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_SetNumberAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetRouterAddress", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_GetRouterAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRoutersAddress", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_SetRoutersAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "SetRouterAddress", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader_SetRouterAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRoutingHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionLooseRoutingHeader__tp_clear(PyNs3Ipv6ExtensionLooseRoutingHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::Ipv6ExtensionLooseRoutingHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3Ipv6ExtensionLooseRoutingHeader__tp_traverse(PyNs3Ipv6ExtensionLooseRoutingHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader__tp_dealloc(PyNs3Ipv6ExtensionLooseRoutingHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionLooseRoutingHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader__tp_richcompare (PyNs3Ipv6ExtensionLooseRoutingHeader *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionLooseRoutingHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionLooseRoutingHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionLooseRoutingHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionLooseRoutingHeader",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionLooseRoutingHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionLooseRoutingHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionLooseRoutingHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionLooseRoutingHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionLooseRoutingHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionLooseRoutingHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3Ipv6ExtensionRouting__get_EXT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Ipv6ExtensionRouting::EXT_NUMBER);
    return py_retval;
}
static PyGetSetDef Ns3Ipv6ExtensionRoutingMeta__getsets[] = {
    {
        (char*) "EXT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3Ipv6ExtensionRouting__get_EXT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv6ExtensionRoutingMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv6ExtensionRoutingMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv6ExtensionRoutingMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Ipv6ExtensionRouting__tp_init__0(PyNs3Ipv6ExtensionRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionRouting *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionRouting_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionRouting(*((PyNs3Ipv6ExtensionRouting *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionRouting__tp_init__1(PyNs3Ipv6ExtensionRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionRouting();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionRouting__tp_init(PyNs3Ipv6ExtensionRouting *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionRouting__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionRouting__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRouting_GetTypeRouting(PyNs3Ipv6ExtensionRouting *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetTypeRouting();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRouting_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionRouting::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRouting_GetExtensionNumber(PyNs3Ipv6ExtensionRouting *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetExtensionNumber();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionRouting__copy__(PyNs3Ipv6ExtensionRouting *self)
{

    PyNs3Ipv6ExtensionRouting *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionRouting, &PyNs3Ipv6ExtensionRouting_Type);
    py_copy->obj = new ns3::Ipv6ExtensionRouting(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionRouting_methods[] = {
    {(char *) "GetTypeRouting", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRouting_GetTypeRouting, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRouting_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetExtensionNumber", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRouting_GetExtensionNumber, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRouting__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionRouting__tp_clear(PyNs3Ipv6ExtensionRouting *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6ExtensionRouting *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6ExtensionRouting__tp_traverse(PyNs3Ipv6ExtensionRouting *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionRouting__tp_dealloc(PyNs3Ipv6ExtensionRouting *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionRouting__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionRouting__tp_richcompare (PyNs3Ipv6ExtensionRouting *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionRouting *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionRouting_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionRouting_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionRouting",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionRouting),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionRouting__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionRouting__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionRouting__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionRouting__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionRouting_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionRouting, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionRouting__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3Ipv6ExtensionRoutingDemux *self)
{
    PyObject *py_retval;
    PyNs3Ipv6ExtensionRoutingDemux__PythonHelper *helper = dynamic_cast< PyNs3Ipv6ExtensionRoutingDemux__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::_wrap_NotifyNewAggregate(PyNs3Ipv6ExtensionRoutingDemux *self)
{
    PyObject *py_retval;
    PyNs3Ipv6ExtensionRoutingDemux__PythonHelper *helper = dynamic_cast< PyNs3Ipv6ExtensionRoutingDemux__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::_wrap_DoStart(PyNs3Ipv6ExtensionRoutingDemux *self)
{
    PyObject *py_retval;
    PyNs3Ipv6ExtensionRoutingDemux__PythonHelper *helper = dynamic_cast< PyNs3Ipv6ExtensionRoutingDemux__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::_wrap_DoDispose(PyNs3Ipv6ExtensionRoutingDemux *self)
{
    PyObject *py_retval;
    PyNs3Ipv6ExtensionRoutingDemux__PythonHelper *helper = dynamic_cast< PyNs3Ipv6ExtensionRoutingDemux__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Ipv6ExtensionRoutingDemux is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

void
PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6ExtensionRoutingDemux *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv6ExtensionRoutingDemux::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6ExtensionRoutingDemux* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6ExtensionRoutingDemux* >(m_pyself)->obj = (ns3::Ipv6ExtensionRoutingDemux*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6ExtensionRoutingDemux* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6ExtensionRoutingDemux* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6ExtensionRoutingDemux* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3Ipv6ExtensionRoutingDemux__tp_init__0(PyNs3Ipv6ExtensionRoutingDemux *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionRoutingDemux *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionRoutingDemux_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv6ExtensionRoutingDemux_Type)
    {
        self->obj = new PyNs3Ipv6ExtensionRoutingDemux__PythonHelper(*((PyNs3Ipv6ExtensionRoutingDemux *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv6ExtensionRoutingDemux__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::Ipv6ExtensionRoutingDemux(*((PyNs3Ipv6ExtensionRoutingDemux *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionRoutingDemux__tp_init__1(PyNs3Ipv6ExtensionRoutingDemux *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv6ExtensionRoutingDemux_Type)
    {
        self->obj = new PyNs3Ipv6ExtensionRoutingDemux__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv6ExtensionRoutingDemux__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::Ipv6ExtensionRoutingDemux();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionRoutingDemux__tp_init(PyNs3Ipv6ExtensionRoutingDemux *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionRoutingDemux__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionRoutingDemux__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingDemux_Insert(PyNs3Ipv6ExtensionRoutingDemux *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6ExtensionRouting *extensionRouting;
    ns3::Ipv6ExtensionRouting *extensionRouting_ptr;
    const char *keywords[] = {"extensionRouting", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionRouting_Type, &extensionRouting)) {
        return NULL;
    }
    extensionRouting_ptr = (extensionRouting ? extensionRouting->obj : NULL);
    self->obj->Insert(ns3::Ptr< ns3::Ipv6ExtensionRouting  > (extensionRouting_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingDemux_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionRoutingDemux::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingDemux_SetNode(PyNs3Ipv6ExtensionRoutingDemux *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingDemux_GetExtensionRouting(PyNs3Ipv6ExtensionRoutingDemux *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6ExtensionRouting > retval;
    int typeRouting;
    const char *keywords[] = {"typeRouting", NULL};
    PyNs3Ipv6ExtensionRouting *py_Ipv6ExtensionRouting;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &typeRouting)) {
        return NULL;
    }
    if (typeRouting > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    retval = self->obj->GetExtensionRouting(typeRouting);
    if (!(const_cast<ns3::Ipv6ExtensionRouting *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6ExtensionRouting *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv6ExtensionRouting = NULL;
    } else {
        py_Ipv6ExtensionRouting = (PyNs3Ipv6ExtensionRouting *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6ExtensionRouting);
    }
    
    if (py_Ipv6ExtensionRouting == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6ExtensionRouting *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6ExtensionRouting_Type);
        py_Ipv6ExtensionRouting = PyObject_GC_New(PyNs3Ipv6ExtensionRouting, wrapper_type);
        py_Ipv6ExtensionRouting->inst_dict = NULL;
        py_Ipv6ExtensionRouting->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6ExtensionRouting *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv6ExtensionRouting->obj = const_cast<ns3::Ipv6ExtensionRouting *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6ExtensionRouting->obj] = (PyObject *) py_Ipv6ExtensionRouting;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6ExtensionRouting);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionRoutingDemux_Remove(PyNs3Ipv6ExtensionRoutingDemux *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6ExtensionRouting *extensionRouting;
    ns3::Ipv6ExtensionRouting *extensionRouting_ptr;
    const char *keywords[] = {"extensionRouting", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionRouting_Type, &extensionRouting)) {
        return NULL;
    }
    extensionRouting_ptr = (extensionRouting ? extensionRouting->obj : NULL);
    self->obj->Remove(ns3::Ptr< ns3::Ipv6ExtensionRouting  > (extensionRouting_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionRoutingDemux__copy__(PyNs3Ipv6ExtensionRoutingDemux *self)
{

    PyNs3Ipv6ExtensionRoutingDemux *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionRoutingDemux, &PyNs3Ipv6ExtensionRoutingDemux_Type);
    py_copy->obj = new ns3::Ipv6ExtensionRoutingDemux(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionRoutingDemux_methods[] = {
    {(char *) "Insert", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingDemux_Insert, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingDemux_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingDemux_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetExtensionRouting", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingDemux_GetExtensionRouting, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Remove", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingDemux_Remove, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "DoDispose", (PyCFunction) PyNs3Ipv6ExtensionRoutingDemux__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionRoutingDemux__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionRoutingDemux__tp_clear(PyNs3Ipv6ExtensionRoutingDemux *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6ExtensionRoutingDemux *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6ExtensionRoutingDemux__tp_traverse(PyNs3Ipv6ExtensionRoutingDemux *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3Ipv6ExtensionRoutingDemux__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionRoutingDemux__tp_dealloc(PyNs3Ipv6ExtensionRoutingDemux *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionRoutingDemux__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionRoutingDemux__tp_richcompare (PyNs3Ipv6ExtensionRoutingDemux *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionRoutingDemux *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionRoutingDemux_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionRoutingDemux_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionRoutingDemux",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionRoutingDemux),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionRoutingDemux__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionRoutingDemux__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionRoutingDemux__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionRoutingDemux__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionRoutingDemux_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionRoutingDemux, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionRoutingDemux__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3Ipv6Interface__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Interface__PythonHelper *helper = dynamic_cast< PyNs3Ipv6Interface__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6Interface__PythonHelper::_wrap_NotifyNewAggregate(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Interface__PythonHelper *helper = dynamic_cast< PyNs3Ipv6Interface__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6Interface__PythonHelper::_wrap_DoStart(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Interface__PythonHelper *helper = dynamic_cast< PyNs3Ipv6Interface__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6Interface__PythonHelper::_wrap_DoDispose(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Interface__PythonHelper *helper = dynamic_cast< PyNs3Ipv6Interface__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Ipv6Interface is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

ns3::Ptr< ns3::NetDevice >
PyNs3Ipv6Interface__PythonHelper::GetDevice() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6Interface *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *tmp_NetDevice;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6Interface::GetDevice();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6Interface* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6Interface* >(m_pyself)->obj = const_cast< ns3::Ipv6Interface* >((const ns3::Ipv6Interface*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetDevice", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6Interface* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6Interface::GetDevice();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3NetDevice_Type, &tmp_NetDevice)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6Interface* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6Interface::GetDevice();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::NetDevice  > (tmp_NetDevice->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6Interface* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6Interface__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6Interface *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv6Interface::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6Interface* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6Interface* >(m_pyself)->obj = (ns3::Ipv6Interface*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6Interface* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6Interface* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6Interface* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3Ipv6Interface__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6Interface__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6Interface__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6Interface__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3Ipv6Interface__tp_init__0(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6Interface *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Interface_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv6Interface_Type)
    {
        self->obj = new PyNs3Ipv6Interface__PythonHelper(*((PyNs3Ipv6Interface *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv6Interface__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::Ipv6Interface(*((PyNs3Ipv6Interface *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3Ipv6Interface__tp_init__1(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv6Interface_Type)
    {
        self->obj = new PyNs3Ipv6Interface__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv6Interface__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::Ipv6Interface();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3Ipv6Interface__tp_init(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6Interface__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6Interface__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6Interface_GetBaseReachableTime(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetBaseReachableTime();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_GetLinkLocalAddress(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    PyNs3Ipv6InterfaceAddress *py_Ipv6InterfaceAddress;
    
    ns3::Ipv6InterfaceAddress retval = self->obj->GetLinkLocalAddress();
    py_Ipv6InterfaceAddress = PyObject_New(PyNs3Ipv6InterfaceAddress, &PyNs3Ipv6InterfaceAddress_Type);
    py_Ipv6InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6InterfaceAddress->obj = new ns3::Ipv6InterfaceAddress(retval);
    PyNs3Ipv6InterfaceAddress_wrapper_registry[(void *) py_Ipv6InterfaceAddress->obj] = (PyObject *) py_Ipv6InterfaceAddress;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6InterfaceAddress);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_SetMetric(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int metric;
    const char *keywords[] = {"metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &metric)) {
        return NULL;
    }
    if (metric > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetMetric(metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_GetAddressMatchingDestination(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dst;
    const char *keywords[] = {"dst", NULL};
    PyNs3Ipv6InterfaceAddress *py_Ipv6InterfaceAddress;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &dst)) {
        return NULL;
    }
    ns3::Ipv6InterfaceAddress retval = self->obj->GetAddressMatchingDestination(*((PyNs3Ipv6Address *) dst)->obj);
    py_Ipv6InterfaceAddress = PyObject_New(PyNs3Ipv6InterfaceAddress, &PyNs3Ipv6InterfaceAddress_Type);
    py_Ipv6InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6InterfaceAddress->obj = new ns3::Ipv6InterfaceAddress(retval);
    PyNs3Ipv6InterfaceAddress_wrapper_registry[(void *) py_Ipv6InterfaceAddress->obj] = (PyObject *) py_Ipv6InterfaceAddress;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6InterfaceAddress);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6Interface::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_SetNsDadUid(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *address;
    unsigned int uid;
    const char *keywords[] = {"address", "uid", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3Ipv6Address_Type, &address, &uid)) {
        return NULL;
    }
    self->obj->SetNsDadUid(*((PyNs3Ipv6Address *) address)->obj, uid);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_Send(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv6Address *dest;
    const char *keywords[] = {"p", "dest", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv6Address_Type, &dest)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    self->obj->Send(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv6Address *) dest)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_GetMetric(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetMetric();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_SetDown(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    
    self->obj->SetDown();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_SetForwarding(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool forward;
    PyObject *py_forward;
    const char *keywords[] = {"forward", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_forward)) {
        return NULL;
    }
    forward = (bool) PyObject_IsTrue(py_forward);
    self->obj->SetForwarding(forward);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_GetCurHopLimit(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetCurHopLimit();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_GetNAddresses(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNAddresses();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_SetReachableTime(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int reachableTime;
    const char *keywords[] = {"reachableTime", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &reachableTime)) {
        return NULL;
    }
    if (reachableTime > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetReachableTime(reachableTime);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_SetState(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *address;
    ns3::Ipv6InterfaceAddress::State_e state;
    const char *keywords[] = {"address", "state", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!i", (char **) keywords, &PyNs3Ipv6Address_Type, &address, &state)) {
        return NULL;
    }
    self->obj->SetState(*((PyNs3Ipv6Address *) address)->obj, state);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_AddAddress(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv6InterfaceAddress *iface;
    const char *keywords[] = {"iface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6InterfaceAddress_Type, &iface)) {
        return NULL;
    }
    retval = self->obj->AddAddress(*((PyNs3Ipv6InterfaceAddress *) iface)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_SetNode(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_IsForwarding(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsForwarding();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_SetBaseReachableTime(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int baseReachableTime;
    const char *keywords[] = {"baseReachableTime", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &baseReachableTime)) {
        return NULL;
    }
    if (baseReachableTime > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetBaseReachableTime(baseReachableTime);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_GetAddress(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int index;
    const char *keywords[] = {"index", NULL};
    PyNs3Ipv6InterfaceAddress *py_Ipv6InterfaceAddress;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    ns3::Ipv6InterfaceAddress retval = self->obj->GetAddress(index);
    py_Ipv6InterfaceAddress = PyObject_New(PyNs3Ipv6InterfaceAddress, &PyNs3Ipv6InterfaceAddress_Type);
    py_Ipv6InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6InterfaceAddress->obj = new ns3::Ipv6InterfaceAddress(retval);
    PyNs3Ipv6InterfaceAddress_wrapper_registry[(void *) py_Ipv6InterfaceAddress->obj] = (PyObject *) py_Ipv6InterfaceAddress;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6InterfaceAddress);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_SetRetransTimer(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retransTimer;
    const char *keywords[] = {"retransTimer", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &retransTimer)) {
        return NULL;
    }
    if (retransTimer > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetRetransTimer(retransTimer);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_SetCurHopLimit(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int curHopLimit;
    const char *keywords[] = {"curHopLimit", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &curHopLimit)) {
        return NULL;
    }
    if (curHopLimit > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetCurHopLimit(curHopLimit);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_SetDevice(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    const char *keywords[] = {"device", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &device)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    self->obj->SetDevice(ns3::Ptr< ns3::NetDevice  > (device_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_IsDown(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsDown();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_GetDevice(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3Ipv6Interface__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6Interface__PythonHelper*> (self->obj);
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = (helper_class == NULL)? (self->obj->GetDevice()) : (self->obj->ns3::Ipv6Interface::GetDevice());
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_RemoveAddress(PyNs3Ipv6Interface *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int index;
    const char *keywords[] = {"index", NULL};
    PyNs3Ipv6InterfaceAddress *py_Ipv6InterfaceAddress;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    ns3::Ipv6InterfaceAddress retval = self->obj->RemoveAddress(index);
    py_Ipv6InterfaceAddress = PyObject_New(PyNs3Ipv6InterfaceAddress, &PyNs3Ipv6InterfaceAddress_Type);
    py_Ipv6InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6InterfaceAddress->obj = new ns3::Ipv6InterfaceAddress(retval);
    PyNs3Ipv6InterfaceAddress_wrapper_registry[(void *) py_Ipv6InterfaceAddress->obj] = (PyObject *) py_Ipv6InterfaceAddress;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6InterfaceAddress);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_SetUp(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    
    self->obj->SetUp();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_GetRetransTimer(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetRetransTimer();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_IsUp(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsUp();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Interface_GetReachableTime(PyNs3Ipv6Interface *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetReachableTime();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6Interface__copy__(PyNs3Ipv6Interface *self)
{

    PyNs3Ipv6Interface *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6Interface, &PyNs3Ipv6Interface_Type);
    py_copy->obj = new ns3::Ipv6Interface(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6Interface_methods[] = {
    {(char *) "GetBaseReachableTime", (PyCFunction) _wrap_PyNs3Ipv6Interface_GetBaseReachableTime, METH_NOARGS, NULL },
    {(char *) "GetLinkLocalAddress", (PyCFunction) _wrap_PyNs3Ipv6Interface_GetLinkLocalAddress, METH_NOARGS, NULL },
    {(char *) "SetMetric", (PyCFunction) _wrap_PyNs3Ipv6Interface_SetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAddressMatchingDestination", (PyCFunction) _wrap_PyNs3Ipv6Interface_GetAddressMatchingDestination, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6Interface_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "SetNsDadUid", (PyCFunction) _wrap_PyNs3Ipv6Interface_SetNsDadUid, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Send", (PyCFunction) _wrap_PyNs3Ipv6Interface_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMetric", (PyCFunction) _wrap_PyNs3Ipv6Interface_GetMetric, METH_NOARGS, NULL },
    {(char *) "SetDown", (PyCFunction) _wrap_PyNs3Ipv6Interface_SetDown, METH_NOARGS, NULL },
    {(char *) "SetForwarding", (PyCFunction) _wrap_PyNs3Ipv6Interface_SetForwarding, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetCurHopLimit", (PyCFunction) _wrap_PyNs3Ipv6Interface_GetCurHopLimit, METH_NOARGS, NULL },
    {(char *) "GetNAddresses", (PyCFunction) _wrap_PyNs3Ipv6Interface_GetNAddresses, METH_NOARGS, NULL },
    {(char *) "SetReachableTime", (PyCFunction) _wrap_PyNs3Ipv6Interface_SetReachableTime, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetState", (PyCFunction) _wrap_PyNs3Ipv6Interface_SetState, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddAddress", (PyCFunction) _wrap_PyNs3Ipv6Interface_AddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3Ipv6Interface_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsForwarding", (PyCFunction) _wrap_PyNs3Ipv6Interface_IsForwarding, METH_NOARGS, NULL },
    {(char *) "SetBaseReachableTime", (PyCFunction) _wrap_PyNs3Ipv6Interface_SetBaseReachableTime, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv6Interface_GetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRetransTimer", (PyCFunction) _wrap_PyNs3Ipv6Interface_SetRetransTimer, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetCurHopLimit", (PyCFunction) _wrap_PyNs3Ipv6Interface_SetCurHopLimit, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDevice", (PyCFunction) _wrap_PyNs3Ipv6Interface_SetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsDown", (PyCFunction) _wrap_PyNs3Ipv6Interface_IsDown, METH_NOARGS, NULL },
    {(char *) "GetDevice", (PyCFunction) _wrap_PyNs3Ipv6Interface_GetDevice, METH_NOARGS, NULL },
    {(char *) "RemoveAddress", (PyCFunction) _wrap_PyNs3Ipv6Interface_RemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetUp", (PyCFunction) _wrap_PyNs3Ipv6Interface_SetUp, METH_NOARGS, NULL },
    {(char *) "GetRetransTimer", (PyCFunction) _wrap_PyNs3Ipv6Interface_GetRetransTimer, METH_NOARGS, NULL },
    {(char *) "IsUp", (PyCFunction) _wrap_PyNs3Ipv6Interface_IsUp, METH_NOARGS, NULL },
    {(char *) "GetReachableTime", (PyCFunction) _wrap_PyNs3Ipv6Interface_GetReachableTime, METH_NOARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3Ipv6Interface__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3Ipv6Interface__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3Ipv6Interface__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "DoDispose", (PyCFunction) PyNs3Ipv6Interface__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6Interface__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6Interface__tp_clear(PyNs3Ipv6Interface *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6Interface *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6Interface__tp_traverse(PyNs3Ipv6Interface *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3Ipv6Interface__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3Ipv6Interface__tp_dealloc(PyNs3Ipv6Interface *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6Interface__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6Interface__tp_richcompare (PyNs3Ipv6Interface *PYBINDGEN_UNUSED(self), PyNs3Ipv6Interface *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6Interface_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6Interface_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6Interface",            /* tp_name */
    sizeof(PyNs3Ipv6Interface),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6Interface__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6Interface__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6Interface__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6Interface__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6Interface_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6Interface, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6Interface__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3Ipv6L3Protocol__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3Ipv6L3Protocol *self)
{
    PyObject *py_retval;
    PyNs3Ipv6L3Protocol__PythonHelper *helper = dynamic_cast< PyNs3Ipv6L3Protocol__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6L3Protocol__PythonHelper::_wrap_NotifyNewAggregate(PyNs3Ipv6L3Protocol *self)
{
    PyObject *py_retval;
    PyNs3Ipv6L3Protocol__PythonHelper *helper = dynamic_cast< PyNs3Ipv6L3Protocol__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Ipv6L3Protocol is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6L3Protocol__PythonHelper::_wrap_DoStart(PyNs3Ipv6L3Protocol *self)
{
    PyObject *py_retval;
    PyNs3Ipv6L3Protocol__PythonHelper *helper = dynamic_cast< PyNs3Ipv6L3Protocol__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3Ipv6L3Protocol__PythonHelper::_wrap_DoDispose(PyNs3Ipv6L3Protocol *self)
{
    PyObject *py_retval;
    PyNs3Ipv6L3Protocol__PythonHelper *helper = dynamic_cast< PyNs3Ipv6L3Protocol__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Ipv6L3Protocol is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::SetRoutingProtocol(ns3::Ptr< ns3::Ipv6RoutingProtocol > routingProtocol)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv6RoutingProtocol *py_Ipv6RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetRoutingProtocol"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv6L3Protocol::SetRoutingProtocol(routingProtocol);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (routingProtocol)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv6RoutingProtocol = NULL;
    } else {
        py_Ipv6RoutingProtocol = (PyNs3Ipv6RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6RoutingProtocol);
    }
    
    if (py_Ipv6RoutingProtocol == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (routingProtocol))), &PyNs3Ipv6RoutingProtocol_Type);
        py_Ipv6RoutingProtocol = PyObject_GC_New(PyNs3Ipv6RoutingProtocol, wrapper_type);
        py_Ipv6RoutingProtocol->inst_dict = NULL;
        py_Ipv6RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (routingProtocol))->Ref();
        py_Ipv6RoutingProtocol->obj = const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (routingProtocol));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6RoutingProtocol->obj] = (PyObject *) py_Ipv6RoutingProtocol;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetRoutingProtocol", (char *) "N", py_Ipv6RoutingProtocol);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::Ptr< ns3::Ipv6RoutingProtocol >
PyNs3Ipv6L3Protocol__PythonHelper::GetRoutingProtocol() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6RoutingProtocol > retval;
    PyNs3Ipv6RoutingProtocol *tmp_Ipv6RoutingProtocol;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetRoutingProtocol"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetRoutingProtocol();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetRoutingProtocol", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetRoutingProtocol();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv6RoutingProtocol_Type, &tmp_Ipv6RoutingProtocol)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetRoutingProtocol();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Ipv6RoutingProtocol  > (tmp_Ipv6RoutingProtocol->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv6L3Protocol__PythonHelper::AddInterface(ns3::Ptr< ns3::NetDevice > device)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "AddInterface"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::AddInterface(device);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "AddInterface", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::AddInterface(device);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::AddInterface(device);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv6L3Protocol__PythonHelper::GetNInterfaces() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNInterfaces"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetNInterfaces();
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNInterfaces", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetNInterfaces();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetNInterfaces();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3Ipv6L3Protocol__PythonHelper::GetInterfaceForAddress(ns3::Ipv6Address addr) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInterfaceForAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetInterfaceForAddress(addr);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(addr);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInterfaceForAddress", (char *) "N", py_Ipv6Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetInterfaceForAddress(addr);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetInterfaceForAddress(addr);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3Ipv6L3Protocol__PythonHelper::GetInterfaceForPrefix(ns3::Ipv6Address addr, ns3::Ipv6Prefix mask) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    PyNs3Ipv6Prefix *py_Ipv6Prefix;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInterfaceForPrefix"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetInterfaceForPrefix(addr, mask);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(addr);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_Ipv6Prefix = PyObject_New(PyNs3Ipv6Prefix, &PyNs3Ipv6Prefix_Type);
    py_Ipv6Prefix->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Prefix->obj = new ns3::Ipv6Prefix(mask);
    PyNs3Ipv6Prefix_wrapper_registry[(void *) py_Ipv6Prefix->obj] = (PyObject *) py_Ipv6Prefix;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInterfaceForPrefix", (char *) "NN", py_Ipv6Address, py_Ipv6Prefix);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetInterfaceForPrefix(addr, mask);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetInterfaceForPrefix(addr, mask);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

int32_t
PyNs3Ipv6L3Protocol__PythonHelper::GetInterfaceForDevice(ns3::Ptr< ns3::NetDevice const > device) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    int32_t retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInterfaceForDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetInterfaceForDevice(device);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (device)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (device))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (device));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInterfaceForDevice", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetInterfaceForDevice(device);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetInterfaceForDevice(device);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv6L3Protocol__PythonHelper::AddAddress(uint32_t i, ns3::Ipv6InterfaceAddress address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv6InterfaceAddress *py_Ipv6InterfaceAddress;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "AddAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::AddAddress(i, address);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_Ipv6InterfaceAddress = PyObject_New(PyNs3Ipv6InterfaceAddress, &PyNs3Ipv6InterfaceAddress_Type);
    py_Ipv6InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6InterfaceAddress->obj = new ns3::Ipv6InterfaceAddress(address);
    PyNs3Ipv6InterfaceAddress_wrapper_registry[(void *) py_Ipv6InterfaceAddress->obj] = (PyObject *) py_Ipv6InterfaceAddress;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "AddAddress", (char *) "NN", PyLong_FromUnsignedLong(i), py_Ipv6InterfaceAddress);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::AddAddress(i, address);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::AddAddress(i, address);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ipv6InterfaceAddress
PyNs3Ipv6L3Protocol__PythonHelper::GetAddress(uint32_t interfaceIndex, uint32_t addressIndex) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv6InterfaceAddress *tmp_Ipv6InterfaceAddress;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetAddress(interfaceIndex, addressIndex);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetAddress", (char *) "NN", PyLong_FromUnsignedLong(interfaceIndex), PyLong_FromUnsignedLong(addressIndex));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetAddress(interfaceIndex, addressIndex);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv6InterfaceAddress_Type, &tmp_Ipv6InterfaceAddress)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetAddress(interfaceIndex, addressIndex);
    }
    ns3::Ipv6InterfaceAddress retval = *tmp_Ipv6InterfaceAddress->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3Ipv6L3Protocol__PythonHelper::GetNAddresses(uint32_t interface) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNAddresses"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetNAddresses(interface);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNAddresses", (char *) "N", PyLong_FromUnsignedLong(interface));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetNAddresses(interface);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetNAddresses(interface);
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv6L3Protocol__PythonHelper::RemoveAddress(uint32_t interfaceIndex, uint32_t addressIndex)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "RemoveAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::RemoveAddress(interfaceIndex, addressIndex);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "RemoveAddress", (char *) "NN", PyLong_FromUnsignedLong(interfaceIndex), PyLong_FromUnsignedLong(addressIndex));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::RemoveAddress(interfaceIndex, addressIndex);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::RemoveAddress(interfaceIndex, addressIndex);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::SetMetric(uint32_t i, uint16_t metric)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetMetric"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv6L3Protocol::SetMetric(i, metric);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetMetric", (char *) "Ni", PyLong_FromUnsignedLong(i), (int) metric);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

uint16_t
PyNs3Ipv6L3Protocol__PythonHelper::GetMetric(uint32_t i) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    uint16_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetMetric"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetMetric(i);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetMetric", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetMetric(i);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetMetric(i);
    }
    if (tmp > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetMetric(i);
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint16_t
PyNs3Ipv6L3Protocol__PythonHelper::GetMtu(uint32_t i) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    uint16_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetMtu"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetMtu(i);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetMtu", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetMtu(i);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetMtu(i);
    }
    if (tmp > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetMtu(i);
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3Ipv6L3Protocol__PythonHelper::IsUp(uint32_t i) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsUp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::IsUp(i);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsUp", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::IsUp(i);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::IsUp(i);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::SetUp(uint32_t i)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetUp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv6L3Protocol::SetUp(i);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetUp", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::SetDown(uint32_t i)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetDown"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv6L3Protocol::SetDown(i);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetDown", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3Ipv6L3Protocol__PythonHelper::IsForwarding(uint32_t i) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsForwarding"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::IsForwarding(i);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsForwarding", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::IsForwarding(i);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::IsForwarding(i);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::SetForwarding(uint32_t i, bool val)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetForwarding"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv6L3Protocol::SetForwarding(i, val);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetForwarding", (char *) "NN", PyLong_FromUnsignedLong(i), PyBool_FromLong(val));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::Ptr< ns3::NetDevice >
PyNs3Ipv6L3Protocol__PythonHelper::GetNetDevice(uint32_t i)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *tmp_NetDevice;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetNetDevice(i);
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNetDevice", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetNetDevice(i);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3NetDevice_Type, &tmp_NetDevice)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Ipv6L3Protocol::GetNetDevice(i);
    }
    // dangerous!
    retval = ns3::Ptr< ns3::NetDevice  > (tmp_NetDevice->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::RegisterExtensions()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "RegisterExtensions"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv6L3Protocol::RegisterExtensions();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "RegisterExtensions", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::RegisterOptions()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "RegisterOptions"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv6L3Protocol::RegisterOptions();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "RegisterOptions", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv6L3Protocol::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Ipv6L3Protocol::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::SetIpForward(bool forward)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetIpForward"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetIpForward", (char *) "N", PyBool_FromLong(forward));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3Ipv6L3Protocol__PythonHelper::GetIpForward() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetIpForward"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetIpForward", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::SetSendIcmpv6Redirect(bool sendIcmpv6Redirect)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetSendIcmpv6Redirect"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = (ns3::Ipv6L3Protocol*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetSendIcmpv6Redirect", (char *) "N", PyBool_FromLong(sendIcmpv6Redirect));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3Ipv6L3Protocol__PythonHelper::GetSendIcmpv6Redirect() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Ipv6L3Protocol *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetSendIcmpv6Redirect"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = const_cast< ns3::Ipv6L3Protocol* >((const ns3::Ipv6L3Protocol*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetSendIcmpv6Redirect", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Ipv6L3Protocol* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::TypeId
PyNs3Ipv6L3Protocol__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3Ipv6L3Protocol__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}
static PyObject* _wrap_PyNs3Ipv6L3Protocol__get_PROT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", ns3::Ipv6L3Protocol::PROT_NUMBER);
    return py_retval;
}
static PyGetSetDef Ns3Ipv6L3ProtocolMeta__getsets[] = {
    {
        (char*) "PROT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3Ipv6L3Protocol__get_PROT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv6L3ProtocolMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv6L3ProtocolMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv6L3ProtocolMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};


static int
_wrap_PyNs3Ipv6L3Protocol__tp_init(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    if (self->ob_type != &PyNs3Ipv6L3Protocol_Type)
    {
        self->obj = new PyNs3Ipv6L3Protocol__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3Ipv6L3Protocol__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::Ipv6L3Protocol();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetNInterfaces(PyNs3Ipv6L3Protocol *self)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->GetNInterfaces()) : (self->obj->ns3::Ipv6L3Protocol::GetNInterfaces());
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetInterfaceForAddress(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv6Address *addr;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"addr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &addr)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetInterfaceForAddress(*((PyNs3Ipv6Address *) addr)->obj)) : (self->obj->ns3::Ipv6L3Protocol::GetInterfaceForAddress(*((PyNs3Ipv6Address *) addr)->obj));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_SetMetric(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    int metric;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "Ii", (char **) keywords, &i, &metric)) {
        return NULL;
    }
    if (metric > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    (helper_class == NULL)? (self->obj->SetMetric(i, metric)) : (self->obj->ns3::Ipv6L3Protocol::SetMetric(i, metric));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetInterfaceForDevice(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"device", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &device)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    retval = (helper_class == NULL)? (self->obj->GetInterfaceForDevice(ns3::Ptr< ns3::NetDevice  > (device_ptr))) : (self->obj->ns3::Ipv6L3Protocol::GetInterfaceForDevice(ns3::Ptr< ns3::NetDevice  > (device_ptr)));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6L3Protocol::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_Send(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv6Address *source;
    PyNs3Ipv6Address *destination;
    int protocol;
    PyNs3Ipv6Route *route;
    ns3::Ipv6Route *route_ptr;
    const char *keywords[] = {"packet", "source", "destination", "protocol", "route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!iO!", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv6Address_Type, &source, &PyNs3Ipv6Address_Type, &destination, &protocol, &PyNs3Ipv6Route_Type, &route)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (protocol > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    route_ptr = (route ? route->obj : NULL);
    self->obj->Send(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv6Address *) source)->obj, *((PyNs3Ipv6Address *) destination)->obj, protocol, ns3::Ptr< ns3::Ipv6Route  > (route_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_AddAutoconfiguredAddress(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv6Address *network;
    PyNs3Ipv6Prefix *mask;
    int flags;
    unsigned int validTime;
    unsigned int preferredTime;
    PyNs3Ipv6Address *defaultRouter = NULL;
    const char *keywords[] = {"interface", "network", "mask", "flags", "validTime", "preferredTime", "defaultRouter", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!O!iII|O!", (char **) keywords, &interface, &PyNs3Ipv6Address_Type, &network, &PyNs3Ipv6Prefix_Type, &mask, &flags, &validTime, &preferredTime, &PyNs3Ipv6Address_Type, &defaultRouter)) {
        return NULL;
    }
    if (flags > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->AddAutoconfiguredAddress(interface, *((PyNs3Ipv6Address *) network)->obj, *((PyNs3Ipv6Prefix *) mask)->obj, flags, validTime, preferredTime, (defaultRouter ? (*((PyNs3Ipv6Address *) defaultRouter)->obj) : ns3::Ipv6Address::GetZero( )));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_DeleteRawSocket(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Socket *socket;
    ns3::Socket *socket_ptr;
    const char *keywords[] = {"socket", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Socket_Type, &socket)) {
        return NULL;
    }
    socket_ptr = (socket ? socket->obj : NULL);
    self->obj->DeleteRawSocket(ns3::Ptr< ns3::Socket  > (socket_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_SetDown(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    (helper_class == NULL)? (self->obj->SetDown(i)) : (self->obj->ns3::Ipv6L3Protocol::SetDown(i));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_RegisterOptions(PyNs3Ipv6L3Protocol *self)
{
    PyObject *py_retval;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    
    (helper_class == NULL)? (self->obj->RegisterOptions()) : (self->obj->ns3::Ipv6L3Protocol::RegisterOptions());
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_AddAddress(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int i;
    PyNs3Ipv6InterfaceAddress *address;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &i, &PyNs3Ipv6InterfaceAddress_Type, &address)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->AddAddress(i, *((PyNs3Ipv6InterfaceAddress *) address)->obj)) : (self->obj->ns3::Ipv6L3Protocol::AddAddress(i, *((PyNs3Ipv6InterfaceAddress *) address)->obj));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_SetDefaultTtl(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int ttl;
    const char *keywords[] = {"ttl", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &ttl)) {
        return NULL;
    }
    if (ttl > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SetDefaultTtl(ttl);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_AddInterface(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"device", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &device)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    retval = (helper_class == NULL)? (self->obj->AddInterface(ns3::Ptr< ns3::NetDevice  > (device_ptr))) : (self->obj->ns3::Ipv6L3Protocol::AddInterface(ns3::Ptr< ns3::NetDevice  > (device_ptr)));
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_RemoveAutoconfiguredAddress(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv6Address *network;
    PyNs3Ipv6Prefix *mask;
    PyNs3Ipv6Address *defaultRouter;
    const char *keywords[] = {"interface", "network", "mask", "defaultRouter", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!O!O!", (char **) keywords, &interface, &PyNs3Ipv6Address_Type, &network, &PyNs3Ipv6Prefix_Type, &mask, &PyNs3Ipv6Address_Type, &defaultRouter)) {
        return NULL;
    }
    self->obj->RemoveAutoconfiguredAddress(interface, *((PyNs3Ipv6Address *) network)->obj, *((PyNs3Ipv6Prefix *) mask)->obj, *((PyNs3Ipv6Address *) defaultRouter)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_RegisterExtensions(PyNs3Ipv6L3Protocol *self)
{
    PyObject *py_retval;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    
    (helper_class == NULL)? (self->obj->RegisterExtensions()) : (self->obj->ns3::Ipv6L3Protocol::RegisterExtensions());
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_SetForwarding(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    bool val;
    PyObject *py_val;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", "val", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO", (char **) keywords, &i, &py_val)) {
        return NULL;
    }
    val = (bool) PyObject_IsTrue(py_val);
    (helper_class == NULL)? (self->obj->SetForwarding(i, val)) : (self->obj->ns3::Ipv6L3Protocol::SetForwarding(i, val));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetNAddresses(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    unsigned int interface;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetNAddresses(interface)) : (self->obj->ns3::Ipv6L3Protocol::GetNAddresses(interface));
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetProtocol(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::IpL4Protocol > retval;
    int protocolNumber;
    const char *keywords[] = {"protocolNumber", NULL};
    PyNs3IpL4Protocol *py_IpL4Protocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &protocolNumber)) {
        return NULL;
    }
    retval = self->obj->GetProtocol(protocolNumber);
    if (!(const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_IpL4Protocol = NULL;
    } else {
        py_IpL4Protocol = (PyNs3IpL4Protocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_IpL4Protocol);
    }
    
    if (py_IpL4Protocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval)))), &PyNs3IpL4Protocol_Type);
        py_IpL4Protocol = PyObject_GC_New(PyNs3IpL4Protocol, wrapper_type);
        py_IpL4Protocol->inst_dict = NULL;
        py_IpL4Protocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval))->Ref();
        py_IpL4Protocol->obj = const_cast<ns3::IpL4Protocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_IpL4Protocol->obj] = (PyObject *) py_IpL4Protocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_IpL4Protocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetMtu(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint16_t retval;
    unsigned int i;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetMtu(i)) : (self->obj->ns3::Ipv6L3Protocol::GetMtu(i));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_SetRoutingProtocol(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6RoutingProtocol *routingProtocol;
    ns3::Ipv6RoutingProtocol *routingProtocol_ptr;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"routingProtocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6RoutingProtocol_Type, &routingProtocol)) {
        return NULL;
    }
    routingProtocol_ptr = (routingProtocol ? routingProtocol->obj : NULL);
    (helper_class == NULL)? (self->obj->SetRoutingProtocol(ns3::Ptr< ns3::Ipv6RoutingProtocol  > (routingProtocol_ptr))) : (self->obj->ns3::Ipv6L3Protocol::SetRoutingProtocol(ns3::Ptr< ns3::Ipv6RoutingProtocol  > (routingProtocol_ptr)));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_Insert(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3IpL4Protocol *protocol;
    ns3::IpL4Protocol *protocol_ptr;
    const char *keywords[] = {"protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3IpL4Protocol_Type, &protocol)) {
        return NULL;
    }
    protocol_ptr = (protocol ? protocol->obj : NULL);
    self->obj->Insert(ns3::Ptr< ns3::IpL4Protocol  > (protocol_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_SetNode(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_IsForwarding(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int i;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->IsForwarding(i)) : (self->obj->ns3::Ipv6L3Protocol::IsForwarding(i));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_Receive(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    int protocol;
    PyObject *from;
    ns3::Address from2;
    PyObject *to;
    ns3::Address to2;
    ns3::NetDevice::PacketType packetType;
    const char *keywords[] = {"device", "p", "protocol", "from", "to", "packetType", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!iOOi", (char **) keywords, &PyNs3NetDevice_Type, &device, &PyNs3Packet_Type, &p, &protocol, &from, &to, &packetType)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    p_ptr = (p ? p->obj : NULL);
    if (protocol > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (PyObject_IsInstance(from, (PyObject*) &PyNs3Address_Type)) {
        from2 = *((PyNs3Address *) from)->obj;
    } else if (PyObject_IsInstance(from, (PyObject*) &PyNs3Ipv4Address_Type)) {
        from2 = *((PyNs3Ipv4Address *) from)->obj;
    } else if (PyObject_IsInstance(from, (PyObject*) &PyNs3Ipv6Address_Type)) {
        from2 = *((PyNs3Ipv6Address *) from)->obj;
    } else if (PyObject_IsInstance(from, (PyObject*) &PyNs3Mac48Address_Type)) {
        from2 = *((PyNs3Mac48Address *) from)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", from->ob_type->tp_name);
        return NULL;
    }
    if (PyObject_IsInstance(to, (PyObject*) &PyNs3Address_Type)) {
        to2 = *((PyNs3Address *) to)->obj;
    } else if (PyObject_IsInstance(to, (PyObject*) &PyNs3Ipv4Address_Type)) {
        to2 = *((PyNs3Ipv4Address *) to)->obj;
    } else if (PyObject_IsInstance(to, (PyObject*) &PyNs3Ipv6Address_Type)) {
        to2 = *((PyNs3Ipv6Address *) to)->obj;
    } else if (PyObject_IsInstance(to, (PyObject*) &PyNs3Mac48Address_Type)) {
        to2 = *((PyNs3Mac48Address *) to)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", to->ob_type->tp_name);
        return NULL;
    }
    self->obj->Receive(ns3::Ptr< ns3::NetDevice  > (device_ptr), ns3::Ptr< ns3::Packet  > (p_ptr), protocol, from2, to2, packetType);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetAddress(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interfaceIndex;
    unsigned int addressIndex;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"interfaceIndex", "addressIndex", NULL};
    PyNs3Ipv6InterfaceAddress *py_Ipv6InterfaceAddress;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &interfaceIndex, &addressIndex)) {
        return NULL;
    }
    ns3::Ipv6InterfaceAddress retval = (helper_class == NULL)? (self->obj->GetAddress(interfaceIndex, addressIndex)) : (self->obj->ns3::Ipv6L3Protocol::GetAddress(interfaceIndex, addressIndex));
    py_Ipv6InterfaceAddress = PyObject_New(PyNs3Ipv6InterfaceAddress, &PyNs3Ipv6InterfaceAddress_Type);
    py_Ipv6InterfaceAddress->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6InterfaceAddress->obj = new ns3::Ipv6InterfaceAddress(retval);
    PyNs3Ipv6InterfaceAddress_wrapper_registry[(void *) py_Ipv6InterfaceAddress->obj] = (PyObject *) py_Ipv6InterfaceAddress;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6InterfaceAddress);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_Remove(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3IpL4Protocol *protocol;
    ns3::IpL4Protocol *protocol_ptr;
    const char *keywords[] = {"protocol", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3IpL4Protocol_Type, &protocol)) {
        return NULL;
    }
    protocol_ptr = (protocol ? protocol->obj : NULL);
    self->obj->Remove(ns3::Ptr< ns3::IpL4Protocol  > (protocol_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetIcmpv6(PyNs3Ipv6L3Protocol *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Icmpv6L4Protocol > retval;
    PyNs3Icmpv6L4Protocol *py_Icmpv6L4Protocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetIcmpv6();
    if (!(const_cast<ns3::Icmpv6L4Protocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Icmpv6L4Protocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Icmpv6L4Protocol = NULL;
    } else {
        py_Icmpv6L4Protocol = (PyNs3Icmpv6L4Protocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Icmpv6L4Protocol);
    }
    
    if (py_Icmpv6L4Protocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Icmpv6L4Protocol *> (ns3::PeekPointer (retval)))), &PyNs3Icmpv6L4Protocol_Type);
        py_Icmpv6L4Protocol = PyObject_GC_New(PyNs3Icmpv6L4Protocol, wrapper_type);
        py_Icmpv6L4Protocol->inst_dict = NULL;
        py_Icmpv6L4Protocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Icmpv6L4Protocol *> (ns3::PeekPointer (retval))->Ref();
        py_Icmpv6L4Protocol->obj = const_cast<ns3::Icmpv6L4Protocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Icmpv6L4Protocol->obj] = (PyObject *) py_Icmpv6L4Protocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Icmpv6L4Protocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetInterfaceForPrefix(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int32_t retval;
    PyNs3Ipv6Address *addr;
    PyNs3Ipv6Prefix *mask;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"addr", "mask", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv6Address_Type, &addr, &PyNs3Ipv6Prefix_Type, &mask)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetInterfaceForPrefix(*((PyNs3Ipv6Address *) addr)->obj, *((PyNs3Ipv6Prefix *) mask)->obj)) : (self->obj->ns3::Ipv6L3Protocol::GetInterfaceForPrefix(*((PyNs3Ipv6Address *) addr)->obj, *((PyNs3Ipv6Prefix *) mask)->obj));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetNetDevice(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    unsigned int i;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetNetDevice(i)) : (self->obj->ns3::Ipv6L3Protocol::GetNetDevice(i));
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetRoutingProtocol(PyNs3Ipv6L3Protocol *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6RoutingProtocol > retval;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    PyNs3Ipv6RoutingProtocol *py_Ipv6RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = (helper_class == NULL)? (self->obj->GetRoutingProtocol()) : (self->obj->ns3::Ipv6L3Protocol::GetRoutingProtocol());
    if (!(const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv6RoutingProtocol = NULL;
    } else {
        py_Ipv6RoutingProtocol = (PyNs3Ipv6RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6RoutingProtocol);
    }
    
    if (py_Ipv6RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6RoutingProtocol_Type);
        py_Ipv6RoutingProtocol = PyObject_GC_New(PyNs3Ipv6RoutingProtocol, wrapper_type);
        py_Ipv6RoutingProtocol->inst_dict = NULL;
        py_Ipv6RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv6RoutingProtocol->obj = const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6RoutingProtocol->obj] = (PyObject *) py_Ipv6RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingProtocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_RemoveAddress(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int interfaceIndex;
    unsigned int addressIndex;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"interfaceIndex", "addressIndex", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &interfaceIndex, &addressIndex)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->RemoveAddress(interfaceIndex, addressIndex)) : (self->obj->ns3::Ipv6L3Protocol::RemoveAddress(interfaceIndex, addressIndex));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetMetric(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint16_t retval;
    unsigned int i;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->GetMetric(i)) : (self->obj->ns3::Ipv6L3Protocol::GetMetric(i));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_SetUp(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    (helper_class == NULL)? (self->obj->SetUp(i)) : (self->obj->ns3::Ipv6L3Protocol::SetUp(i));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_CreateRawSocket(PyNs3Ipv6L3Protocol *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Socket > retval;
    PyNs3Socket *py_Socket;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->CreateRawSocket();
    if (!(const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Socket__PythonHelper).name())
    {
        py_Socket = reinterpret_cast< PyNs3Socket* >(reinterpret_cast< PyNs3Socket__PythonHelper* >(const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Socket);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Socket *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Socket = NULL;
        } else {
            py_Socket = (PyNs3Socket *) wrapper_lookup_iter->second;
            Py_INCREF(py_Socket);
        }
    
        if (py_Socket == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))), &PyNs3Socket_Type);
            py_Socket = PyObject_GC_New(PyNs3Socket, wrapper_type);
            py_Socket->inst_dict = NULL;
            py_Socket->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Socket *> (ns3::PeekPointer (retval))->Ref();
            py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Socket->obj] = (PyObject *) py_Socket;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Socket);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_IsUp(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    unsigned int i;
    PyNs3Ipv6L3Protocol__PythonHelper *helper_class = dynamic_cast<PyNs3Ipv6L3Protocol__PythonHelper*> (self->obj);
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->IsUp(i)) : (self->obj->ns3::Ipv6L3Protocol::IsUp(i));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6L3Protocol_GetInterface(PyNs3Ipv6L3Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6Interface > retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    PyNs3Ipv6Interface *py_Ipv6Interface;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = self->obj->GetInterface(i);
    if (!(const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Ipv6Interface__PythonHelper).name())
    {
        py_Ipv6Interface = reinterpret_cast< PyNs3Ipv6Interface* >(reinterpret_cast< PyNs3Ipv6Interface__PythonHelper* >(const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Ipv6Interface->obj = const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Ipv6Interface);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Ipv6Interface = NULL;
        } else {
            py_Ipv6Interface = (PyNs3Ipv6Interface *) wrapper_lookup_iter->second;
            Py_INCREF(py_Ipv6Interface);
        }
    
        if (py_Ipv6Interface == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6Interface_Type);
            py_Ipv6Interface = PyObject_GC_New(PyNs3Ipv6Interface, wrapper_type);
            py_Ipv6Interface->inst_dict = NULL;
            py_Ipv6Interface->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval))->Ref();
            py_Ipv6Interface->obj = const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6Interface->obj] = (PyObject *) py_Ipv6Interface;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Interface);
    return py_retval;
}

static PyMethodDef PyNs3Ipv6L3Protocol_methods[] = {
    {(char *) "GetNInterfaces", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetNInterfaces, METH_NOARGS, NULL },
    {(char *) "GetInterfaceForAddress", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetInterfaceForAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetMetric", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_SetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInterfaceForDevice", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetInterfaceForDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Send", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddAutoconfiguredAddress", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_AddAutoconfiguredAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "DeleteRawSocket", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_DeleteRawSocket, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDown", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_SetDown, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RegisterOptions", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_RegisterOptions, METH_NOARGS, NULL },
    {(char *) "AddAddress", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_AddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDefaultTtl", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_SetDefaultTtl, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddInterface", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_AddInterface, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RemoveAutoconfiguredAddress", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_RemoveAutoconfiguredAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RegisterExtensions", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_RegisterExtensions, METH_NOARGS, NULL },
    {(char *) "SetForwarding", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_SetForwarding, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNAddresses", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetNAddresses, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetProtocol", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMtu", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetMtu, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRoutingProtocol", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_SetRoutingProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Insert", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_Insert, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsForwarding", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_IsForwarding, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Receive", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_Receive, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Remove", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_Remove, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetIcmpv6", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetIcmpv6, METH_NOARGS, NULL },
    {(char *) "GetInterfaceForPrefix", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetInterfaceForPrefix, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNetDevice", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetNetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetRoutingProtocol", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetRoutingProtocol, METH_NOARGS, NULL },
    {(char *) "RemoveAddress", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_RemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMetric", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetUp", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_SetUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "CreateRawSocket", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_CreateRawSocket, METH_NOARGS, NULL },
    {(char *) "IsUp", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_IsUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInterface", (PyCFunction) _wrap_PyNs3Ipv6L3Protocol_GetInterface, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3Ipv6L3Protocol__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3Ipv6L3Protocol__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3Ipv6L3Protocol__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "DoDispose", (PyCFunction) PyNs3Ipv6L3Protocol__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6L3Protocol__tp_clear(PyNs3Ipv6L3Protocol *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6L3Protocol *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6L3Protocol__tp_traverse(PyNs3Ipv6L3Protocol *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3Ipv6L3Protocol__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3Ipv6L3Protocol__tp_dealloc(PyNs3Ipv6L3Protocol *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6L3Protocol__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6L3Protocol__tp_richcompare (PyNs3Ipv6L3Protocol *PYBINDGEN_UNUSED(self), PyNs3Ipv6L3Protocol *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6L3Protocol_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6L3Protocol_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6L3Protocol",            /* tp_name */
    sizeof(PyNs3Ipv6L3Protocol),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6L3Protocol__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6L3Protocol__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6L3Protocol__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6L3Protocol__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6L3Protocol_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6L3Protocol, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6L3Protocol__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3Ipv6MulticastRoute__get_MAX_INTERFACES(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(ns3::Ipv6MulticastRoute::MAX_INTERFACES));
    return py_retval;
}
static PyObject* _wrap_PyNs3Ipv6MulticastRoute__get_MAX_TTL(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(ns3::Ipv6MulticastRoute::MAX_TTL));
    return py_retval;
}
static PyGetSetDef Ns3Ipv6MulticastRouteMeta__getsets[] = {
    {
        (char*) "MAX_TTL", /* attribute name */
        (getter) _wrap_PyNs3Ipv6MulticastRoute__get_MAX_TTL, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MAX_INTERFACES", /* attribute name */
        (getter) _wrap_PyNs3Ipv6MulticastRoute__get_MAX_INTERFACES, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv6MulticastRouteMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv6MulticastRouteMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv6MulticastRouteMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Ipv6MulticastRoute__tp_init__0(PyNs3Ipv6MulticastRoute *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6MulticastRoute *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6MulticastRoute_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6MulticastRoute(*((PyNs3Ipv6MulticastRoute *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6MulticastRoute__tp_init__1(PyNs3Ipv6MulticastRoute *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6MulticastRoute();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6MulticastRoute__tp_init(PyNs3Ipv6MulticastRoute *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6MulticastRoute__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6MulticastRoute__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoute_GetParent(PyNs3Ipv6MulticastRoute *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetParent();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoute_SetGroup(PyNs3Ipv6MulticastRoute *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *group;
    const char *keywords[] = {"group", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &group)) {
        return NULL;
    }
    self->obj->SetGroup(*((PyNs3Ipv6Address *) group)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoute_GetOrigin(PyNs3Ipv6MulticastRoute *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetOrigin();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoute_SetOutputTtl(PyNs3Ipv6MulticastRoute *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int oif;
    unsigned int ttl;
    const char *keywords[] = {"oif", "ttl", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "II", (char **) keywords, &oif, &ttl)) {
        return NULL;
    }
    self->obj->SetOutputTtl(oif, ttl);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoute_SetOrigin(PyNs3Ipv6MulticastRoute *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *origin;
    const char *keywords[] = {"origin", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &origin)) {
        return NULL;
    }
    self->obj->SetOrigin(*((PyNs3Ipv6Address *) origin)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoute_GetOutputTtl(PyNs3Ipv6MulticastRoute *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    unsigned int oif;
    const char *keywords[] = {"oif", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &oif)) {
        return NULL;
    }
    if (PyErr_Warn(PyExc_DeprecationWarning, (char *) "Deprecated")) {
        return NULL;
    }
    retval = self->obj->GetOutputTtl(oif);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoute_GetOutputTtlMap(PyNs3Ipv6MulticastRoute *self)
{
    PyObject *py_retval;
    std::map< unsigned int, unsigned int > retval;
    Pystd__map__lt___unsigned_int__unsigned_int___gt__ *py_std__map__lt___unsigned_int__unsigned_int___gt__;
    
    retval = self->obj->GetOutputTtlMap();
    py_std__map__lt___unsigned_int__unsigned_int___gt__ = PyObject_New(Pystd__map__lt___unsigned_int__unsigned_int___gt__, &Pystd__map__lt___unsigned_int__unsigned_int___gt___Type);
    py_std__map__lt___unsigned_int__unsigned_int___gt__->obj = new std::map< unsigned int, unsigned int >(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__map__lt___unsigned_int__unsigned_int___gt__);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoute_SetParent(PyNs3Ipv6MulticastRoute *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int iif;
    const char *keywords[] = {"iif", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &iif)) {
        return NULL;
    }
    self->obj->SetParent(iif);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6MulticastRoute_GetGroup(PyNs3Ipv6MulticastRoute *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetGroup();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6MulticastRoute__copy__(PyNs3Ipv6MulticastRoute *self)
{

    PyNs3Ipv6MulticastRoute *py_copy;
    py_copy = PyObject_New(PyNs3Ipv6MulticastRoute, &PyNs3Ipv6MulticastRoute_Type);
    py_copy->obj = new ns3::Ipv6MulticastRoute(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6MulticastRoute_methods[] = {
    {(char *) "GetParent", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoute_GetParent, METH_NOARGS, NULL },
    {(char *) "SetGroup", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoute_SetGroup, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOrigin", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoute_GetOrigin, METH_NOARGS, NULL },
    {(char *) "SetOutputTtl", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoute_SetOutputTtl, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetOrigin", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoute_SetOrigin, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOutputTtl", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoute_GetOutputTtl, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetOutputTtlMap", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoute_GetOutputTtlMap, METH_NOARGS, NULL },
    {(char *) "SetParent", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoute_SetParent, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetGroup", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoute_GetGroup, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6MulticastRoute__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv6MulticastRoute__tp_dealloc(PyNs3Ipv6MulticastRoute *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::Ipv6MulticastRoute *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyNs3Ipv6MulticastRoute__tp_str(PyNs3Ipv6MulticastRoute *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyNs3Ipv6MulticastRoute__tp_richcompare (PyNs3Ipv6MulticastRoute *PYBINDGEN_UNUSED(self), PyNs3Ipv6MulticastRoute *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6MulticastRoute_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6MulticastRoute_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6MulticastRoute",            /* tp_name */
    sizeof(PyNs3Ipv6MulticastRoute),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6MulticastRoute__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyNs3Ipv6MulticastRoute__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6MulticastRoute__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6MulticastRoute_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6MulticastRoute__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyNs3Ipv6RawSocketFactory__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'Ipv6RawSocketFactory' cannot be constructed (have pure virtual methods but no helper class)");
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6RawSocketFactory_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6RawSocketFactory::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

static PyMethodDef PyNs3Ipv6RawSocketFactory_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6RawSocketFactory_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6RawSocketFactory__tp_clear(PyNs3Ipv6RawSocketFactory *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6RawSocketFactory *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6RawSocketFactory__tp_traverse(PyNs3Ipv6RawSocketFactory *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6RawSocketFactory__tp_dealloc(PyNs3Ipv6RawSocketFactory *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6RawSocketFactory__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6RawSocketFactory__tp_richcompare (PyNs3Ipv6RawSocketFactory *PYBINDGEN_UNUSED(self), PyNs3Ipv6RawSocketFactory *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6RawSocketFactory_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6RawSocketFactory_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6RawSocketFactory",            /* tp_name */
    sizeof(PyNs3Ipv6RawSocketFactory),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6RawSocketFactory__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6RawSocketFactory__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6RawSocketFactory__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6RawSocketFactory__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6RawSocketFactory_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6RawSocketFactory, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6RawSocketFactory__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6Route__tp_init__0(PyNs3Ipv6Route *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6Route *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Route_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6Route(*((PyNs3Ipv6Route *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6Route__tp_init__1(PyNs3Ipv6Route *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6Route();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6Route__tp_init(PyNs3Ipv6Route *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6Route__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6Route__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6Route_GetOutputDevice(PyNs3Ipv6Route *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetOutputDevice();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Route_GetGateway(PyNs3Ipv6Route *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetGateway();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Route_SetDestination(PyNs3Ipv6Route *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dest;
    const char *keywords[] = {"dest", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &dest)) {
        return NULL;
    }
    self->obj->SetDestination(*((PyNs3Ipv6Address *) dest)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Route_SetGateway(PyNs3Ipv6Route *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *gw;
    const char *keywords[] = {"gw", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &gw)) {
        return NULL;
    }
    self->obj->SetGateway(*((PyNs3Ipv6Address *) gw)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Route_SetOutputDevice(PyNs3Ipv6Route *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *outputDevice;
    ns3::NetDevice *outputDevice_ptr;
    const char *keywords[] = {"outputDevice", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &outputDevice)) {
        return NULL;
    }
    outputDevice_ptr = (outputDevice ? outputDevice->obj : NULL);
    self->obj->SetOutputDevice(ns3::Ptr< ns3::NetDevice  > (outputDevice_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Route_GetSource(PyNs3Ipv6Route *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetSource();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Route_GetDestination(PyNs3Ipv6Route *self)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    ns3::Ipv6Address retval = self->obj->GetDestination();
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(retval);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6Route_SetSource(PyNs3Ipv6Route *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *src;
    const char *keywords[] = {"src", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &src)) {
        return NULL;
    }
    self->obj->SetSource(*((PyNs3Ipv6Address *) src)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6Route__copy__(PyNs3Ipv6Route *self)
{

    PyNs3Ipv6Route *py_copy;
    py_copy = PyObject_New(PyNs3Ipv6Route, &PyNs3Ipv6Route_Type);
    py_copy->obj = new ns3::Ipv6Route(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6Route_methods[] = {
    {(char *) "GetOutputDevice", (PyCFunction) _wrap_PyNs3Ipv6Route_GetOutputDevice, METH_NOARGS, NULL },
    {(char *) "GetGateway", (PyCFunction) _wrap_PyNs3Ipv6Route_GetGateway, METH_NOARGS, NULL },
    {(char *) "SetDestination", (PyCFunction) _wrap_PyNs3Ipv6Route_SetDestination, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetGateway", (PyCFunction) _wrap_PyNs3Ipv6Route_SetGateway, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetOutputDevice", (PyCFunction) _wrap_PyNs3Ipv6Route_SetOutputDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetSource", (PyCFunction) _wrap_PyNs3Ipv6Route_GetSource, METH_NOARGS, NULL },
    {(char *) "GetDestination", (PyCFunction) _wrap_PyNs3Ipv6Route_GetDestination, METH_NOARGS, NULL },
    {(char *) "SetSource", (PyCFunction) _wrap_PyNs3Ipv6Route_SetSource, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6Route__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3Ipv6Route__tp_dealloc(PyNs3Ipv6Route *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::Ipv6Route *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyNs3Ipv6Route__tp_str(PyNs3Ipv6Route *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyNs3Ipv6Route__tp_richcompare (PyNs3Ipv6Route *PYBINDGEN_UNUSED(self), PyNs3Ipv6Route *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6Route_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6Route_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6Route",            /* tp_name */
    sizeof(PyNs3Ipv6Route),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6Route__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyNs3Ipv6Route__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6Route__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6Route_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6Route__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyNs3Ipv6RoutingProtocol__tp_init(void)
{
    PyErr_SetString(PyExc_TypeError, "class 'Ipv6RoutingProtocol' cannot be constructed (have pure virtual methods but no helper class)");
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6RoutingProtocol_NotifyAddAddress(PyNs3Ipv6RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv6InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv6InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyAddAddress(interface, *((PyNs3Ipv6InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingProtocol_NotifyAddRoute(PyNs3Ipv6RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Prefix *mask;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    PyNs3Ipv6Address *prefixToUse = NULL;
    const char *keywords[] = {"dst", "mask", "nextHop", "interface", "prefixToUse", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!I|O!", (char **) keywords, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Prefix_Type, &mask, &PyNs3Ipv6Address_Type, &nextHop, &interface, &PyNs3Ipv6Address_Type, &prefixToUse)) {
        return NULL;
    }
    self->obj->NotifyAddRoute(*((PyNs3Ipv6Address *) dst)->obj, *((PyNs3Ipv6Prefix *) mask)->obj, *((PyNs3Ipv6Address *) nextHop)->obj, interface, (prefixToUse ? (*((PyNs3Ipv6Address *) prefixToUse)->obj) : ns3::Ipv6Address::GetZero( )));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingProtocol_NotifyInterfaceUp(PyNs3Ipv6RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceUp(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingProtocol_NotifyInterfaceDown(PyNs3Ipv6RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceDown(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingProtocol_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6RoutingProtocol::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingProtocol_NotifyRemoveRoute(PyNs3Ipv6RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Prefix *mask;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    PyNs3Ipv6Address *prefixToUse = NULL;
    const char *keywords[] = {"dst", "mask", "nextHop", "interface", "prefixToUse", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!I|O!", (char **) keywords, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Prefix_Type, &mask, &PyNs3Ipv6Address_Type, &nextHop, &interface, &PyNs3Ipv6Address_Type, &prefixToUse)) {
        return NULL;
    }
    self->obj->NotifyRemoveRoute(*((PyNs3Ipv6Address *) dst)->obj, *((PyNs3Ipv6Prefix *) mask)->obj, *((PyNs3Ipv6Address *) nextHop)->obj, interface, (prefixToUse ? (*((PyNs3Ipv6Address *) prefixToUse)->obj) : ns3::Ipv6Address::GetZero( )));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingProtocol_SetIpv6(PyNs3Ipv6RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    const char *keywords[] = {"ipv6", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6_Type, &ipv6)) {
        return NULL;
    }
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    self->obj->SetIpv6(ns3::Ptr< ns3::Ipv6  > (ipv6_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingProtocol_PrintRoutingTable(PyNs3Ipv6RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTable(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingProtocol_RouteOutput(PyNs3Ipv6RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6Route > retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv6Header *header;
    PyNs3NetDevice *oif;
    ns3::NetDevice *oif_ptr;
    ns3::Socket::SocketErrno  sockerr;
    const char *keywords[] = {"p", "header", "oif", "sockerr", NULL};
    PyNs3Ipv6Route *py_Ipv6Route;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!i", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv6Header_Type, &header, &PyNs3NetDevice_Type, &oif, &sockerr)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    oif_ptr = (oif ? oif->obj : NULL);
    retval = self->obj->RouteOutput(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv6Header *) header)->obj, ns3::Ptr< ns3::NetDevice  > (oif_ptr), sockerr);
    if (!(const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Ipv6Route = NULL;
    } else {
        py_Ipv6Route = (PyNs3Ipv6Route *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6Route);
    }
    
    if (py_Ipv6Route == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6Route_Type);
        py_Ipv6Route = PyObject_New(PyNs3Ipv6Route, wrapper_type);
        py_Ipv6Route->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv6Route->obj = const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Ipv6Route->obj] = (PyObject *) py_Ipv6Route;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Route);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6RoutingProtocol_NotifyRemoveAddress(PyNs3Ipv6RoutingProtocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv6InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv6InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyRemoveAddress(interface, *((PyNs3Ipv6InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3Ipv6RoutingProtocol_methods[] = {
    {(char *) "NotifyAddAddress", (PyCFunction) _wrap_PyNs3Ipv6RoutingProtocol_NotifyAddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyAddRoute", (PyCFunction) _wrap_PyNs3Ipv6RoutingProtocol_NotifyAddRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceUp", (PyCFunction) _wrap_PyNs3Ipv6RoutingProtocol_NotifyInterfaceUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceDown", (PyCFunction) _wrap_PyNs3Ipv6RoutingProtocol_NotifyInterfaceDown, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6RoutingProtocol_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "NotifyRemoveRoute", (PyCFunction) _wrap_PyNs3Ipv6RoutingProtocol_NotifyRemoveRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetIpv6", (PyCFunction) _wrap_PyNs3Ipv6RoutingProtocol_SetIpv6, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTable", (PyCFunction) _wrap_PyNs3Ipv6RoutingProtocol_PrintRoutingTable, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RouteOutput", (PyCFunction) _wrap_PyNs3Ipv6RoutingProtocol_RouteOutput, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyRemoveAddress", (PyCFunction) _wrap_PyNs3Ipv6RoutingProtocol_NotifyRemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6RoutingProtocol__tp_clear(PyNs3Ipv6RoutingProtocol *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6RoutingProtocol *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6RoutingProtocol__tp_traverse(PyNs3Ipv6RoutingProtocol *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6RoutingProtocol__tp_dealloc(PyNs3Ipv6RoutingProtocol *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6RoutingProtocol__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6RoutingProtocol__tp_richcompare (PyNs3Ipv6RoutingProtocol *PYBINDGEN_UNUSED(self), PyNs3Ipv6RoutingProtocol *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6RoutingProtocol_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6RoutingProtocol_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6RoutingProtocol",            /* tp_name */
    sizeof(PyNs3Ipv6RoutingProtocol),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6RoutingProtocol__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6RoutingProtocol__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6RoutingProtocol__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6RoutingProtocol__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6RoutingProtocol_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6RoutingProtocol, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6RoutingProtocol__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6StaticRouting__tp_init__0(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6StaticRouting *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6StaticRouting_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6StaticRouting(*((PyNs3Ipv6StaticRouting *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6StaticRouting__tp_init__1(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6StaticRouting();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6StaticRouting__tp_init(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6StaticRouting__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6StaticRouting__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_NotifyAddAddress(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv6InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv6InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyAddAddress(interface, *((PyNs3Ipv6InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv6StaticRouting_RemoveMulticastRoute__0(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv6Address *origin;
    PyNs3Ipv6Address *group;
    unsigned int inputInterface;
    const char *keywords[] = {"origin", "group", "inputInterface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PyNs3Ipv6Address_Type, &origin, &PyNs3Ipv6Address_Type, &group, &inputInterface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->RemoveMulticastRoute(*((PyNs3Ipv6Address *) origin)->obj, *((PyNs3Ipv6Address *) group)->obj, inputInterface);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6StaticRouting_RemoveMulticastRoute__1(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->RemoveMulticastRoute(i);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv6StaticRouting_RemoveMulticastRoute(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6StaticRouting_RemoveMulticastRoute__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6StaticRouting_RemoveMulticastRoute__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}



PyObject *
_wrap_PyNs3Ipv6StaticRouting_AddNetworkRouteTo__0(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *network;
    PyNs3Ipv6Prefix *networkPrefix;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    unsigned int metric = 0;
    const char *keywords[] = {"network", "networkPrefix", "nextHop", "interface", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!I|I", (char **) keywords, &PyNs3Ipv6Address_Type, &network, &PyNs3Ipv6Prefix_Type, &networkPrefix, &PyNs3Ipv6Address_Type, &nextHop, &interface, &metric)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddNetworkRouteTo(*((PyNs3Ipv6Address *) network)->obj, *((PyNs3Ipv6Prefix *) networkPrefix)->obj, *((PyNs3Ipv6Address *) nextHop)->obj, interface, metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6StaticRouting_AddNetworkRouteTo__1(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *network;
    PyNs3Ipv6Prefix *networkPrefix;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    PyNs3Ipv6Address *prefixToUse;
    unsigned int metric = 0;
    const char *keywords[] = {"network", "networkPrefix", "nextHop", "interface", "prefixToUse", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!IO!|I", (char **) keywords, &PyNs3Ipv6Address_Type, &network, &PyNs3Ipv6Prefix_Type, &networkPrefix, &PyNs3Ipv6Address_Type, &nextHop, &interface, &PyNs3Ipv6Address_Type, &prefixToUse, &metric)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddNetworkRouteTo(*((PyNs3Ipv6Address *) network)->obj, *((PyNs3Ipv6Prefix *) networkPrefix)->obj, *((PyNs3Ipv6Address *) nextHop)->obj, interface, *((PyNs3Ipv6Address *) prefixToUse)->obj, metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6StaticRouting_AddNetworkRouteTo__2(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *network;
    PyNs3Ipv6Prefix *networkPrefix;
    unsigned int interface;
    unsigned int metric = 0;
    const char *keywords[] = {"network", "networkPrefix", "interface", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I|I", (char **) keywords, &PyNs3Ipv6Address_Type, &network, &PyNs3Ipv6Prefix_Type, &networkPrefix, &interface, &metric)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddNetworkRouteTo(*((PyNs3Ipv6Address *) network)->obj, *((PyNs3Ipv6Prefix *) networkPrefix)->obj, interface, metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv6StaticRouting_AddNetworkRouteTo(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3Ipv6StaticRouting_AddNetworkRouteTo__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6StaticRouting_AddNetworkRouteTo__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3Ipv6StaticRouting_AddNetworkRouteTo__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_GetMetric(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    unsigned int index;
    const char *keywords[] = {"index", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    retval = self->obj->GetMetric(index);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_GetRoute(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    PyNs3Ipv6RoutingTableEntry *py_Ipv6RoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    ns3::Ipv6RoutingTableEntry retval = self->obj->GetRoute(i);
    py_Ipv6RoutingTableEntry = PyObject_New(PyNs3Ipv6RoutingTableEntry, &PyNs3Ipv6RoutingTableEntry_Type);
    py_Ipv6RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6RoutingTableEntry->obj = new ns3::Ipv6RoutingTableEntry(retval);
    PyNs3Ipv6RoutingTableEntry_wrapper_registry[(void *) py_Ipv6RoutingTableEntry->obj] = (PyObject *) py_Ipv6RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingTableEntry);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_HasNetworkDest(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Ipv6Address *dest;
    unsigned int interfaceIndex;
    const char *keywords[] = {"dest", "interfaceIndex", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3Ipv6Address_Type, &dest, &interfaceIndex)) {
        return NULL;
    }
    retval = self->obj->HasNetworkDest(*((PyNs3Ipv6Address *) dest)->obj, interfaceIndex);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_NotifyAddRoute(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Prefix *mask;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    PyNs3Ipv6Address *prefixToUse = NULL;
    const char *keywords[] = {"dst", "mask", "nextHop", "interface", "prefixToUse", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!I|O!", (char **) keywords, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Prefix_Type, &mask, &PyNs3Ipv6Address_Type, &nextHop, &interface, &PyNs3Ipv6Address_Type, &prefixToUse)) {
        return NULL;
    }
    self->obj->NotifyAddRoute(*((PyNs3Ipv6Address *) dst)->obj, *((PyNs3Ipv6Prefix *) mask)->obj, *((PyNs3Ipv6Address *) nextHop)->obj, interface, (prefixToUse ? (*((PyNs3Ipv6Address *) prefixToUse)->obj) : ns3::Ipv6Address::GetZero( )));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_NotifyInterfaceDown(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceDown(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_GetDefaultRoute(PyNs3Ipv6StaticRouting *self)
{
    PyObject *py_retval;
    PyNs3Ipv6RoutingTableEntry *py_Ipv6RoutingTableEntry;
    
    ns3::Ipv6RoutingTableEntry retval = self->obj->GetDefaultRoute();
    py_Ipv6RoutingTableEntry = PyObject_New(PyNs3Ipv6RoutingTableEntry, &PyNs3Ipv6RoutingTableEntry_Type);
    py_Ipv6RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6RoutingTableEntry->obj = new ns3::Ipv6RoutingTableEntry(retval);
    PyNs3Ipv6RoutingTableEntry_wrapper_registry[(void *) py_Ipv6RoutingTableEntry->obj] = (PyObject *) py_Ipv6RoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingTableEntry);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_GetNMulticastRoutes(PyNs3Ipv6StaticRouting *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNMulticastRoutes();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_NotifyRemoveRoute(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Prefix *mask;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    PyNs3Ipv6Address *prefixToUse = NULL;
    const char *keywords[] = {"dst", "mask", "nextHop", "interface", "prefixToUse", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!I|O!", (char **) keywords, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Prefix_Type, &mask, &PyNs3Ipv6Address_Type, &nextHop, &interface, &PyNs3Ipv6Address_Type, &prefixToUse)) {
        return NULL;
    }
    self->obj->NotifyRemoveRoute(*((PyNs3Ipv6Address *) dst)->obj, *((PyNs3Ipv6Prefix *) mask)->obj, *((PyNs3Ipv6Address *) nextHop)->obj, interface, (prefixToUse ? (*((PyNs3Ipv6Address *) prefixToUse)->obj) : ns3::Ipv6Address::GetZero( )));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_SetIpv6(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    const char *keywords[] = {"ipv6", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6_Type, &ipv6)) {
        return NULL;
    }
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    self->obj->SetIpv6(ns3::Ptr< ns3::Ipv6  > (ipv6_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv6StaticRouting_RemoveRoute__0(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->RemoveRoute(i);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6StaticRouting_RemoveRoute__1(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *network;
    PyNs3Ipv6Prefix *prefix;
    unsigned int ifIndex;
    PyNs3Ipv6Address *prefixToUse;
    const char *keywords[] = {"network", "prefix", "ifIndex", "prefixToUse", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!IO!", (char **) keywords, &PyNs3Ipv6Address_Type, &network, &PyNs3Ipv6Prefix_Type, &prefix, &ifIndex, &PyNs3Ipv6Address_Type, &prefixToUse)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->RemoveRoute(*((PyNs3Ipv6Address *) network)->obj, *((PyNs3Ipv6Prefix *) prefix)->obj, ifIndex, *((PyNs3Ipv6Address *) prefixToUse)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv6StaticRouting_RemoveRoute(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6StaticRouting_RemoveRoute__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6StaticRouting_RemoveRoute__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6StaticRouting::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_NotifyInterfaceUp(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceUp(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv6StaticRouting_AddHostRouteTo__0(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dest;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    PyNs3Ipv6Address *prefixToUse = NULL;
    unsigned int metric = 0;
    const char *keywords[] = {"dest", "nextHop", "interface", "prefixToUse", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I|O!I", (char **) keywords, &PyNs3Ipv6Address_Type, &dest, &PyNs3Ipv6Address_Type, &nextHop, &interface, &PyNs3Ipv6Address_Type, &prefixToUse, &metric)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddHostRouteTo(*((PyNs3Ipv6Address *) dest)->obj, *((PyNs3Ipv6Address *) nextHop)->obj, interface, (prefixToUse ? (*((PyNs3Ipv6Address *) prefixToUse)->obj) : ns3::Ipv6Address(((const char*)"::"))), metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv6StaticRouting_AddHostRouteTo__1(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dest;
    unsigned int interface;
    unsigned int metric = 0;
    const char *keywords[] = {"dest", "interface", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I|I", (char **) keywords, &PyNs3Ipv6Address_Type, &dest, &interface, &metric)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddHostRouteTo(*((PyNs3Ipv6Address *) dest)->obj, interface, metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv6StaticRouting_AddHostRouteTo(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6StaticRouting_AddHostRouteTo__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6StaticRouting_AddHostRouteTo__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_GetMulticastRoute(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    PyNs3Ipv6MulticastRoutingTableEntry *py_Ipv6MulticastRoutingTableEntry;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    ns3::Ipv6MulticastRoutingTableEntry retval = self->obj->GetMulticastRoute(i);
    py_Ipv6MulticastRoutingTableEntry = PyObject_New(PyNs3Ipv6MulticastRoutingTableEntry, &PyNs3Ipv6MulticastRoutingTableEntry_Type);
    py_Ipv6MulticastRoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6MulticastRoutingTableEntry->obj = new ns3::Ipv6MulticastRoutingTableEntry(retval);
    PyNs3Ipv6MulticastRoutingTableEntry_wrapper_registry[(void *) py_Ipv6MulticastRoutingTableEntry->obj] = (PyObject *) py_Ipv6MulticastRoutingTableEntry;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6MulticastRoutingTableEntry);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_PrintRoutingTable(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTable(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_NotifyRemoveAddress(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv6InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv6InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyRemoveAddress(interface, *((PyNs3Ipv6InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_GetNRoutes(PyNs3Ipv6StaticRouting *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNRoutes();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_AddMulticastRoute(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *origin;
    PyNs3Ipv6Address *group;
    unsigned int inputInterface;
    std::vector< unsigned int > outputInterfaces_value;
    const char *keywords[] = {"origin", "group", "inputInterface", "outputInterfaces", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!IO&", (char **) keywords, &PyNs3Ipv6Address_Type, &origin, &PyNs3Ipv6Address_Type, &group, &inputInterface, _wrap_convert_py2c__std__vector__lt___unsigned_int___gt__, &outputInterfaces_value)) {
        return NULL;
    }
    self->obj->AddMulticastRoute(*((PyNs3Ipv6Address *) origin)->obj, *((PyNs3Ipv6Address *) group)->obj, inputInterface, outputInterfaces_value);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_RouteOutput(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6Route > retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv6Header *header;
    PyNs3NetDevice *oif;
    ns3::NetDevice *oif_ptr;
    ns3::Socket::SocketErrno  sockerr;
    const char *keywords[] = {"p", "header", "oif", "sockerr", NULL};
    PyNs3Ipv6Route *py_Ipv6Route;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!i", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv6Header_Type, &header, &PyNs3NetDevice_Type, &oif, &sockerr)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    oif_ptr = (oif ? oif->obj : NULL);
    retval = self->obj->RouteOutput(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv6Header *) header)->obj, ns3::Ptr< ns3::NetDevice  > (oif_ptr), sockerr);
    if (!(const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Ipv6Route = NULL;
    } else {
        py_Ipv6Route = (PyNs3Ipv6Route *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6Route);
    }
    
    if (py_Ipv6Route == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6Route_Type);
        py_Ipv6Route = PyObject_New(PyNs3Ipv6Route, wrapper_type);
        py_Ipv6Route->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv6Route->obj = const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Ipv6Route->obj] = (PyObject *) py_Ipv6Route;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Route);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_SetDefaultMulticastRoute(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int outputInterface;
    const char *keywords[] = {"outputInterface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &outputInterface)) {
        return NULL;
    }
    self->obj->SetDefaultMulticastRoute(outputInterface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6StaticRouting_SetDefaultRoute(PyNs3Ipv6StaticRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    PyNs3Ipv6Address *prefixToUse = NULL;
    unsigned int metric = 0;
    const char *keywords[] = {"nextHop", "interface", "prefixToUse", "metric", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I|O!I", (char **) keywords, &PyNs3Ipv6Address_Type, &nextHop, &interface, &PyNs3Ipv6Address_Type, &prefixToUse, &metric)) {
        return NULL;
    }
    self->obj->SetDefaultRoute(*((PyNs3Ipv6Address *) nextHop)->obj, interface, (prefixToUse ? (*((PyNs3Ipv6Address *) prefixToUse)->obj) : ns3::Ipv6Address(((const char*)"::"))), metric);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6StaticRouting__copy__(PyNs3Ipv6StaticRouting *self)
{

    PyNs3Ipv6StaticRouting *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6StaticRouting, &PyNs3Ipv6StaticRouting_Type);
    py_copy->obj = new ns3::Ipv6StaticRouting(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6StaticRouting_methods[] = {
    {(char *) "NotifyAddAddress", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_NotifyAddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RemoveMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_RemoveMulticastRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddNetworkRouteTo", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_AddNetworkRouteTo, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMetric", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_GetMetric, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetRoute", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_GetRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "HasNetworkDest", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_HasNetworkDest, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyAddRoute", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_NotifyAddRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceDown", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_NotifyInterfaceDown, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDefaultRoute", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_GetDefaultRoute, METH_NOARGS, NULL },
    {(char *) "GetNMulticastRoutes", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_GetNMulticastRoutes, METH_NOARGS, NULL },
    {(char *) "NotifyRemoveRoute", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_NotifyRemoveRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetIpv6", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_SetIpv6, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RemoveRoute", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_RemoveRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "NotifyInterfaceUp", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_NotifyInterfaceUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddHostRouteTo", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_AddHostRouteTo, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_GetMulticastRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTable", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_PrintRoutingTable, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyRemoveAddress", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_NotifyRemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNRoutes", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_GetNRoutes, METH_NOARGS, NULL },
    {(char *) "AddMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_AddMulticastRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RouteOutput", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_RouteOutput, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDefaultMulticastRoute", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_SetDefaultMulticastRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDefaultRoute", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting_SetDefaultRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6StaticRouting__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6StaticRouting__tp_clear(PyNs3Ipv6StaticRouting *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6StaticRouting *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6StaticRouting__tp_traverse(PyNs3Ipv6StaticRouting *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6StaticRouting__tp_dealloc(PyNs3Ipv6StaticRouting *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6StaticRouting__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6StaticRouting__tp_richcompare (PyNs3Ipv6StaticRouting *PYBINDGEN_UNUSED(self), PyNs3Ipv6StaticRouting *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6StaticRouting_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6StaticRouting_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6StaticRouting",            /* tp_name */
    sizeof(PyNs3Ipv6StaticRouting),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6StaticRouting__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6StaticRouting__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6StaticRouting__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6StaticRouting__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6StaticRouting_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6StaticRouting, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6StaticRouting__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3NdiscCache__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3NdiscCache *self)
{
    PyObject *py_retval;
    PyNs3NdiscCache__PythonHelper *helper = dynamic_cast< PyNs3NdiscCache__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3NdiscCache__PythonHelper::_wrap_NotifyNewAggregate(PyNs3NdiscCache *self)
{
    PyObject *py_retval;
    PyNs3NdiscCache__PythonHelper *helper = dynamic_cast< PyNs3NdiscCache__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3NdiscCache__PythonHelper::_wrap_DoStart(PyNs3NdiscCache *self)
{
    PyObject *py_retval;
    PyNs3NdiscCache__PythonHelper *helper = dynamic_cast< PyNs3NdiscCache__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

void
PyNs3NdiscCache__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NdiscCache *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3NdiscCache* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NdiscCache* >(m_pyself)->obj = (ns3::NdiscCache*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NdiscCache* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NdiscCache* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NdiscCache* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3NdiscCache__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3NdiscCache__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3NdiscCache__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3NdiscCache__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}
static PyObject* _wrap_PyNs3NdiscCache__get_DEFAULT_UNRES_QLEN(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(ns3::NdiscCache::DEFAULT_UNRES_QLEN));
    return py_retval;
}
static PyGetSetDef Ns3NdiscCacheMeta__getsets[] = {
    {
        (char*) "DEFAULT_UNRES_QLEN", /* attribute name */
        (getter) _wrap_PyNs3NdiscCache__get_DEFAULT_UNRES_QLEN, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3NdiscCacheMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3NdiscCacheMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3NdiscCacheMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};


static int
_wrap_PyNs3NdiscCache__tp_init(PyNs3NdiscCache *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    if (self->ob_type != &PyNs3NdiscCache_Type)
    {
        self->obj = new PyNs3NdiscCache__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3NdiscCache__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::NdiscCache();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}


PyObject *
_wrap_PyNs3NdiscCache_SetUnresQlen(PyNs3NdiscCache *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int unresQlen;
    const char *keywords[] = {"unresQlen", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &unresQlen)) {
        return NULL;
    }
    self->obj->SetUnresQlen(unresQlen);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCache_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::NdiscCache::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCache_GetUnresQlen(PyNs3NdiscCache *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetUnresQlen();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCache_Flush(PyNs3NdiscCache *self)
{
    PyObject *py_retval;
    
    self->obj->Flush();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCache_SetDevice(PyNs3NdiscCache *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Ipv6Interface *interface;
    ns3::Ipv6Interface *interface_ptr;
    const char *keywords[] = {"device", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3NetDevice_Type, &device, &PyNs3Ipv6Interface_Type, &interface)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    interface_ptr = (interface ? interface->obj : NULL);
    self->obj->SetDevice(ns3::Ptr< ns3::NetDevice  > (device_ptr), ns3::Ptr< ns3::Ipv6Interface  > (interface_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCache_GetInterface(PyNs3NdiscCache *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6Interface > retval;
    PyNs3Ipv6Interface *py_Ipv6Interface;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetInterface();
    if (!(const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Ipv6Interface__PythonHelper).name())
    {
        py_Ipv6Interface = reinterpret_cast< PyNs3Ipv6Interface* >(reinterpret_cast< PyNs3Ipv6Interface__PythonHelper* >(const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Ipv6Interface->obj = const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Ipv6Interface);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Ipv6Interface = NULL;
        } else {
            py_Ipv6Interface = (PyNs3Ipv6Interface *) wrapper_lookup_iter->second;
            Py_INCREF(py_Ipv6Interface);
        }
    
        if (py_Ipv6Interface == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6Interface_Type);
            py_Ipv6Interface = PyObject_GC_New(PyNs3Ipv6Interface, wrapper_type);
            py_Ipv6Interface->inst_dict = NULL;
            py_Ipv6Interface->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval))->Ref();
            py_Ipv6Interface->obj = const_cast<ns3::Ipv6Interface *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6Interface->obj] = (PyObject *) py_Ipv6Interface;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Interface);
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCache_GetDevice(PyNs3NdiscCache *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetDevice();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}

static PyMethodDef PyNs3NdiscCache_methods[] = {
    {(char *) "SetUnresQlen", (PyCFunction) _wrap_PyNs3NdiscCache_SetUnresQlen, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3NdiscCache_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetUnresQlen", (PyCFunction) _wrap_PyNs3NdiscCache_GetUnresQlen, METH_NOARGS, NULL },
    {(char *) "Flush", (PyCFunction) _wrap_PyNs3NdiscCache_Flush, METH_NOARGS, NULL },
    {(char *) "SetDevice", (PyCFunction) _wrap_PyNs3NdiscCache_SetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInterface", (PyCFunction) _wrap_PyNs3NdiscCache_GetInterface, METH_NOARGS, NULL },
    {(char *) "GetDevice", (PyCFunction) _wrap_PyNs3NdiscCache_GetDevice, METH_NOARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3NdiscCache__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3NdiscCache__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3NdiscCache__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3NdiscCache__tp_clear(PyNs3NdiscCache *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::NdiscCache *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3NdiscCache__tp_traverse(PyNs3NdiscCache *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3NdiscCache__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3NdiscCache__tp_dealloc(PyNs3NdiscCache *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3NdiscCache__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3NdiscCache__tp_richcompare (PyNs3NdiscCache *PYBINDGEN_UNUSED(self), PyNs3NdiscCache *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3NdiscCache_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3NdiscCache_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.NdiscCache",            /* tp_name */
    sizeof(PyNs3NdiscCache),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3NdiscCache__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3NdiscCache__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3NdiscCache__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3NdiscCache__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3NdiscCache_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3NdiscCache, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3NdiscCache__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3NdiscCacheEntry_wrapper_registry;

static int
_wrap_PyNs3NdiscCacheEntry__tp_init(PyNs3NdiscCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyNs3NdiscCacheEntry *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NdiscCacheEntry_Type, &arg0)) {
        return -1;
    }
    self->obj = new ns3::NdiscCache::Entry(*((PyNs3NdiscCacheEntry *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_IncNSRetransmit(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->IncNSRetransmit();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_GetMacAddress(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    ns3::Address retval = self->obj->GetMacAddress();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_SetMacAddress(PyNs3NdiscCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *mac;
    ns3::Address mac2;
    const char *keywords[] = {"mac", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &mac)) {
        return NULL;
    }
    if (PyObject_IsInstance(mac, (PyObject*) &PyNs3Address_Type)) {
        mac2 = *((PyNs3Address *) mac)->obj;
    } else if (PyObject_IsInstance(mac, (PyObject*) &PyNs3Ipv4Address_Type)) {
        mac2 = *((PyNs3Ipv4Address *) mac)->obj;
    } else if (PyObject_IsInstance(mac, (PyObject*) &PyNs3Ipv6Address_Type)) {
        mac2 = *((PyNs3Ipv6Address *) mac)->obj;
    } else if (PyObject_IsInstance(mac, (PyObject*) &PyNs3Mac48Address_Type)) {
        mac2 = *((PyNs3Mac48Address *) mac)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", mac->ob_type->tp_name);
        return NULL;
    }
    self->obj->SetMacAddress(mac2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_IsDelay(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsDelay();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_FunctionReachableTimeout(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->FunctionReachableTimeout();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_ClearWaitingPacket(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->ClearWaitingPacket();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_IsStale(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsStale();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_StartRetransmitTimer(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->StartRetransmitTimer();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_IsProbe(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsProbe();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_StopRetransmitTimer(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->StopRetransmitTimer();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_UpdateLastReachabilityconfirmation(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->UpdateLastReachabilityconfirmation();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_GetNSRetransmit(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetNSRetransmit();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_StopDelayTimer(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->StopDelayTimer();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_IsReachable(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsReachable();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_StartDelayTimer(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->StartDelayTimer();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3NdiscCacheEntry_MarkStale__0(PyNs3NdiscCacheEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    std::list< ns3::Ptr< ns3::Packet > > retval;
    PyObject *mac;
    ns3::Address mac2;
    const char *keywords[] = {"mac", NULL};
    Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__ *py_std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &mac)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (PyObject_IsInstance(mac, (PyObject*) &PyNs3Address_Type)) {
        mac2 = *((PyNs3Address *) mac)->obj;
    } else if (PyObject_IsInstance(mac, (PyObject*) &PyNs3Ipv4Address_Type)) {
        mac2 = *((PyNs3Ipv4Address *) mac)->obj;
    } else if (PyObject_IsInstance(mac, (PyObject*) &PyNs3Ipv6Address_Type)) {
        mac2 = *((PyNs3Ipv6Address *) mac)->obj;
    } else if (PyObject_IsInstance(mac, (PyObject*) &PyNs3Mac48Address_Type)) {
        mac2 = *((PyNs3Mac48Address *) mac)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", mac->ob_type->tp_name);
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->MarkStale(mac2);
    py_std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__ = PyObject_New(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__, &Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt___Type);
    py_std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__->obj = new std::list< ns3::Ptr< ns3::Packet > >(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__);
    return py_retval;
}

PyObject *
_wrap_PyNs3NdiscCacheEntry_MarkStale__1(PyNs3NdiscCacheEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->MarkStale();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3NdiscCacheEntry_MarkStale(PyNs3NdiscCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3NdiscCacheEntry_MarkStale__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3NdiscCacheEntry_MarkStale__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_AddWaitingPacket(PyNs3NdiscCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &p)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    self->obj->AddWaitingPacket(ns3::Ptr< ns3::Packet  > (p_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_ResetNSRetransmit(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->ResetNSRetransmit();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_MarkDelay(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->MarkDelay();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3NdiscCacheEntry_MarkReachable__0(PyNs3NdiscCacheEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    std::list< ns3::Ptr< ns3::Packet > > retval;
    PyObject *mac;
    ns3::Address mac2;
    const char *keywords[] = {"mac", NULL};
    Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__ *py_std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &mac)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (PyObject_IsInstance(mac, (PyObject*) &PyNs3Address_Type)) {
        mac2 = *((PyNs3Address *) mac)->obj;
    } else if (PyObject_IsInstance(mac, (PyObject*) &PyNs3Ipv4Address_Type)) {
        mac2 = *((PyNs3Ipv4Address *) mac)->obj;
    } else if (PyObject_IsInstance(mac, (PyObject*) &PyNs3Ipv6Address_Type)) {
        mac2 = *((PyNs3Ipv6Address *) mac)->obj;
    } else if (PyObject_IsInstance(mac, (PyObject*) &PyNs3Mac48Address_Type)) {
        mac2 = *((PyNs3Mac48Address *) mac)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", mac->ob_type->tp_name);
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->MarkReachable(mac2);
    py_std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__ = PyObject_New(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__, &Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt___Type);
    py_std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__->obj = new std::list< ns3::Ptr< ns3::Packet > >(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__);
    return py_retval;
}

PyObject *
_wrap_PyNs3NdiscCacheEntry_MarkReachable__1(PyNs3NdiscCacheEntry *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->MarkReachable();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3NdiscCacheEntry_MarkReachable(PyNs3NdiscCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3NdiscCacheEntry_MarkReachable__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3NdiscCacheEntry_MarkReachable__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_FunctionDelayTimeout(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->FunctionDelayTimeout();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_StartReachableTimer(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->StartReachableTimer();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_MarkIncomplete(PyNs3NdiscCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &p)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    self->obj->MarkIncomplete(ns3::Ptr< ns3::Packet  > (p_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_IsIncomplete(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsIncomplete();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_FunctionRetransmitTimeout(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->FunctionRetransmitTimeout();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_SetIpv6Address(PyNs3NdiscCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *ipv6Address;
    const char *keywords[] = {"ipv6Address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &ipv6Address)) {
        return NULL;
    }
    self->obj->SetIpv6Address(*((PyNs3Ipv6Address *) ipv6Address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_StartProbeTimer(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->StartProbeTimer();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_GetLastReachabilityConfirmation(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    PyNs3Time *py_Time;
    
    ns3::Time retval = self->obj->GetLastReachabilityConfirmation();
    py_Time = PyObject_New(PyNs3Time, &PyNs3Time_Type);
    py_Time->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Time->obj = new ns3::Time(retval);
    PyNs3Time_wrapper_registry[(void *) py_Time->obj] = (PyObject *) py_Time;
    py_retval = Py_BuildValue((char *) "N", py_Time);
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_FunctionProbeTimeout(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->FunctionProbeTimeout();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_StopReachableTimer(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->StopReachableTimer();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_SetRouter(PyNs3NdiscCacheEntry *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool router;
    PyObject *py_router;
    const char *keywords[] = {"router", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_router)) {
        return NULL;
    }
    router = (bool) PyObject_IsTrue(py_router);
    self->obj->SetRouter(router);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_StopProbeTimer(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->StopProbeTimer();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_MarkProbe(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    
    self->obj->MarkProbe();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NdiscCacheEntry_IsRouter(PyNs3NdiscCacheEntry *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsRouter();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3NdiscCacheEntry__copy__(PyNs3NdiscCacheEntry *self)
{

    PyNs3NdiscCacheEntry *py_copy;
    py_copy = PyObject_New(PyNs3NdiscCacheEntry, &PyNs3NdiscCacheEntry_Type);
    py_copy->obj = new ns3::NdiscCache::Entry(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3NdiscCacheEntry_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3NdiscCacheEntry_methods[] = {
    {(char *) "IncNSRetransmit", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_IncNSRetransmit, METH_NOARGS, NULL },
    {(char *) "GetMacAddress", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_GetMacAddress, METH_NOARGS, NULL },
    {(char *) "SetMacAddress", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_SetMacAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsDelay", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_IsDelay, METH_NOARGS, NULL },
    {(char *) "FunctionReachableTimeout", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_FunctionReachableTimeout, METH_NOARGS, NULL },
    {(char *) "ClearWaitingPacket", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_ClearWaitingPacket, METH_NOARGS, NULL },
    {(char *) "IsStale", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_IsStale, METH_NOARGS, NULL },
    {(char *) "StartRetransmitTimer", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_StartRetransmitTimer, METH_NOARGS, NULL },
    {(char *) "IsProbe", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_IsProbe, METH_NOARGS, NULL },
    {(char *) "StopRetransmitTimer", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_StopRetransmitTimer, METH_NOARGS, NULL },
    {(char *) "UpdateLastReachabilityconfirmation", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_UpdateLastReachabilityconfirmation, METH_NOARGS, NULL },
    {(char *) "GetNSRetransmit", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_GetNSRetransmit, METH_NOARGS, NULL },
    {(char *) "StopDelayTimer", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_StopDelayTimer, METH_NOARGS, NULL },
    {(char *) "IsReachable", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_IsReachable, METH_NOARGS, NULL },
    {(char *) "StartDelayTimer", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_StartDelayTimer, METH_NOARGS, NULL },
    {(char *) "MarkStale", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_MarkStale, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddWaitingPacket", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_AddWaitingPacket, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "ResetNSRetransmit", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_ResetNSRetransmit, METH_NOARGS, NULL },
    {(char *) "MarkDelay", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_MarkDelay, METH_NOARGS, NULL },
    {(char *) "MarkReachable", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_MarkReachable, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "FunctionDelayTimeout", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_FunctionDelayTimeout, METH_NOARGS, NULL },
    {(char *) "StartReachableTimer", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_StartReachableTimer, METH_NOARGS, NULL },
    {(char *) "MarkIncomplete", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_MarkIncomplete, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsIncomplete", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_IsIncomplete, METH_NOARGS, NULL },
    {(char *) "FunctionRetransmitTimeout", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_FunctionRetransmitTimeout, METH_NOARGS, NULL },
    {(char *) "SetIpv6Address", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_SetIpv6Address, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "StartProbeTimer", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_StartProbeTimer, METH_NOARGS, NULL },
    {(char *) "GetLastReachabilityConfirmation", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_GetLastReachabilityConfirmation, METH_NOARGS, NULL },
    {(char *) "FunctionProbeTimeout", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_FunctionProbeTimeout, METH_NOARGS, NULL },
    {(char *) "StopReachableTimer", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_StopReachableTimer, METH_NOARGS, NULL },
    {(char *) "SetRouter", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_SetRouter, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "StopProbeTimer", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_StopProbeTimer, METH_NOARGS, NULL },
    {(char *) "MarkProbe", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_MarkProbe, METH_NOARGS, NULL },
    {(char *) "IsRouter", (PyCFunction) _wrap_PyNs3NdiscCacheEntry_IsRouter, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3NdiscCacheEntry__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3NdiscCacheEntry__tp_dealloc(PyNs3NdiscCacheEntry *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3NdiscCacheEntry_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3NdiscCacheEntry_wrapper_registry.end()) {
        PyNs3NdiscCacheEntry_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::NdiscCache::Entry *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3NdiscCacheEntry__tp_richcompare (PyNs3NdiscCacheEntry *PYBINDGEN_UNUSED(self), PyNs3NdiscCacheEntry *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3NdiscCacheEntry_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3NdiscCacheEntry_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.NdiscCache.Entry",            /* tp_name */
    sizeof(PyNs3NdiscCacheEntry),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3NdiscCacheEntry__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3NdiscCacheEntry__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3NdiscCacheEntry_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3NdiscCacheEntry__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3TcpL4Protocol__get_PROT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::TcpL4Protocol::PROT_NUMBER);
    return py_retval;
}
static PyGetSetDef Ns3TcpL4ProtocolMeta__getsets[] = {
    {
        (char*) "PROT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3TcpL4Protocol__get_PROT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3TcpL4ProtocolMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3TcpL4ProtocolMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3TcpL4ProtocolMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};


static int
_wrap_PyNs3TcpL4Protocol__tp_init(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    self->obj = new ns3::TcpL4Protocol();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyNs3TcpL4Protocol_SetNode(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3TcpL4Protocol_Receive__0(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    ns3::IpL4Protocol::RxStatus retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv4Header *header;
    PyNs3Ipv4Interface *incomingInterface;
    ns3::Ipv4Interface *incomingInterface_ptr;
    const char *keywords[] = {"p", "header", "incomingInterface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv4Header_Type, &header, &PyNs3Ipv4Interface_Type, &incomingInterface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    incomingInterface_ptr = (incomingInterface ? incomingInterface->obj : NULL);
    retval = self->obj->Receive(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv4Header *) header)->obj, ns3::Ptr< ns3::Ipv4Interface  > (incomingInterface_ptr));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
_wrap_PyNs3TcpL4Protocol_Receive__1(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    ns3::IpL4Protocol::RxStatus retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Interface *interface;
    ns3::Ipv6Interface *interface_ptr;
    const char *keywords[] = {"p", "src", "dst", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Interface_Type, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    interface_ptr = (interface ? interface->obj : NULL);
    retval = self->obj->Receive(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, ns3::Ptr< ns3::Ipv6Interface  > (interface_ptr));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject * _wrap_PyNs3TcpL4Protocol_Receive(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3TcpL4Protocol_Receive__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3TcpL4Protocol_Receive__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3TcpL4Protocol_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::TcpL4Protocol::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}



PyObject *
_wrap_PyNs3TcpL4Protocol_CreateSocket__0(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Socket > retval;
    const char *keywords[] = {NULL};
    PyNs3Socket *py_Socket;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->CreateSocket();
    if (!(const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Socket__PythonHelper).name())
    {
        py_Socket = reinterpret_cast< PyNs3Socket* >(reinterpret_cast< PyNs3Socket__PythonHelper* >(const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Socket);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Socket *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Socket = NULL;
        } else {
            py_Socket = (PyNs3Socket *) wrapper_lookup_iter->second;
            Py_INCREF(py_Socket);
        }
    
        if (py_Socket == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))), &PyNs3Socket_Type);
            py_Socket = PyObject_GC_New(PyNs3Socket, wrapper_type);
            py_Socket->inst_dict = NULL;
            py_Socket->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Socket *> (ns3::PeekPointer (retval))->Ref();
            py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Socket->obj] = (PyObject *) py_Socket;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Socket);
    return py_retval;
}

PyObject *
_wrap_PyNs3TcpL4Protocol_CreateSocket__1(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Socket > retval;
    PyNs3TypeId *socketTypeId;
    const char *keywords[] = {"socketTypeId", NULL};
    PyNs3Socket *py_Socket;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3TypeId_Type, &socketTypeId)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->CreateSocket(*((PyNs3TypeId *) socketTypeId)->obj);
    if (!(const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Socket__PythonHelper).name())
    {
        py_Socket = reinterpret_cast< PyNs3Socket* >(reinterpret_cast< PyNs3Socket__PythonHelper* >(const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Socket);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Socket *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Socket = NULL;
        } else {
            py_Socket = (PyNs3Socket *) wrapper_lookup_iter->second;
            Py_INCREF(py_Socket);
        }
    
        if (py_Socket == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))), &PyNs3Socket_Type);
            py_Socket = PyObject_GC_New(PyNs3Socket, wrapper_type);
            py_Socket->inst_dict = NULL;
            py_Socket->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Socket *> (ns3::PeekPointer (retval))->Ref();
            py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Socket->obj] = (PyObject *) py_Socket;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Socket);
    return py_retval;
}

PyObject * _wrap_PyNs3TcpL4Protocol_CreateSocket(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3TcpL4Protocol_CreateSocket__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3TcpL4Protocol_CreateSocket__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}



PyObject *
_wrap_PyNs3TcpL4Protocol_Send__0(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv4Address *saddr;
    PyNs3Ipv4Address *daddr;
    int sport;
    int dport;
    PyNs3NetDevice *oif = NULL;
    ns3::NetDevice *oif_ptr;
    const char *keywords[] = {"packet", "saddr", "daddr", "sport", "dport", "oif", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!ii|O!", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv4Address_Type, &saddr, &PyNs3Ipv4Address_Type, &daddr, &sport, &dport, &PyNs3NetDevice_Type, &oif)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (sport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (dport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    oif_ptr = (oif ? oif->obj : NULL);
    self->obj->Send(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv4Address *) saddr)->obj, *((PyNs3Ipv4Address *) daddr)->obj, sport, dport, ns3::Ptr< ns3::NetDevice  > (oif_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3TcpL4Protocol_Send__1(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv6Address *saddr;
    PyNs3Ipv6Address *daddr;
    int sport;
    int dport;
    PyNs3NetDevice *oif = NULL;
    ns3::NetDevice *oif_ptr;
    const char *keywords[] = {"packet", "saddr", "daddr", "sport", "dport", "oif", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!ii|O!", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv6Address_Type, &saddr, &PyNs3Ipv6Address_Type, &daddr, &sport, &dport, &PyNs3NetDevice_Type, &oif)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (sport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (dport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    oif_ptr = (oif ? oif->obj : NULL);
    self->obj->Send(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv6Address *) saddr)->obj, *((PyNs3Ipv6Address *) daddr)->obj, sport, dport, ns3::Ptr< ns3::NetDevice  > (oif_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3TcpL4Protocol_Send(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3TcpL4Protocol_Send__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3TcpL4Protocol_Send__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3TcpL4Protocol_GetProtocolNumber(PyNs3TcpL4Protocol *self)
{
    PyObject *py_retval;
    int retval;
    
    retval = self->obj->GetProtocolNumber();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpL4Protocol_SetDownTarget(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl8> cb_cb_impl;
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl8> (cb);
    self->obj->SetDownTarget(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::Ipv4Address, ns3::Ipv4Address, unsigned char, ns3::Ptr<ns3::Ipv4Route>, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3TcpL4Protocol_SetDownTarget6(PyNs3TcpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl7> cb_cb_impl;
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl7> (cb);
    self->obj->SetDownTarget6(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::Ipv6Address, ns3::Ipv6Address, unsigned char, ns3::Ptr<ns3::Ipv6Route>, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3TcpL4Protocol_methods[] = {
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3TcpL4Protocol_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Receive", (PyCFunction) _wrap_PyNs3TcpL4Protocol_Receive, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3TcpL4Protocol_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "CreateSocket", (PyCFunction) _wrap_PyNs3TcpL4Protocol_CreateSocket, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Send", (PyCFunction) _wrap_PyNs3TcpL4Protocol_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetProtocolNumber", (PyCFunction) _wrap_PyNs3TcpL4Protocol_GetProtocolNumber, METH_NOARGS, NULL },
    {(char *) "SetDownTarget", (PyCFunction) _wrap_PyNs3TcpL4Protocol_SetDownTarget, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDownTarget6", (PyCFunction) _wrap_PyNs3TcpL4Protocol_SetDownTarget6, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3TcpL4Protocol__tp_clear(PyNs3TcpL4Protocol *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::TcpL4Protocol *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3TcpL4Protocol__tp_traverse(PyNs3TcpL4Protocol *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3TcpL4Protocol__tp_dealloc(PyNs3TcpL4Protocol *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3TcpL4Protocol__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3TcpL4Protocol__tp_richcompare (PyNs3TcpL4Protocol *PYBINDGEN_UNUSED(self), PyNs3TcpL4Protocol *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3TcpL4Protocol_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3TcpL4Protocol_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.TcpL4Protocol",            /* tp_name */
    sizeof(PyNs3TcpL4Protocol),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3TcpL4Protocol__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3TcpL4Protocol__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3TcpL4Protocol__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3TcpL4Protocol__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3TcpL4Protocol_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3TcpL4Protocol, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3TcpL4Protocol__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3UdpL4Protocol__get_PROT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::UdpL4Protocol::PROT_NUMBER);
    return py_retval;
}
static PyGetSetDef Ns3UdpL4ProtocolMeta__getsets[] = {
    {
        (char*) "PROT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3UdpL4Protocol__get_PROT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3UdpL4ProtocolMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3UdpL4ProtocolMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3UdpL4ProtocolMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};


static int
_wrap_PyNs3UdpL4Protocol__tp_init(PyNs3UdpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        return -1;
    }
    self->obj = new ns3::UdpL4Protocol();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyNs3UdpL4Protocol_SetNode(PyNs3UdpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3UdpL4Protocol_Receive__0(PyNs3UdpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    ns3::IpL4Protocol::RxStatus retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv4Header *header;
    PyNs3Ipv4Interface *interface;
    ns3::Ipv4Interface *interface_ptr;
    const char *keywords[] = {"p", "header", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv4Header_Type, &header, &PyNs3Ipv4Interface_Type, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    interface_ptr = (interface ? interface->obj : NULL);
    retval = self->obj->Receive(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv4Header *) header)->obj, ns3::Ptr< ns3::Ipv4Interface  > (interface_ptr));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
_wrap_PyNs3UdpL4Protocol_Receive__1(PyNs3UdpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    ns3::IpL4Protocol::RxStatus retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Interface *interface;
    ns3::Ipv6Interface *interface_ptr;
    const char *keywords[] = {"p", "src", "dst", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Interface_Type, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    interface_ptr = (interface ? interface->obj : NULL);
    retval = self->obj->Receive(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, ns3::Ptr< ns3::Ipv6Interface  > (interface_ptr));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject * _wrap_PyNs3UdpL4Protocol_Receive(PyNs3UdpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3UdpL4Protocol_Receive__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3UdpL4Protocol_Receive__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3UdpL4Protocol_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::UdpL4Protocol::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpL4Protocol_CreateSocket(PyNs3UdpL4Protocol *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Socket > retval;
    PyNs3Socket *py_Socket;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->CreateSocket();
    if (!(const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Socket__PythonHelper).name())
    {
        py_Socket = reinterpret_cast< PyNs3Socket* >(reinterpret_cast< PyNs3Socket__PythonHelper* >(const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Socket);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Socket *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Socket = NULL;
        } else {
            py_Socket = (PyNs3Socket *) wrapper_lookup_iter->second;
            Py_INCREF(py_Socket);
        }
    
        if (py_Socket == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Socket *> (ns3::PeekPointer (retval)))), &PyNs3Socket_Type);
            py_Socket = PyObject_GC_New(PyNs3Socket, wrapper_type);
            py_Socket->inst_dict = NULL;
            py_Socket->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Socket *> (ns3::PeekPointer (retval))->Ref();
            py_Socket->obj = const_cast<ns3::Socket *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Socket->obj] = (PyObject *) py_Socket;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Socket);
    return py_retval;
}



PyObject *
_wrap_PyNs3UdpL4Protocol_Send__0(PyNs3UdpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv4Address *saddr;
    PyNs3Ipv4Address *daddr;
    int sport;
    int dport;
    const char *keywords[] = {"packet", "saddr", "daddr", "sport", "dport", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!ii", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv4Address_Type, &saddr, &PyNs3Ipv4Address_Type, &daddr, &sport, &dport)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (sport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (dport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->Send(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv4Address *) saddr)->obj, *((PyNs3Ipv4Address *) daddr)->obj, sport, dport);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3UdpL4Protocol_Send__1(PyNs3UdpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv4Address *saddr;
    PyNs3Ipv4Address *daddr;
    int sport;
    int dport;
    PyNs3Ipv4Route *route;
    ns3::Ipv4Route *route_ptr;
    const char *keywords[] = {"packet", "saddr", "daddr", "sport", "dport", "route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!iiO!", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv4Address_Type, &saddr, &PyNs3Ipv4Address_Type, &daddr, &sport, &dport, &PyNs3Ipv4Route_Type, &route)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (sport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (dport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    route_ptr = (route ? route->obj : NULL);
    self->obj->Send(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv4Address *) saddr)->obj, *((PyNs3Ipv4Address *) daddr)->obj, sport, dport, ns3::Ptr< ns3::Ipv4Route  > (route_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3UdpL4Protocol_Send__2(PyNs3UdpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv6Address *saddr;
    PyNs3Ipv6Address *daddr;
    int sport;
    int dport;
    const char *keywords[] = {"packet", "saddr", "daddr", "sport", "dport", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!ii", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv6Address_Type, &saddr, &PyNs3Ipv6Address_Type, &daddr, &sport, &dport)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (sport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (dport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->Send(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv6Address *) saddr)->obj, *((PyNs3Ipv6Address *) daddr)->obj, sport, dport);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3UdpL4Protocol_Send__3(PyNs3UdpL4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv6Address *saddr;
    PyNs3Ipv6Address *daddr;
    int sport;
    int dport;
    PyNs3Ipv6Route *route;
    ns3::Ipv6Route *route_ptr;
    const char *keywords[] = {"packet", "saddr", "daddr", "sport", "dport", "route", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!iiO!", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv6Address_Type, &saddr, &PyNs3Ipv6Address_Type, &daddr, &sport, &dport, &PyNs3Ipv6Route_Type, &route)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (sport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (dport > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    route_ptr = (route ? route->obj : NULL);
    self->obj->Send(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv6Address *) saddr)->obj, *((PyNs3Ipv6Address *) daddr)->obj, sport, dport, ns3::Ptr< ns3::Ipv6Route  > (route_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3UdpL4Protocol_Send(PyNs3UdpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[4] = {0,};
    retval = _wrap_PyNs3UdpL4Protocol_Send__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3UdpL4Protocol_Send__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3UdpL4Protocol_Send__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyNs3UdpL4Protocol_Send__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    error_list = PyList_New(4);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3UdpL4Protocol_GetProtocolNumber(PyNs3UdpL4Protocol *self)
{
    PyObject *py_retval;
    int retval;
    
    retval = self->obj->GetProtocolNumber();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpL4Protocol_SetDownTarget(PyNs3UdpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl8> cb_cb_impl;
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl8> (cb);
    self->obj->SetDownTarget(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::Ipv4Address, ns3::Ipv4Address, unsigned char, ns3::Ptr<ns3::Ipv4Route>, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3UdpL4Protocol_SetDownTarget6(PyNs3UdpL4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl7> cb_cb_impl;
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl7> (cb);
    self->obj->SetDownTarget6(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::Ipv6Address, ns3::Ipv6Address, unsigned char, ns3::Ptr<ns3::Ipv6Route>, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3UdpL4Protocol_methods[] = {
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3UdpL4Protocol_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Receive", (PyCFunction) _wrap_PyNs3UdpL4Protocol_Receive, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3UdpL4Protocol_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "CreateSocket", (PyCFunction) _wrap_PyNs3UdpL4Protocol_CreateSocket, METH_NOARGS, NULL },
    {(char *) "Send", (PyCFunction) _wrap_PyNs3UdpL4Protocol_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetProtocolNumber", (PyCFunction) _wrap_PyNs3UdpL4Protocol_GetProtocolNumber, METH_NOARGS, NULL },
    {(char *) "SetDownTarget", (PyCFunction) _wrap_PyNs3UdpL4Protocol_SetDownTarget, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDownTarget6", (PyCFunction) _wrap_PyNs3UdpL4Protocol_SetDownTarget6, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3UdpL4Protocol__tp_clear(PyNs3UdpL4Protocol *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::UdpL4Protocol *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3UdpL4Protocol__tp_traverse(PyNs3UdpL4Protocol *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3UdpL4Protocol__tp_dealloc(PyNs3UdpL4Protocol *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3UdpL4Protocol__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3UdpL4Protocol__tp_richcompare (PyNs3UdpL4Protocol *PYBINDGEN_UNUSED(self), PyNs3UdpL4Protocol *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3UdpL4Protocol_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3UdpL4Protocol_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.UdpL4Protocol",            /* tp_name */
    sizeof(PyNs3UdpL4Protocol),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3UdpL4Protocol__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3UdpL4Protocol__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3UdpL4Protocol__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3UdpL4Protocol__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3UdpL4Protocol_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3UdpL4Protocol, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3UdpL4Protocol__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3Icmpv4L4Protocol__get_PROT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv4L4Protocol::PROT_NUMBER);
    return py_retval;
}
static PyGetSetDef Ns3Icmpv4L4ProtocolMeta__getsets[] = {
    {
        (char*) "PROT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3Icmpv4L4Protocol__get_PROT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Icmpv4L4ProtocolMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Icmpv4L4ProtocolMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Icmpv4L4ProtocolMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Icmpv4L4Protocol__tp_init__0(PyNs3Icmpv4L4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv4L4Protocol *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv4L4Protocol_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv4L4Protocol(*((PyNs3Icmpv4L4Protocol *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv4L4Protocol__tp_init__1(PyNs3Icmpv4L4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv4L4Protocol();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv4L4Protocol__tp_init(PyNs3Icmpv4L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv4L4Protocol__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv4L4Protocol__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv4L4Protocol_SendDestUnreachPort(PyNs3Icmpv4L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Header *header;
    PyNs3Packet *orgData;
    ns3::Packet *orgData_ptr;
    const char *keywords[] = {"header", "orgData", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv4Header_Type, &header, &PyNs3Packet_Type, &orgData)) {
        return NULL;
    }
    orgData_ptr = (orgData ? orgData->obj : NULL);
    self->obj->SendDestUnreachPort(*((PyNs3Ipv4Header *) header)->obj, ns3::Ptr< ns3::Packet  > (orgData_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4L4Protocol_SetNode(PyNs3Icmpv4L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3Icmpv4L4Protocol_Receive__0(PyNs3Icmpv4L4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    ns3::IpL4Protocol::RxStatus retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv4Header *header;
    PyNs3Ipv4Interface *incomingInterface;
    ns3::Ipv4Interface *incomingInterface_ptr;
    const char *keywords[] = {"p", "header", "incomingInterface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv4Header_Type, &header, &PyNs3Ipv4Interface_Type, &incomingInterface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    incomingInterface_ptr = (incomingInterface ? incomingInterface->obj : NULL);
    retval = self->obj->Receive(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv4Header *) header)->obj, ns3::Ptr< ns3::Ipv4Interface  > (incomingInterface_ptr));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
_wrap_PyNs3Icmpv4L4Protocol_Receive__1(PyNs3Icmpv4L4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    ns3::IpL4Protocol::RxStatus retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Interface *incomingInterface;
    ns3::Ipv6Interface *incomingInterface_ptr;
    const char *keywords[] = {"p", "src", "dst", "incomingInterface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Interface_Type, &incomingInterface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    incomingInterface_ptr = (incomingInterface ? incomingInterface->obj : NULL);
    retval = self->obj->Receive(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, ns3::Ptr< ns3::Ipv6Interface  > (incomingInterface_ptr));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject * _wrap_PyNs3Icmpv4L4Protocol_Receive(PyNs3Icmpv4L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv4L4Protocol_Receive__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv4L4Protocol_Receive__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Icmpv4L4Protocol_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv4L4Protocol::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4L4Protocol_GetStaticProtocolNumber(void)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = ns3::Icmpv4L4Protocol::GetStaticProtocolNumber();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4L4Protocol_SetDownTarget6(PyNs3Icmpv4L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl7> cb_cb_impl;
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl7> (cb);
    self->obj->SetDownTarget6(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::Ipv6Address, ns3::Ipv6Address, unsigned char, ns3::Ptr<ns3::Ipv6Route>, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4L4Protocol_GetProtocolNumber(PyNs3Icmpv4L4Protocol *self)
{
    PyObject *py_retval;
    int retval;
    
    retval = self->obj->GetProtocolNumber();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4L4Protocol_SendTimeExceededTtl(PyNs3Icmpv4L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Header *header;
    PyNs3Packet *orgData;
    ns3::Packet *orgData_ptr;
    const char *keywords[] = {"header", "orgData", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv4Header_Type, &header, &PyNs3Packet_Type, &orgData)) {
        return NULL;
    }
    orgData_ptr = (orgData ? orgData->obj : NULL);
    self->obj->SendTimeExceededTtl(*((PyNs3Ipv4Header *) header)->obj, ns3::Ptr< ns3::Packet  > (orgData_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4L4Protocol_SendDestUnreachFragNeeded(PyNs3Icmpv4L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Header *header;
    PyNs3Packet *orgData;
    ns3::Packet *orgData_ptr;
    int nextHopMtu;
    const char *keywords[] = {"header", "orgData", "nextHopMtu", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!i", (char **) keywords, &PyNs3Ipv4Header_Type, &header, &PyNs3Packet_Type, &orgData, &nextHopMtu)) {
        return NULL;
    }
    orgData_ptr = (orgData ? orgData->obj : NULL);
    if (nextHopMtu > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SendDestUnreachFragNeeded(*((PyNs3Ipv4Header *) header)->obj, ns3::Ptr< ns3::Packet  > (orgData_ptr), nextHopMtu);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv4L4Protocol_SetDownTarget(PyNs3Icmpv4L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl8> cb_cb_impl;
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl8> (cb);
    self->obj->SetDownTarget(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::Ipv4Address, ns3::Ipv4Address, unsigned char, ns3::Ptr<ns3::Ipv4Route>, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv4L4Protocol__copy__(PyNs3Icmpv4L4Protocol *self)
{

    PyNs3Icmpv4L4Protocol *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv4L4Protocol, &PyNs3Icmpv4L4Protocol_Type);
    py_copy->obj = new ns3::Icmpv4L4Protocol(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv4L4Protocol_methods[] = {
    {(char *) "SendDestUnreachPort", (PyCFunction) _wrap_PyNs3Icmpv4L4Protocol_SendDestUnreachPort, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3Icmpv4L4Protocol_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Receive", (PyCFunction) _wrap_PyNs3Icmpv4L4Protocol_Receive, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv4L4Protocol_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetStaticProtocolNumber", (PyCFunction) _wrap_PyNs3Icmpv4L4Protocol_GetStaticProtocolNumber, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "SetDownTarget6", (PyCFunction) _wrap_PyNs3Icmpv4L4Protocol_SetDownTarget6, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetProtocolNumber", (PyCFunction) _wrap_PyNs3Icmpv4L4Protocol_GetProtocolNumber, METH_NOARGS, NULL },
    {(char *) "SendTimeExceededTtl", (PyCFunction) _wrap_PyNs3Icmpv4L4Protocol_SendTimeExceededTtl, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SendDestUnreachFragNeeded", (PyCFunction) _wrap_PyNs3Icmpv4L4Protocol_SendDestUnreachFragNeeded, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDownTarget", (PyCFunction) _wrap_PyNs3Icmpv4L4Protocol_SetDownTarget, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv4L4Protocol__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv4L4Protocol__tp_clear(PyNs3Icmpv4L4Protocol *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Icmpv4L4Protocol *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Icmpv4L4Protocol__tp_traverse(PyNs3Icmpv4L4Protocol *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv4L4Protocol__tp_dealloc(PyNs3Icmpv4L4Protocol *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv4L4Protocol__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv4L4Protocol__tp_richcompare (PyNs3Icmpv4L4Protocol *PYBINDGEN_UNUSED(self), PyNs3Icmpv4L4Protocol *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv4L4Protocol_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv4L4Protocol_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv4L4Protocol",            /* tp_name */
    sizeof(PyNs3Icmpv4L4Protocol),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv4L4Protocol__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv4L4Protocol__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv4L4Protocol__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv4L4Protocol__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv4L4Protocol_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv4L4Protocol, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv4L4Protocol__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_DELAY_FIRST_PROBE_TIME(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::DELAY_FIRST_PROBE_TIME);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MAX_ANYCAST_DELAY_TIME(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::MAX_ANYCAST_DELAY_TIME);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MAX_FINAL_RTR_ADVERTISEMENTS(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::MAX_FINAL_RTR_ADVERTISEMENTS);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MAX_INITIAL_RTR_ADVERTISEMENTS(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::MAX_INITIAL_RTR_ADVERTISEMENTS);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MAX_INITIAL_RTR_ADVERT_INTERVAL(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::MAX_INITIAL_RTR_ADVERT_INTERVAL);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MAX_MULTICAST_SOLICIT(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::MAX_MULTICAST_SOLICIT);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MAX_NEIGHBOR_ADVERTISEMENT(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::MAX_NEIGHBOR_ADVERTISEMENT);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MAX_RANDOM_FACTOR(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "d", ns3::Icmpv6L4Protocol::MAX_RANDOM_FACTOR);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MAX_RA_DELAY_TIME(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(ns3::Icmpv6L4Protocol::MAX_RA_DELAY_TIME));
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MAX_RTR_SOLICITATIONS(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::MAX_RTR_SOLICITATIONS);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MAX_RTR_SOLICITATION_DELAY(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::MAX_RTR_SOLICITATION_DELAY);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MAX_UNICAST_SOLICIT(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::MAX_UNICAST_SOLICIT);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MIN_DELAY_BETWEEN_RAS(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::MIN_DELAY_BETWEEN_RAS);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_MIN_RANDOM_FACTOR(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "d", ns3::Icmpv6L4Protocol::MIN_RANDOM_FACTOR);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_PROT_NUMBER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::PROT_NUMBER);
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_REACHABLE_TIME(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(ns3::Icmpv6L4Protocol::REACHABLE_TIME));
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_RETRANS_TIMER(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(ns3::Icmpv6L4Protocol::RETRANS_TIMER));
    return py_retval;
}
static PyObject* _wrap_PyNs3Icmpv6L4Protocol__get_RTR_SOLICITATION_INTERVAL(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Icmpv6L4Protocol::RTR_SOLICITATION_INTERVAL);
    return py_retval;
}
static PyGetSetDef Ns3Icmpv6L4ProtocolMeta__getsets[] = {
    {
        (char*) "MAX_MULTICAST_SOLICIT", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MAX_MULTICAST_SOLICIT, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "RTR_SOLICITATION_INTERVAL", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_RTR_SOLICITATION_INTERVAL, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MAX_RA_DELAY_TIME", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MAX_RA_DELAY_TIME, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MAX_RTR_SOLICITATIONS", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MAX_RTR_SOLICITATIONS, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MIN_RANDOM_FACTOR", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MIN_RANDOM_FACTOR, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MAX_RANDOM_FACTOR", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MAX_RANDOM_FACTOR, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "RETRANS_TIMER", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_RETRANS_TIMER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MAX_INITIAL_RTR_ADVERTISEMENTS", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MAX_INITIAL_RTR_ADVERTISEMENTS, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MAX_NEIGHBOR_ADVERTISEMENT", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MAX_NEIGHBOR_ADVERTISEMENT, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "REACHABLE_TIME", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_REACHABLE_TIME, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MAX_ANYCAST_DELAY_TIME", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MAX_ANYCAST_DELAY_TIME, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MIN_DELAY_BETWEEN_RAS", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MIN_DELAY_BETWEEN_RAS, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MAX_RTR_SOLICITATION_DELAY", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MAX_RTR_SOLICITATION_DELAY, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "PROT_NUMBER", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_PROT_NUMBER, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MAX_FINAL_RTR_ADVERTISEMENTS", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MAX_FINAL_RTR_ADVERTISEMENTS, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "DELAY_FIRST_PROBE_TIME", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_DELAY_FIRST_PROBE_TIME, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MAX_INITIAL_RTR_ADVERT_INTERVAL", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MAX_INITIAL_RTR_ADVERT_INTERVAL, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "MAX_UNICAST_SOLICIT", /* attribute name */
        (getter) _wrap_PyNs3Icmpv6L4Protocol__get_MAX_UNICAST_SOLICIT, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Icmpv6L4ProtocolMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Icmpv6L4ProtocolMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Icmpv6L4ProtocolMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Icmpv6L4Protocol__tp_init__0(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Icmpv6L4Protocol *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Icmpv6L4Protocol_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6L4Protocol(*((PyNs3Icmpv6L4Protocol *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Icmpv6L4Protocol__tp_init__1(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Icmpv6L4Protocol();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Icmpv6L4Protocol__tp_init(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6L4Protocol__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6L4Protocol__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_SendErrorDestinationUnreachable(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *malformedPacket;
    ns3::Packet *malformedPacket_ptr;
    PyNs3Ipv6Address *dst;
    int code;
    const char *keywords[] = {"malformedPacket", "dst", "code", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!i", (char **) keywords, &PyNs3Packet_Type, &malformedPacket, &PyNs3Ipv6Address_Type, &dst, &code)) {
        return NULL;
    }
    malformedPacket_ptr = (malformedPacket ? malformedPacket->obj : NULL);
    if (code > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SendErrorDestinationUnreachable(ns3::Ptr< ns3::Packet  > (malformedPacket_ptr), *((PyNs3Ipv6Address *) dst)->obj, code);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Icmpv6L4Protocol::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_GetStaticProtocolNumber(void)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = ns3::Icmpv6L4Protocol::GetStaticProtocolNumber();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_DoDAD(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *target;
    PyNs3Ipv6Interface *interface;
    ns3::Ipv6Interface *interface_ptr;
    const char *keywords[] = {"target", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Ipv6Address_Type, &target, &PyNs3Ipv6Interface_Type, &interface)) {
        return NULL;
    }
    interface_ptr = (interface ? interface->obj : NULL);
    self->obj->DoDAD(*((PyNs3Ipv6Address *) target)->obj, ns3::Ptr< ns3::Ipv6Interface  > (interface_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3Icmpv6L4Protocol_SendMessage__0(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    int ttl;
    const char *keywords[] = {"packet", "src", "dst", "ttl", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!i", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &ttl)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (ttl > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->SendMessage(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, ttl);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Icmpv6L4Protocol_SendMessage__1(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyNs3Ipv6Address *dst;
    PyNs3Icmpv6Header *icmpv6Hdr;
    int ttl;
    const char *keywords[] = {"packet", "dst", "icmpv6Hdr", "ttl", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!i", (char **) keywords, &PyNs3Packet_Type, &packet, &PyNs3Ipv6Address_Type, &dst, &PyNs3Icmpv6Header_Type, &icmpv6Hdr, &ttl)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (ttl > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->SendMessage(ns3::Ptr< ns3::Packet  > (packet_ptr), *((PyNs3Ipv6Address *) dst)->obj, *((PyNs3Icmpv6Header *) icmpv6Hdr)->obj, ttl);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Icmpv6L4Protocol_SendMessage(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6L4Protocol_SendMessage__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6L4Protocol_SendMessage__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_SendErrorTooBig(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *malformedPacket;
    ns3::Packet *malformedPacket_ptr;
    PyNs3Ipv6Address *dst;
    unsigned int mtu;
    const char *keywords[] = {"malformedPacket", "dst", "mtu", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PyNs3Packet_Type, &malformedPacket, &PyNs3Ipv6Address_Type, &dst, &mtu)) {
        return NULL;
    }
    malformedPacket_ptr = (malformedPacket ? malformedPacket->obj : NULL);
    self->obj->SendErrorTooBig(ns3::Ptr< ns3::Packet  > (malformedPacket_ptr), *((PyNs3Ipv6Address *) dst)->obj, mtu);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_ForgeNS(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Address *target;
    PyObject *hardwareAddress;
    ns3::Address hardwareAddress2;
    const char *keywords[] = {"src", "dst", "target", "hardwareAddress", NULL};
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!O", (char **) keywords, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Address_Type, &target, &hardwareAddress)) {
        return NULL;
    }
    if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Address_Type)) {
        hardwareAddress2 = *((PyNs3Address *) hardwareAddress)->obj;
    } else if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Ipv4Address_Type)) {
        hardwareAddress2 = *((PyNs3Ipv4Address *) hardwareAddress)->obj;
    } else if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Ipv6Address_Type)) {
        hardwareAddress2 = *((PyNs3Ipv6Address *) hardwareAddress)->obj;
    } else if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Mac48Address_Type)) {
        hardwareAddress2 = *((PyNs3Mac48Address *) hardwareAddress)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", hardwareAddress->ob_type->tp_name);
        return NULL;
    }
    retval = self->obj->ForgeNS(*((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, *((PyNs3Ipv6Address *) target)->obj, hardwareAddress2);
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (retval))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_SendNS(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Address *target;
    PyObject *hardwareAddress;
    ns3::Address hardwareAddress2;
    const char *keywords[] = {"src", "dst", "target", "hardwareAddress", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!O", (char **) keywords, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Address_Type, &target, &hardwareAddress)) {
        return NULL;
    }
    if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Address_Type)) {
        hardwareAddress2 = *((PyNs3Address *) hardwareAddress)->obj;
    } else if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Ipv4Address_Type)) {
        hardwareAddress2 = *((PyNs3Ipv4Address *) hardwareAddress)->obj;
    } else if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Ipv6Address_Type)) {
        hardwareAddress2 = *((PyNs3Ipv6Address *) hardwareAddress)->obj;
    } else if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Mac48Address_Type)) {
        hardwareAddress2 = *((PyNs3Mac48Address *) hardwareAddress)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", hardwareAddress->ob_type->tp_name);
        return NULL;
    }
    self->obj->SendNS(*((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, *((PyNs3Ipv6Address *) target)->obj, hardwareAddress2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_SendRS(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    PyObject *hardwareAddress;
    ns3::Address hardwareAddress2;
    const char *keywords[] = {"src", "dst", "hardwareAddress", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O", (char **) keywords, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &hardwareAddress)) {
        return NULL;
    }
    if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Address_Type)) {
        hardwareAddress2 = *((PyNs3Address *) hardwareAddress)->obj;
    } else if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Ipv4Address_Type)) {
        hardwareAddress2 = *((PyNs3Ipv4Address *) hardwareAddress)->obj;
    } else if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Ipv6Address_Type)) {
        hardwareAddress2 = *((PyNs3Ipv6Address *) hardwareAddress)->obj;
    } else if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Mac48Address_Type)) {
        hardwareAddress2 = *((PyNs3Mac48Address *) hardwareAddress)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", hardwareAddress->ob_type->tp_name);
        return NULL;
    }
    self->obj->SendRS(*((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, hardwareAddress2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_IsAlwaysDad(PyNs3Icmpv6L4Protocol *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsAlwaysDad();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_NotifyNewAggregate(PyNs3Icmpv6L4Protocol *self)
{
    PyObject *py_retval;
    
    self->obj->NotifyNewAggregate();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_CreateCache(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NdiscCache > retval;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    PyNs3Ipv6Interface *interface;
    ns3::Ipv6Interface *interface_ptr;
    const char *keywords[] = {"device", "interface", NULL};
    PyNs3NdiscCache *py_NdiscCache;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3NetDevice_Type, &device, &PyNs3Ipv6Interface_Type, &interface)) {
        return NULL;
    }
    device_ptr = (device ? device->obj : NULL);
    interface_ptr = (interface ? interface->obj : NULL);
    retval = self->obj->CreateCache(ns3::Ptr< ns3::NetDevice  > (device_ptr), ns3::Ptr< ns3::Ipv6Interface  > (interface_ptr));
    if (!(const_cast<ns3::NdiscCache *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NdiscCache *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NdiscCache__PythonHelper).name())
    {
        py_NdiscCache = reinterpret_cast< PyNs3NdiscCache* >(reinterpret_cast< PyNs3NdiscCache__PythonHelper* >(const_cast<ns3::NdiscCache *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NdiscCache->obj = const_cast<ns3::NdiscCache *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NdiscCache);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NdiscCache *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NdiscCache = NULL;
        } else {
            py_NdiscCache = (PyNs3NdiscCache *) wrapper_lookup_iter->second;
            Py_INCREF(py_NdiscCache);
        }
    
        if (py_NdiscCache == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NdiscCache *> (ns3::PeekPointer (retval)))), &PyNs3NdiscCache_Type);
            py_NdiscCache = PyObject_GC_New(PyNs3NdiscCache, wrapper_type);
            py_NdiscCache->inst_dict = NULL;
            py_NdiscCache->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NdiscCache *> (ns3::PeekPointer (retval))->Ref();
            py_NdiscCache->obj = const_cast<ns3::NdiscCache *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NdiscCache->obj] = (PyObject *) py_NdiscCache;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NdiscCache);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_ForgeEchoRequest(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    int id;
    int seq;
    PyNs3Packet *data;
    ns3::Packet *data_ptr;
    const char *keywords[] = {"src", "dst", "id", "seq", "data", NULL};
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!iiO!", (char **) keywords, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &id, &seq, &PyNs3Packet_Type, &data)) {
        return NULL;
    }
    if (id > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (seq > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    data_ptr = (data ? data->obj : NULL);
    retval = self->obj->ForgeEchoRequest(*((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, id, seq, ns3::Ptr< ns3::Packet  > (data_ptr));
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (retval))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_SetNode(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3Icmpv6L4Protocol_Receive__0(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    ns3::IpL4Protocol::RxStatus retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv4Header *header;
    PyNs3Ipv4Interface *interface;
    ns3::Ipv4Interface *interface_ptr;
    const char *keywords[] = {"p", "header", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv4Header_Type, &header, &PyNs3Ipv4Interface_Type, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    interface_ptr = (interface ? interface->obj : NULL);
    retval = self->obj->Receive(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv4Header *) header)->obj, ns3::Ptr< ns3::Ipv4Interface  > (interface_ptr));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
_wrap_PyNs3Icmpv6L4Protocol_Receive__1(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    ns3::IpL4Protocol::RxStatus retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Interface *interface;
    ns3::Ipv6Interface *interface_ptr;
    const char *keywords[] = {"p", "src", "dst", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Interface_Type, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    interface_ptr = (interface ? interface->obj : NULL);
    retval = self->obj->Receive(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, ns3::Ptr< ns3::Ipv6Interface  > (interface_ptr));
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject * _wrap_PyNs3Icmpv6L4Protocol_Receive(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Icmpv6L4Protocol_Receive__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Icmpv6L4Protocol_Receive__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_GetProtocolNumber(PyNs3Icmpv6L4Protocol *self)
{
    PyObject *py_retval;
    int retval;
    
    retval = self->obj->GetProtocolNumber();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_ForgeRS(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Packet > retval;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    PyObject *hardwareAddress;
    ns3::Address hardwareAddress2;
    const char *keywords[] = {"src", "dst", "hardwareAddress", NULL};
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O", (char **) keywords, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &hardwareAddress)) {
        return NULL;
    }
    if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Address_Type)) {
        hardwareAddress2 = *((PyNs3Address *) hardwareAddress)->obj;
    } else if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Ipv4Address_Type)) {
        hardwareAddress2 = *((PyNs3Ipv4Address *) hardwareAddress)->obj;
    } else if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Ipv6Address_Type)) {
        hardwareAddress2 = *((PyNs3Ipv6Address *) hardwareAddress)->obj;
    } else if (PyObject_IsInstance(hardwareAddress, (PyObject*) &PyNs3Mac48Address_Type)) {
        hardwareAddress2 = *((PyNs3Mac48Address *) hardwareAddress)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", hardwareAddress->ob_type->tp_name);
        return NULL;
    }
    retval = self->obj->ForgeRS(*((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, hardwareAddress2);
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer (retval)))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (retval))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_GetVersion(PyNs3Icmpv6L4Protocol *self)
{
    PyObject *py_retval;
    int retval;
    
    retval = self->obj->GetVersion();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_SendErrorTimeExceeded(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *malformedPacket;
    ns3::Packet *malformedPacket_ptr;
    PyNs3Ipv6Address *dst;
    int code;
    const char *keywords[] = {"malformedPacket", "dst", "code", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!i", (char **) keywords, &PyNs3Packet_Type, &malformedPacket, &PyNs3Ipv6Address_Type, &dst, &code)) {
        return NULL;
    }
    malformedPacket_ptr = (malformedPacket ? malformedPacket->obj : NULL);
    if (code > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SendErrorTimeExceeded(ns3::Ptr< ns3::Packet  > (malformedPacket_ptr), *((PyNs3Ipv6Address *) dst)->obj, code);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_SendErrorParameterError(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *malformedPacket;
    ns3::Packet *malformedPacket_ptr;
    PyNs3Ipv6Address *dst;
    int code;
    unsigned int ptr;
    const char *keywords[] = {"malformedPacket", "dst", "code", "ptr", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!iI", (char **) keywords, &PyNs3Packet_Type, &malformedPacket, &PyNs3Ipv6Address_Type, &dst, &code, &ptr)) {
        return NULL;
    }
    malformedPacket_ptr = (malformedPacket ? malformedPacket->obj : NULL);
    if (code > 0xff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->SendErrorParameterError(ns3::Ptr< ns3::Packet  > (malformedPacket_ptr), *((PyNs3Ipv6Address *) dst)->obj, code, ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_SendRedirection(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *redirectedPacket;
    ns3::Packet *redirectedPacket_ptr;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Address *redirTarget;
    PyNs3Ipv6Address *redirDestination;
    PyObject *redirHardwareTarget;
    ns3::Address redirHardwareTarget2;
    const char *keywords[] = {"redirectedPacket", "dst", "redirTarget", "redirDestination", "redirHardwareTarget", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!O!O", (char **) keywords, &PyNs3Packet_Type, &redirectedPacket, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Address_Type, &redirTarget, &PyNs3Ipv6Address_Type, &redirDestination, &redirHardwareTarget)) {
        return NULL;
    }
    redirectedPacket_ptr = (redirectedPacket ? redirectedPacket->obj : NULL);
    if (PyObject_IsInstance(redirHardwareTarget, (PyObject*) &PyNs3Address_Type)) {
        redirHardwareTarget2 = *((PyNs3Address *) redirHardwareTarget)->obj;
    } else if (PyObject_IsInstance(redirHardwareTarget, (PyObject*) &PyNs3Ipv4Address_Type)) {
        redirHardwareTarget2 = *((PyNs3Ipv4Address *) redirHardwareTarget)->obj;
    } else if (PyObject_IsInstance(redirHardwareTarget, (PyObject*) &PyNs3Ipv6Address_Type)) {
        redirHardwareTarget2 = *((PyNs3Ipv6Address *) redirHardwareTarget)->obj;
    } else if (PyObject_IsInstance(redirHardwareTarget, (PyObject*) &PyNs3Mac48Address_Type)) {
        redirHardwareTarget2 = *((PyNs3Mac48Address *) redirHardwareTarget)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", redirHardwareTarget->ob_type->tp_name);
        return NULL;
    }
    self->obj->SendRedirection(ns3::Ptr< ns3::Packet  > (redirectedPacket_ptr), *((PyNs3Ipv6Address *) dst)->obj, *((PyNs3Ipv6Address *) redirTarget)->obj, *((PyNs3Ipv6Address *) redirDestination)->obj, redirHardwareTarget2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Icmpv6L4Protocol_SendEchoReply(PyNs3Icmpv6L4Protocol *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *src;
    PyNs3Ipv6Address *dst;
    int id;
    int seq;
    PyNs3Packet *data;
    ns3::Packet *data_ptr;
    const char *keywords[] = {"src", "dst", "id", "seq", "data", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!iiO!", (char **) keywords, &PyNs3Ipv6Address_Type, &src, &PyNs3Ipv6Address_Type, &dst, &id, &seq, &PyNs3Packet_Type, &data)) {
        return NULL;
    }
    if (id > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (seq > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    data_ptr = (data ? data->obj : NULL);
    self->obj->SendEchoReply(*((PyNs3Ipv6Address *) src)->obj, *((PyNs3Ipv6Address *) dst)->obj, id, seq, ns3::Ptr< ns3::Packet  > (data_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Icmpv6L4Protocol__copy__(PyNs3Icmpv6L4Protocol *self)
{

    PyNs3Icmpv6L4Protocol *py_copy;
    py_copy = PyObject_GC_New(PyNs3Icmpv6L4Protocol, &PyNs3Icmpv6L4Protocol_Type);
    py_copy->obj = new ns3::Icmpv6L4Protocol(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Icmpv6L4Protocol_methods[] = {
    {(char *) "SendErrorDestinationUnreachable", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_SendErrorDestinationUnreachable, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetStaticProtocolNumber", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_GetStaticProtocolNumber, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "DoDAD", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_DoDAD, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SendMessage", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_SendMessage, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SendErrorTooBig", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_SendErrorTooBig, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "ForgeNS", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_ForgeNS, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SendNS", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_SendNS, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SendRS", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_SendRS, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsAlwaysDad", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_IsAlwaysDad, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "CreateCache", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_CreateCache, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "ForgeEchoRequest", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_ForgeEchoRequest, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Receive", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_Receive, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetProtocolNumber", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_GetProtocolNumber, METH_NOARGS, NULL },
    {(char *) "ForgeRS", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_ForgeRS, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetVersion", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_GetVersion, METH_NOARGS, NULL },
    {(char *) "SendErrorTimeExceeded", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_SendErrorTimeExceeded, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SendErrorParameterError", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_SendErrorParameterError, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SendRedirection", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_SendRedirection, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SendEchoReply", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol_SendEchoReply, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Icmpv6L4Protocol__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Icmpv6L4Protocol__tp_clear(PyNs3Icmpv6L4Protocol *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Icmpv6L4Protocol *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Icmpv6L4Protocol__tp_traverse(PyNs3Icmpv6L4Protocol *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Icmpv6L4Protocol__tp_dealloc(PyNs3Icmpv6L4Protocol *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Icmpv6L4Protocol__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Icmpv6L4Protocol__tp_richcompare (PyNs3Icmpv6L4Protocol *PYBINDGEN_UNUSED(self), PyNs3Icmpv6L4Protocol *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Icmpv6L4Protocol_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Icmpv6L4Protocol_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Icmpv6L4Protocol",            /* tp_name */
    sizeof(PyNs3Icmpv6L4Protocol),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Icmpv6L4Protocol__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Icmpv6L4Protocol__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Icmpv6L4Protocol__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Icmpv6L4Protocol__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Icmpv6L4Protocol_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Icmpv6L4Protocol, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Icmpv6L4Protocol__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv4GlobalRouting__tp_init__0(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4GlobalRouting *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4GlobalRouting_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4GlobalRouting(*((PyNs3Ipv4GlobalRouting *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4GlobalRouting__tp_init__1(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4GlobalRouting();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4GlobalRouting__tp_init(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4GlobalRouting__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4GlobalRouting__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_NotifyAddAddress(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv4InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv4InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyAddAddress(interface, *((PyNs3Ipv4InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_NotifyInterfaceUp(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceUp(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_NotifyInterfaceDown(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceDown(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_GetNRoutes(PyNs3Ipv4GlobalRouting *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNRoutes();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}



PyObject *
_wrap_PyNs3Ipv4GlobalRouting_AddHostRouteTo__0(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *dest;
    PyNs3Ipv4Address *nextHop;
    unsigned int interface;
    const char *keywords[] = {"dest", "nextHop", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &dest, &PyNs3Ipv4Address_Type, &nextHop, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddHostRouteTo(*((PyNs3Ipv4Address *) dest)->obj, *((PyNs3Ipv4Address *) nextHop)->obj, interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4GlobalRouting_AddHostRouteTo__1(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *dest;
    unsigned int interface;
    const char *keywords[] = {"dest", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &dest, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddHostRouteTo(*((PyNs3Ipv4Address *) dest)->obj, interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv4GlobalRouting_AddHostRouteTo(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4GlobalRouting_AddHostRouteTo__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4GlobalRouting_AddHostRouteTo__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}



PyObject *
_wrap_PyNs3Ipv4GlobalRouting_AddNetworkRouteTo__0(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *network;
    PyNs3Ipv4Mask *networkMask;
    PyNs3Ipv4Address *nextHop;
    unsigned int interface;
    const char *keywords[] = {"network", "networkMask", "nextHop", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &network, &PyNs3Ipv4Mask_Type, &networkMask, &PyNs3Ipv4Address_Type, &nextHop, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddNetworkRouteTo(*((PyNs3Ipv4Address *) network)->obj, *((PyNs3Ipv4Mask *) networkMask)->obj, *((PyNs3Ipv4Address *) nextHop)->obj, interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3Ipv4GlobalRouting_AddNetworkRouteTo__1(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *network;
    PyNs3Ipv4Mask *networkMask;
    unsigned int interface;
    const char *keywords[] = {"network", "networkMask", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &network, &PyNs3Ipv4Mask_Type, &networkMask, &interface)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddNetworkRouteTo(*((PyNs3Ipv4Address *) network)->obj, *((PyNs3Ipv4Mask *) networkMask)->obj, interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3Ipv4GlobalRouting_AddNetworkRouteTo(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4GlobalRouting_AddNetworkRouteTo__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4GlobalRouting_AddNetworkRouteTo__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_AddASExternalRouteTo(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *network;
    PyNs3Ipv4Mask *networkMask;
    PyNs3Ipv4Address *nextHop;
    unsigned int interface;
    const char *keywords[] = {"network", "networkMask", "nextHop", "interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!I", (char **) keywords, &PyNs3Ipv4Address_Type, &network, &PyNs3Ipv4Mask_Type, &networkMask, &PyNs3Ipv4Address_Type, &nextHop, &interface)) {
        return NULL;
    }
    self->obj->AddASExternalRouteTo(*((PyNs3Ipv4Address *) network)->obj, *((PyNs3Ipv4Mask *) networkMask)->obj, *((PyNs3Ipv4Address *) nextHop)->obj, interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_RouteOutput(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4Route > retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv4Header *header;
    PyNs3NetDevice *oif;
    ns3::NetDevice *oif_ptr;
    ns3::Socket::SocketErrno  sockerr;
    const char *keywords[] = {"p", "header", "oif", "sockerr", NULL};
    PyNs3Ipv4Route *py_Ipv4Route;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!i", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv4Header_Type, &header, &PyNs3NetDevice_Type, &oif, &sockerr)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    oif_ptr = (oif ? oif->obj : NULL);
    retval = self->obj->RouteOutput(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv4Header *) header)->obj, ns3::Ptr< ns3::NetDevice  > (oif_ptr), sockerr);
    if (!(const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Ipv4Route = NULL;
    } else {
        py_Ipv4Route = (PyNs3Ipv4Route *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4Route);
    }
    
    if (py_Ipv4Route == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4Route_Type);
        py_Ipv4Route = PyObject_New(PyNs3Ipv4Route, wrapper_type);
        py_Ipv4Route->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4Route->obj = const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Ipv4Route->obj] = (PyObject *) py_Ipv4Route;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Route);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_GetRoute(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ipv4RoutingTableEntry *retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    PyNs3Ipv4RoutingTableEntry *py_Ipv4RoutingTableEntry;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = self->obj->GetRoute(i);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Ipv4RoutingTableEntry_wrapper_registry.find((void *) retval);
    if (wrapper_lookup_iter == PyNs3Ipv4RoutingTableEntry_wrapper_registry.end()) {
        py_Ipv4RoutingTableEntry = NULL;
    } else {
        py_Ipv4RoutingTableEntry = (PyNs3Ipv4RoutingTableEntry *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4RoutingTableEntry);
    }
    
    if (py_Ipv4RoutingTableEntry == NULL) {
        py_Ipv4RoutingTableEntry = PyObject_New(PyNs3Ipv4RoutingTableEntry, &PyNs3Ipv4RoutingTableEntry_Type);
        py_Ipv4RoutingTableEntry->obj = new ns3::Ipv4RoutingTableEntry((*retval));
        py_Ipv4RoutingTableEntry->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        PyNs3Ipv4RoutingTableEntry_wrapper_registry[(void *) py_Ipv4RoutingTableEntry->obj] = (PyObject *) py_Ipv4RoutingTableEntry;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4RoutingTableEntry);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_SetIpv4(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    const char *keywords[] = {"ipv4", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4_Type, &ipv4)) {
        return NULL;
    }
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    self->obj->SetIpv4(ns3::Ptr< ns3::Ipv4  > (ipv4_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_AssignStreams(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int64_t retval;
    int64_t stream;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "L", (char **) keywords, &stream)) {
        return NULL;
    }
    retval = self->obj->AssignStreams(stream);
    py_retval = Py_BuildValue((char *) "L", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_PrintRoutingTable(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTable(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_RemoveRoute(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    self->obj->RemoveRoute(i);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv4GlobalRouting::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4GlobalRouting_NotifyRemoveAddress(PyNs3Ipv4GlobalRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv4InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv4InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyRemoveAddress(interface, *((PyNs3Ipv4InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4GlobalRouting__copy__(PyNs3Ipv4GlobalRouting *self)
{

    PyNs3Ipv4GlobalRouting *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv4GlobalRouting, &PyNs3Ipv4GlobalRouting_Type);
    py_copy->obj = new ns3::Ipv4GlobalRouting(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4GlobalRouting_methods[] = {
    {(char *) "NotifyAddAddress", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_NotifyAddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceUp", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_NotifyInterfaceUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceDown", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_NotifyInterfaceDown, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNRoutes", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_GetNRoutes, METH_NOARGS, NULL },
    {(char *) "AddHostRouteTo", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_AddHostRouteTo, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddNetworkRouteTo", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_AddNetworkRouteTo, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddASExternalRouteTo", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_AddASExternalRouteTo, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RouteOutput", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_RouteOutput, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetRoute", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_GetRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetIpv4", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_SetIpv4, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AssignStreams", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_AssignStreams, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTable", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_PrintRoutingTable, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RemoveRoute", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_RemoveRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "NotifyRemoveAddress", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting_NotifyRemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4GlobalRouting__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4GlobalRouting__tp_clear(PyNs3Ipv4GlobalRouting *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv4GlobalRouting *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv4GlobalRouting__tp_traverse(PyNs3Ipv4GlobalRouting *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv4GlobalRouting__tp_dealloc(PyNs3Ipv4GlobalRouting *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4GlobalRouting__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4GlobalRouting__tp_richcompare (PyNs3Ipv4GlobalRouting *PYBINDGEN_UNUSED(self), PyNs3Ipv4GlobalRouting *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4GlobalRouting_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4GlobalRouting_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4GlobalRouting",            /* tp_name */
    sizeof(PyNs3Ipv4GlobalRouting),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4GlobalRouting__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4GlobalRouting__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4GlobalRouting__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4GlobalRouting__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4GlobalRouting_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4GlobalRouting, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4GlobalRouting__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv4ListRouting__tp_init__0(PyNs3Ipv4ListRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv4ListRouting *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4ListRouting_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4ListRouting(*((PyNs3Ipv4ListRouting *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv4ListRouting__tp_init__1(PyNs3Ipv4ListRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv4ListRouting();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv4ListRouting__tp_init(PyNs3Ipv4ListRouting *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv4ListRouting__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv4ListRouting__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv4ListRouting_NotifyAddAddress(PyNs3Ipv4ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv4InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv4InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyAddAddress(interface, *((PyNs3Ipv4InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4ListRouting_NotifyInterfaceUp(PyNs3Ipv4ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceUp(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4ListRouting_NotifyInterfaceDown(PyNs3Ipv4ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceDown(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4ListRouting_GetRoutingProtocol(PyNs3Ipv4ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4RoutingProtocol > retval;
    unsigned int index;
    int16_t  priority;
    const char *keywords[] = {"index", NULL};
    PyNs3Ipv4RoutingProtocol *py_Ipv4RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    retval = self->obj->GetRoutingProtocol(index, priority);
    if (!(const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv4RoutingProtocol = NULL;
    } else {
        py_Ipv4RoutingProtocol = (PyNs3Ipv4RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4RoutingProtocol);
    }
    
    if (py_Ipv4RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4RoutingProtocol_Type);
        py_Ipv4RoutingProtocol = PyObject_GC_New(PyNs3Ipv4RoutingProtocol, wrapper_type);
        py_Ipv4RoutingProtocol->inst_dict = NULL;
        py_Ipv4RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4RoutingProtocol->obj = const_cast<ns3::Ipv4RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv4RoutingProtocol->obj] = (PyObject *) py_Ipv4RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "Nh", py_Ipv4RoutingProtocol, priority);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4ListRouting_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv4ListRouting::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4ListRouting_RouteOutput(PyNs3Ipv4ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv4Route > retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv4Header *header;
    PyNs3NetDevice *oif;
    ns3::NetDevice *oif_ptr;
    ns3::Socket::SocketErrno  sockerr;
    const char *keywords[] = {"p", "header", "oif", "sockerr", NULL};
    PyNs3Ipv4Route *py_Ipv4Route;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!i", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv4Header_Type, &header, &PyNs3NetDevice_Type, &oif, &sockerr)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    oif_ptr = (oif ? oif->obj : NULL);
    retval = self->obj->RouteOutput(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv4Header *) header)->obj, ns3::Ptr< ns3::NetDevice  > (oif_ptr), sockerr);
    if (!(const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Ipv4Route = NULL;
    } else {
        py_Ipv4Route = (PyNs3Ipv4Route *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv4Route);
    }
    
    if (py_Ipv4Route == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval)))), &PyNs3Ipv4Route_Type);
        py_Ipv4Route = PyObject_New(PyNs3Ipv4Route, wrapper_type);
        py_Ipv4Route->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv4Route->obj = const_cast<ns3::Ipv4Route *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Ipv4Route->obj] = (PyObject *) py_Ipv4Route;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv4Route);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4ListRouting_SetIpv4(PyNs3Ipv4ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4 *ipv4;
    ns3::Ipv4 *ipv4_ptr;
    const char *keywords[] = {"ipv4", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4_Type, &ipv4)) {
        return NULL;
    }
    ipv4_ptr = (ipv4 ? ipv4->obj : NULL);
    self->obj->SetIpv4(ns3::Ptr< ns3::Ipv4  > (ipv4_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4ListRouting_AddRoutingProtocol(PyNs3Ipv4ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv4RoutingProtocol *routingProtocol;
    ns3::Ipv4RoutingProtocol *routingProtocol_ptr;
    int priority;
    const char *keywords[] = {"routingProtocol", "priority", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!i", (char **) keywords, &PyNs3Ipv4RoutingProtocol_Type, &routingProtocol, &priority)) {
        return NULL;
    }
    routingProtocol_ptr = (routingProtocol ? routingProtocol->obj : NULL);
    if (priority > 0x7fff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->AddRoutingProtocol(ns3::Ptr< ns3::Ipv4RoutingProtocol  > (routingProtocol_ptr), priority);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4ListRouting_PrintRoutingTable(PyNs3Ipv4ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTable(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4ListRouting_GetNRoutingProtocols(PyNs3Ipv4ListRouting *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNRoutingProtocols();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv4ListRouting_NotifyRemoveAddress(PyNs3Ipv4ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv4InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv4InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyRemoveAddress(interface, *((PyNs3Ipv4InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv4ListRouting__copy__(PyNs3Ipv4ListRouting *self)
{

    PyNs3Ipv4ListRouting *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv4ListRouting, &PyNs3Ipv4ListRouting_Type);
    py_copy->obj = new ns3::Ipv4ListRouting(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv4ListRouting_methods[] = {
    {(char *) "NotifyAddAddress", (PyCFunction) _wrap_PyNs3Ipv4ListRouting_NotifyAddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceUp", (PyCFunction) _wrap_PyNs3Ipv4ListRouting_NotifyInterfaceUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceDown", (PyCFunction) _wrap_PyNs3Ipv4ListRouting_NotifyInterfaceDown, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetRoutingProtocol", (PyCFunction) _wrap_PyNs3Ipv4ListRouting_GetRoutingProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv4ListRouting_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "RouteOutput", (PyCFunction) _wrap_PyNs3Ipv4ListRouting_RouteOutput, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetIpv4", (PyCFunction) _wrap_PyNs3Ipv4ListRouting_SetIpv4, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddRoutingProtocol", (PyCFunction) _wrap_PyNs3Ipv4ListRouting_AddRoutingProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTable", (PyCFunction) _wrap_PyNs3Ipv4ListRouting_PrintRoutingTable, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNRoutingProtocols", (PyCFunction) _wrap_PyNs3Ipv4ListRouting_GetNRoutingProtocols, METH_NOARGS, NULL },
    {(char *) "NotifyRemoveAddress", (PyCFunction) _wrap_PyNs3Ipv4ListRouting_NotifyRemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv4ListRouting__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv4ListRouting__tp_clear(PyNs3Ipv4ListRouting *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv4ListRouting *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv4ListRouting__tp_traverse(PyNs3Ipv4ListRouting *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv4ListRouting__tp_dealloc(PyNs3Ipv4ListRouting *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv4ListRouting__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv4ListRouting__tp_richcompare (PyNs3Ipv4ListRouting *PYBINDGEN_UNUSED(self), PyNs3Ipv4ListRouting *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv4ListRouting_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv4ListRouting_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv4ListRouting",            /* tp_name */
    sizeof(PyNs3Ipv4ListRouting),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv4ListRouting__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv4ListRouting__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv4ListRouting__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv4ListRouting__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv4ListRouting_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv4ListRouting, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv4ListRouting__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3Ipv6ExtensionLooseRouting__get_TYPE_ROUTING(PyObject * PYBINDGEN_UNUSED(obj), void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "i", (int)ns3::Ipv6ExtensionLooseRouting::TYPE_ROUTING);
    return py_retval;
}
static PyGetSetDef Ns3Ipv6ExtensionLooseRoutingMeta__getsets[] = {
    {
        (char*) "TYPE_ROUTING", /* attribute name */
        (getter) _wrap_PyNs3Ipv6ExtensionLooseRouting__get_TYPE_ROUTING, /* C function to get the attribute */
        (setter) NULL, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};

PyTypeObject PyNs3Ipv6ExtensionLooseRoutingMeta_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	(char *) "Ns3Ipv6ExtensionLooseRoutingMeta",		        /* tp_name */
	0,					/* tp_basicsize */
	0,					/* tp_itemsize */
	0,	 				/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, /* tp_flags */
 	0,					/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	Ns3Ipv6ExtensionLooseRoutingMeta__getsets,				/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,	                                /* tp_descr_get */
	0,  		                        /* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	0,					/* tp_new */
	0,               			/* tp_free */
        0,                                      /* tp_is_gc */
        0,                                      /* tp_bases */
        0,                                      /* tp_mro */
        0,                                      /* tp_cache */
        0,                                      /* tp_subclasses */
        0,                                      /* tp_weaklist */
        0                                       /* tp_del */
};



static int
_wrap_PyNs3Ipv6ExtensionLooseRouting__tp_init__0(PyNs3Ipv6ExtensionLooseRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ExtensionLooseRouting *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ExtensionLooseRouting_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionLooseRouting(*((PyNs3Ipv6ExtensionLooseRouting *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ExtensionLooseRouting__tp_init__1(PyNs3Ipv6ExtensionLooseRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ExtensionLooseRouting();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ExtensionLooseRouting__tp_init(PyNs3Ipv6ExtensionLooseRouting *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ExtensionLooseRouting__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ExtensionLooseRouting__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionLooseRouting_GetTypeRouting(PyNs3Ipv6ExtensionLooseRouting *self)
{
    PyObject *py_retval;
    uint8_t retval;
    
    retval = self->obj->GetTypeRouting();
    py_retval = Py_BuildValue((char *) "i", (int)retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ExtensionLooseRouting_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ExtensionLooseRouting::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ExtensionLooseRouting__copy__(PyNs3Ipv6ExtensionLooseRouting *self)
{

    PyNs3Ipv6ExtensionLooseRouting *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ExtensionLooseRouting, &PyNs3Ipv6ExtensionLooseRouting_Type);
    py_copy->obj = new ns3::Ipv6ExtensionLooseRouting(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ExtensionLooseRouting_methods[] = {
    {(char *) "GetTypeRouting", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRouting_GetTypeRouting, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRouting_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ExtensionLooseRouting__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ExtensionLooseRouting__tp_clear(PyNs3Ipv6ExtensionLooseRouting *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6ExtensionLooseRouting *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6ExtensionLooseRouting__tp_traverse(PyNs3Ipv6ExtensionLooseRouting *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ExtensionLooseRouting__tp_dealloc(PyNs3Ipv6ExtensionLooseRouting *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ExtensionLooseRouting__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ExtensionLooseRouting__tp_richcompare (PyNs3Ipv6ExtensionLooseRouting *PYBINDGEN_UNUSED(self), PyNs3Ipv6ExtensionLooseRouting *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ExtensionLooseRouting_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ExtensionLooseRouting_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ExtensionLooseRouting",            /* tp_name */
    sizeof(PyNs3Ipv6ExtensionLooseRouting),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ExtensionLooseRouting__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ExtensionLooseRouting__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ExtensionLooseRouting__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ExtensionLooseRouting__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ExtensionLooseRouting_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ExtensionLooseRouting, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ExtensionLooseRouting__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3Ipv6ListRouting__tp_init__0(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3Ipv6ListRouting *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6ListRouting_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ListRouting(*((PyNs3Ipv6ListRouting *) arg0)->obj);
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3Ipv6ListRouting__tp_init__1(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::Ipv6ListRouting();
    self->obj->Ref ();
    ns3::CompleteConstruct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3Ipv6ListRouting__tp_init(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3Ipv6ListRouting__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3Ipv6ListRouting__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_NotifyAddAddress(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv6InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv6InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyAddAddress(interface, *((PyNs3Ipv6InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_NotifyAddRoute(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Prefix *mask;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    PyNs3Ipv6Address *prefixToUse = NULL;
    const char *keywords[] = {"dst", "mask", "nextHop", "interface", "prefixToUse", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!I|O!", (char **) keywords, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Prefix_Type, &mask, &PyNs3Ipv6Address_Type, &nextHop, &interface, &PyNs3Ipv6Address_Type, &prefixToUse)) {
        return NULL;
    }
    self->obj->NotifyAddRoute(*((PyNs3Ipv6Address *) dst)->obj, *((PyNs3Ipv6Prefix *) mask)->obj, *((PyNs3Ipv6Address *) nextHop)->obj, interface, (prefixToUse ? (*((PyNs3Ipv6Address *) prefixToUse)->obj) : ns3::Ipv6Address::GetZero( )));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_NotifyInterfaceUp(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceUp(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_NotifyInterfaceDown(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    const char *keywords[] = {"interface", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &interface)) {
        return NULL;
    }
    self->obj->NotifyInterfaceDown(interface);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_GetRoutingProtocol(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6RoutingProtocol > retval;
    unsigned int index;
    int16_t  priority;
    const char *keywords[] = {"index", "priority", NULL};
    PyNs3Ipv6RoutingProtocol *py_Ipv6RoutingProtocol;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "Ih", (char **) keywords, &index, &priority)) {
        return NULL;
    }
    retval = self->obj->GetRoutingProtocol(index, priority);
    if (!(const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
        py_Ipv6RoutingProtocol = NULL;
    } else {
        py_Ipv6RoutingProtocol = (PyNs3Ipv6RoutingProtocol *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6RoutingProtocol);
    }
    
    if (py_Ipv6RoutingProtocol == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6RoutingProtocol_Type);
        py_Ipv6RoutingProtocol = PyObject_GC_New(PyNs3Ipv6RoutingProtocol, wrapper_type);
        py_Ipv6RoutingProtocol->inst_dict = NULL;
        py_Ipv6RoutingProtocol->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv6RoutingProtocol->obj = const_cast<ns3::Ipv6RoutingProtocol *> (ns3::PeekPointer (retval));
        PyNs3ObjectBase_wrapper_registry[(void *) py_Ipv6RoutingProtocol->obj] = (PyObject *) py_Ipv6RoutingProtocol;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6RoutingProtocol);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_RouteOutput(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Ipv6Route > retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3Ipv6Header *header;
    PyNs3NetDevice *oif;
    ns3::NetDevice *oif_ptr;
    ns3::Socket::SocketErrno  sockerr;
    const char *keywords[] = {"p", "header", "oif", "sockerr", NULL};
    PyNs3Ipv6Route *py_Ipv6Route;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!i", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3Ipv6Header_Type, &header, &PyNs3NetDevice_Type, &oif, &sockerr)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    oif_ptr = (oif ? oif->obj : NULL);
    retval = self->obj->RouteOutput(ns3::Ptr< ns3::Packet  > (p_ptr), *((PyNs3Ipv6Header *) header)->obj, ns3::Ptr< ns3::NetDevice  > (oif_ptr), sockerr);
    if (!(const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Ipv6Route = NULL;
    } else {
        py_Ipv6Route = (PyNs3Ipv6Route *) wrapper_lookup_iter->second;
        Py_INCREF(py_Ipv6Route);
    }
    
    if (py_Ipv6Route == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval)))), &PyNs3Ipv6Route_Type);
        py_Ipv6Route = PyObject_New(PyNs3Ipv6Route, wrapper_type);
        py_Ipv6Route->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval))->Ref();
        py_Ipv6Route->obj = const_cast<ns3::Ipv6Route *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_Ipv6Route->obj] = (PyObject *) py_Ipv6Route;
    }
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Route);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::Ipv6ListRouting::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_NotifyRemoveRoute(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *dst;
    PyNs3Ipv6Prefix *mask;
    PyNs3Ipv6Address *nextHop;
    unsigned int interface;
    PyNs3Ipv6Address *prefixToUse = NULL;
    const char *keywords[] = {"dst", "mask", "nextHop", "interface", "prefixToUse", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!I|O!", (char **) keywords, &PyNs3Ipv6Address_Type, &dst, &PyNs3Ipv6Prefix_Type, &mask, &PyNs3Ipv6Address_Type, &nextHop, &interface, &PyNs3Ipv6Address_Type, &prefixToUse)) {
        return NULL;
    }
    self->obj->NotifyRemoveRoute(*((PyNs3Ipv6Address *) dst)->obj, *((PyNs3Ipv6Prefix *) mask)->obj, *((PyNs3Ipv6Address *) nextHop)->obj, interface, (prefixToUse ? (*((PyNs3Ipv6Address *) prefixToUse)->obj) : ns3::Ipv6Address::GetZero( )));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_SetIpv6(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6 *ipv6;
    ns3::Ipv6 *ipv6_ptr;
    const char *keywords[] = {"ipv6", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6_Type, &ipv6)) {
        return NULL;
    }
    ipv6_ptr = (ipv6 ? ipv6->obj : NULL);
    self->obj->SetIpv6(ns3::Ptr< ns3::Ipv6  > (ipv6_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_AddRoutingProtocol(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Ipv6RoutingProtocol *routingProtocol;
    ns3::Ipv6RoutingProtocol *routingProtocol_ptr;
    int priority;
    const char *keywords[] = {"routingProtocol", "priority", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!i", (char **) keywords, &PyNs3Ipv6RoutingProtocol_Type, &routingProtocol, &priority)) {
        return NULL;
    }
    routingProtocol_ptr = (routingProtocol ? routingProtocol->obj : NULL);
    if (priority > 0x7fff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    self->obj->AddRoutingProtocol(ns3::Ptr< ns3::Ipv6RoutingProtocol  > (routingProtocol_ptr), priority);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_PrintRoutingTable(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3OutputStreamWrapper *stream;
    ns3::OutputStreamWrapper *stream_ptr;
    const char *keywords[] = {"stream", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3OutputStreamWrapper_Type, &stream)) {
        return NULL;
    }
    stream_ptr = (stream ? stream->obj : NULL);
    self->obj->PrintRoutingTable(ns3::Ptr< ns3::OutputStreamWrapper  > (stream_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_GetNRoutingProtocols(PyNs3Ipv6ListRouting *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNRoutingProtocols();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3Ipv6ListRouting_NotifyRemoveAddress(PyNs3Ipv6ListRouting *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int interface;
    PyNs3Ipv6InterfaceAddress *address;
    const char *keywords[] = {"interface", "address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "IO!", (char **) keywords, &interface, &PyNs3Ipv6InterfaceAddress_Type, &address)) {
        return NULL;
    }
    self->obj->NotifyRemoveAddress(interface, *((PyNs3Ipv6InterfaceAddress *) address)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3Ipv6ListRouting__copy__(PyNs3Ipv6ListRouting *self)
{

    PyNs3Ipv6ListRouting *py_copy;
    py_copy = PyObject_GC_New(PyNs3Ipv6ListRouting, &PyNs3Ipv6ListRouting_Type);
    py_copy->obj = new ns3::Ipv6ListRouting(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3Ipv6ListRouting_methods[] = {
    {(char *) "NotifyAddAddress", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_NotifyAddAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyAddRoute", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_NotifyAddRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceUp", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_NotifyInterfaceUp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyInterfaceDown", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_NotifyInterfaceDown, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetRoutingProtocol", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_GetRoutingProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "RouteOutput", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_RouteOutput, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "NotifyRemoveRoute", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_NotifyRemoveRoute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetIpv6", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_SetIpv6, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddRoutingProtocol", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_AddRoutingProtocol, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "PrintRoutingTable", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_PrintRoutingTable, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNRoutingProtocols", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_GetNRoutingProtocols, METH_NOARGS, NULL },
    {(char *) "NotifyRemoveAddress", (PyCFunction) _wrap_PyNs3Ipv6ListRouting_NotifyRemoveAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3Ipv6ListRouting__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3Ipv6ListRouting__tp_clear(PyNs3Ipv6ListRouting *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::Ipv6ListRouting *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3Ipv6ListRouting__tp_traverse(PyNs3Ipv6ListRouting *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3Ipv6ListRouting__tp_dealloc(PyNs3Ipv6ListRouting *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3Ipv6ListRouting__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3Ipv6ListRouting__tp_richcompare (PyNs3Ipv6ListRouting *PYBINDGEN_UNUSED(self), PyNs3Ipv6ListRouting *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3Ipv6ListRouting_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3Ipv6ListRouting_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Ipv6ListRouting",            /* tp_name */
    sizeof(PyNs3Ipv6ListRouting),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3Ipv6ListRouting__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3Ipv6ListRouting__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3Ipv6ListRouting__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3Ipv6ListRouting__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3Ipv6ListRouting_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3Ipv6ListRouting, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3Ipv6ListRouting__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3LoopbackNetDevice__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3LoopbackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3LoopbackNetDevice__PythonHelper::_wrap_NotifyNewAggregate(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3LoopbackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3LoopbackNetDevice__PythonHelper::_wrap_DoStart(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3LoopbackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3LoopbackNetDevice__PythonHelper::_wrap_DoDispose(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3LoopbackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class LoopbackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


ns3::Address
PyNs3LoopbackNetDevice__PythonHelper::GetAddress() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Address *tmp_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetAddress();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetAddress", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetAddress();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetAddress();
    }
    ns3::Address retval = *tmp_Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Address
PyNs3LoopbackNetDevice__PythonHelper::GetBroadcast() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Address *tmp_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetBroadcast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetBroadcast();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetBroadcast", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetBroadcast();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetBroadcast();
    }
    ns3::Address retval = *tmp_Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Channel >
PyNs3LoopbackNetDevice__PythonHelper::GetChannel() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Channel > retval;
    PyNs3Channel *tmp_Channel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetChannel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetChannel();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetChannel", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetChannel();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Channel_Type, &tmp_Channel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetChannel();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Channel  > (tmp_Channel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3LoopbackNetDevice__PythonHelper::GetIfIndex() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetIfIndex"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetIfIndex();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetIfIndex", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetIfIndex();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetIfIndex();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint16_t
PyNs3LoopbackNetDevice__PythonHelper::GetMtu() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    uint16_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetMtu"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetMtu();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetMtu", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetMtu();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetMtu();
    }
    if (tmp > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetMtu();
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Address
PyNs3LoopbackNetDevice__PythonHelper::GetMulticast(ns3::Ipv4Address multicastGroup) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    PyNs3Address *tmp_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetMulticast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetMulticast(multicastGroup);
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(multicastGroup);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetMulticast", (char *) "N", py_Ipv4Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetMulticast(multicastGroup);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetMulticast(multicastGroup);
    }
    ns3::Address retval = *tmp_Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Address
PyNs3LoopbackNetDevice__PythonHelper::GetMulticast(ns3::Ipv6Address addr) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    PyNs3Address *tmp_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetMulticast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetMulticast(addr);
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(addr);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetMulticast", (char *) "N", py_Ipv6Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetMulticast(addr);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetMulticast(addr);
    }
    ns3::Address retval = *tmp_Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Node >
PyNs3LoopbackNetDevice__PythonHelper::GetNode() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3Node *tmp_Node;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetNode"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetNode();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetNode", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetNode();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Node_Type, &tmp_Node)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::GetNode();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Node  > (tmp_Node->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3LoopbackNetDevice__PythonHelper::IsBridge() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsBridge"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsBridge();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsBridge", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsBridge();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsBridge();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3LoopbackNetDevice__PythonHelper::IsBroadcast() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsBroadcast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsBroadcast();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsBroadcast", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsBroadcast();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsBroadcast();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3LoopbackNetDevice__PythonHelper::IsLinkUp() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsLinkUp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsLinkUp();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsLinkUp", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsLinkUp();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsLinkUp();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3LoopbackNetDevice__PythonHelper::IsMulticast() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsMulticast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsMulticast();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsMulticast", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsMulticast();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsMulticast();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3LoopbackNetDevice__PythonHelper::IsPointToPoint() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "IsPointToPoint"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsPointToPoint();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "IsPointToPoint", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsPointToPoint();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::IsPointToPoint();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3LoopbackNetDevice__PythonHelper::NeedsArp() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NeedsArp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::NeedsArp();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NeedsArp", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::NeedsArp();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::NeedsArp();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3LoopbackNetDevice__PythonHelper::Send(ns3::Ptr< ns3::Packet > packet, ns3::Address const & dest, uint16_t protocolNumber)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Address *py_Address;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "Send"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::Send(packet, dest, protocolNumber);
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = (ns3::LoopbackNetDevice*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (packet)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (packet))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (packet))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (packet));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(dest);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "Send", (char *) "NNi", py_Packet, py_Address, (int) protocolNumber);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::Send(packet, dest, protocolNumber);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::Send(packet, dest, protocolNumber);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3LoopbackNetDevice__PythonHelper::SendFrom(ns3::Ptr< ns3::Packet > packet, ns3::Address const & source, ns3::Address const & dest, uint16_t protocolNumber)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Address *py_Address;
    PyNs3Address *py_Address2;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SendFrom"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::SendFrom(packet, source, dest, protocolNumber);
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = (ns3::LoopbackNetDevice*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (packet)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (packet))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (packet))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (packet));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(source);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_Address2 = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address2->obj = new ns3::Address(dest);
    PyNs3Address_wrapper_registry[(void *) py_Address2->obj] = (PyObject *) py_Address2;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SendFrom", (char *) "NNNi", py_Packet, py_Address, py_Address2, (int) protocolNumber);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::SendFrom(packet, source, dest, protocolNumber);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::SendFrom(packet, source, dest, protocolNumber);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3LoopbackNetDevice__PythonHelper::SetAddress(ns3::Address address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::LoopbackNetDevice::SetAddress(address);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = (ns3::LoopbackNetDevice*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(address);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetAddress", (char *) "N", py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3LoopbackNetDevice__PythonHelper::SetIfIndex(uint32_t const index)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetIfIndex"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::LoopbackNetDevice::SetIfIndex(index);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = (ns3::LoopbackNetDevice*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetIfIndex", (char *) "N", PyLong_FromUnsignedLong(index));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3LoopbackNetDevice__PythonHelper::SetMtu(uint16_t const mtu)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetMtu"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::SetMtu(mtu);
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = (ns3::LoopbackNetDevice*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetMtu", (char *) "i", (int) mtu);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::SetMtu(mtu);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::SetMtu(mtu);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3LoopbackNetDevice__PythonHelper::SetNode(ns3::Ptr< ns3::Node > node)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Node *py_Node;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SetNode"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::LoopbackNetDevice::SetNode(node);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = (ns3::LoopbackNetDevice*) this;
    if (typeid(*(const_cast<ns3::Node *> (ns3::PeekPointer (node)))).name() == typeid(PyNs3Node__PythonHelper).name())
    {
        py_Node = (PyNs3Node*) (((PyNs3Node__PythonHelper*) const_cast<ns3::Node *> (ns3::PeekPointer (node)))->m_pyself);
        py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (node));
        Py_INCREF(py_Node);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Node *> (ns3::PeekPointer (node)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Node = NULL;
        } else {
            py_Node = (PyNs3Node *) wrapper_lookup_iter->second;
            Py_INCREF(py_Node);
        }
    
        if (py_Node == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Node *> (ns3::PeekPointer (node))), &PyNs3Node_Type);
            py_Node = PyObject_GC_New(PyNs3Node, wrapper_type);
            py_Node->inst_dict = NULL;
            py_Node->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Node *> (ns3::PeekPointer (node))->Ref();
            py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (node));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Node->obj] = (PyObject *) py_Node;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SetNode", (char *) "N", py_Node);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}



bool
PyNs3LoopbackNetDevice__PythonHelper::SupportsSendFrom() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "SupportsSendFrom"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::SupportsSendFrom();
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = const_cast< ns3::LoopbackNetDevice* >((const ns3::LoopbackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "SupportsSendFrom", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::SupportsSendFrom();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::LoopbackNetDevice::SupportsSendFrom();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3LoopbackNetDevice__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::LoopbackNetDevice *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::LoopbackNetDevice::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = (ns3::LoopbackNetDevice*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3LoopbackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3LoopbackNetDevice__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3LoopbackNetDevice__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3LoopbackNetDevice__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3LoopbackNetDevice__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3LoopbackNetDevice__tp_init__0(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3LoopbackNetDevice *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3LoopbackNetDevice_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3LoopbackNetDevice_Type)
    {
        self->obj = new PyNs3LoopbackNetDevice__PythonHelper(*((PyNs3LoopbackNetDevice *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3LoopbackNetDevice__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::LoopbackNetDevice(*((PyNs3LoopbackNetDevice *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3LoopbackNetDevice__tp_init__1(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3LoopbackNetDevice_Type)
    {
        self->obj = new PyNs3LoopbackNetDevice__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3LoopbackNetDevice__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::LoopbackNetDevice();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3LoopbackNetDevice__tp_init(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3LoopbackNetDevice__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3LoopbackNetDevice__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}



PyObject *
_wrap_PyNs3LoopbackNetDevice_GetMulticast__0(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *multicastGroup;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    const char *keywords[] = {"multicastGroup", NULL};
    PyNs3Address *py_Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &multicastGroup)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Address retval = (helper_class == NULL)? (self->obj->GetMulticast(*((PyNs3Ipv4Address *) multicastGroup)->obj)) : (self->obj->ns3::LoopbackNetDevice::GetMulticast(*((PyNs3Ipv4Address *) multicastGroup)->obj));
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject *
_wrap_PyNs3LoopbackNetDevice_GetMulticast__1(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *addr;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    const char *keywords[] = {"addr", NULL};
    PyNs3Address *py_Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &addr)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Address retval = (helper_class == NULL)? (self->obj->GetMulticast(*((PyNs3Ipv6Address *) addr)->obj)) : (self->obj->ns3::LoopbackNetDevice::GetMulticast(*((PyNs3Ipv6Address *) addr)->obj));
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject * _wrap_PyNs3LoopbackNetDevice_GetMulticast(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3LoopbackNetDevice_GetMulticast__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3LoopbackNetDevice_GetMulticast__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_IsPointToPoint(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->IsPointToPoint()) : (self->obj->ns3::LoopbackNetDevice::IsPointToPoint());
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::LoopbackNetDevice::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_Send(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyObject *dest;
    ns3::Address dest2;
    int protocolNumber;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    const char *keywords[] = {"packet", "dest", "protocolNumber", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!Oi", (char **) keywords, &PyNs3Packet_Type, &packet, &dest, &protocolNumber)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Address_Type)) {
        dest2 = *((PyNs3Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv4Address_Type)) {
        dest2 = *((PyNs3Ipv4Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv6Address_Type)) {
        dest2 = *((PyNs3Ipv6Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Mac48Address_Type)) {
        dest2 = *((PyNs3Mac48Address *) dest)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", dest->ob_type->tp_name);
        return NULL;
    }
    if (protocolNumber > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->Send(ns3::Ptr< ns3::Packet  > (packet_ptr), dest2, protocolNumber)) : (self->obj->ns3::LoopbackNetDevice::Send(ns3::Ptr< ns3::Packet  > (packet_ptr), dest2, protocolNumber));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_GetIfIndex(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->GetIfIndex()) : (self->obj->ns3::LoopbackNetDevice::GetIfIndex());
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_NeedsArp(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->NeedsArp()) : (self->obj->ns3::LoopbackNetDevice::NeedsArp());
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_SetPromiscReceiveCallback(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl9> cb_cb_impl;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl9> (cb);
    (helper_class == NULL)? (self->obj->SetPromiscReceiveCallback(ns3::Callback<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<ns3::Packet const>, unsigned short, ns3::Address const&, ns3::Address const&, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl))) : (self->obj->ns3::LoopbackNetDevice::SetPromiscReceiveCallback(ns3::Callback<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<ns3::Packet const>, unsigned short, ns3::Address const&, ns3::Address const&, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl)));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_GetNode(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    PyNs3Node *py_Node;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = (helper_class == NULL)? (self->obj->GetNode()) : (self->obj->ns3::LoopbackNetDevice::GetNode());
    if (!(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Node__PythonHelper).name())
    {
        py_Node = reinterpret_cast< PyNs3Node* >(reinterpret_cast< PyNs3Node__PythonHelper* >(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Node);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Node *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Node = NULL;
        } else {
            py_Node = (PyNs3Node *) wrapper_lookup_iter->second;
            Py_INCREF(py_Node);
        }
    
        if (py_Node == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))), &PyNs3Node_Type);
            py_Node = PyObject_GC_New(PyNs3Node, wrapper_type);
            py_Node->inst_dict = NULL;
            py_Node->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Node *> (ns3::PeekPointer (retval))->Ref();
            py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Node->obj] = (PyObject *) py_Node;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Node);
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_SendFrom(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyObject *source;
    ns3::Address source2;
    PyObject *dest;
    ns3::Address dest2;
    int protocolNumber;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    const char *keywords[] = {"packet", "source", "dest", "protocolNumber", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!OOi", (char **) keywords, &PyNs3Packet_Type, &packet, &source, &dest, &protocolNumber)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (PyObject_IsInstance(source, (PyObject*) &PyNs3Address_Type)) {
        source2 = *((PyNs3Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv4Address_Type)) {
        source2 = *((PyNs3Ipv4Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv6Address_Type)) {
        source2 = *((PyNs3Ipv6Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Mac48Address_Type)) {
        source2 = *((PyNs3Mac48Address *) source)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", source->ob_type->tp_name);
        return NULL;
    }
    if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Address_Type)) {
        dest2 = *((PyNs3Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv4Address_Type)) {
        dest2 = *((PyNs3Ipv4Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv6Address_Type)) {
        dest2 = *((PyNs3Ipv6Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Mac48Address_Type)) {
        dest2 = *((PyNs3Mac48Address *) dest)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", dest->ob_type->tp_name);
        return NULL;
    }
    if (protocolNumber > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->SendFrom(ns3::Ptr< ns3::Packet  > (packet_ptr), source2, dest2, protocolNumber)) : (self->obj->ns3::LoopbackNetDevice::SendFrom(ns3::Ptr< ns3::Packet  > (packet_ptr), source2, dest2, protocolNumber));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_IsBroadcast(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->IsBroadcast()) : (self->obj->ns3::LoopbackNetDevice::IsBroadcast());
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_GetMtu(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    uint16_t retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->GetMtu()) : (self->obj->ns3::LoopbackNetDevice::GetMtu());
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_IsBridge(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->IsBridge()) : (self->obj->ns3::LoopbackNetDevice::IsBridge());
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_SetNode(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    (helper_class == NULL)? (self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr))) : (self->obj->ns3::LoopbackNetDevice::SetNode(ns3::Ptr< ns3::Node  > (node_ptr)));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_GetAddress(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    PyNs3Address *py_Address;
    
    ns3::Address retval = (helper_class == NULL)? (self->obj->GetAddress()) : (self->obj->ns3::LoopbackNetDevice::GetAddress());
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_IsLinkUp(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->IsLinkUp()) : (self->obj->ns3::LoopbackNetDevice::IsLinkUp());
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_SetIfIndex(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int index;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    const char *keywords[] = {"index", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    (helper_class == NULL)? (self->obj->SetIfIndex(index)) : (self->obj->ns3::LoopbackNetDevice::SetIfIndex(index));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_SetAddress(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *address;
    ns3::Address address2;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &address)) {
        return NULL;
    }
    if (PyObject_IsInstance(address, (PyObject*) &PyNs3Address_Type)) {
        address2 = *((PyNs3Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv4Address_Type)) {
        address2 = *((PyNs3Ipv4Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv6Address_Type)) {
        address2 = *((PyNs3Ipv6Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Mac48Address_Type)) {
        address2 = *((PyNs3Mac48Address *) address)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", address->ob_type->tp_name);
        return NULL;
    }
    (helper_class == NULL)? (self->obj->SetAddress(address2)) : (self->obj->ns3::LoopbackNetDevice::SetAddress(address2));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_GetBroadcast(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    PyNs3Address *py_Address;
    
    ns3::Address retval = (helper_class == NULL)? (self->obj->GetBroadcast()) : (self->obj->ns3::LoopbackNetDevice::GetBroadcast());
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_AddLinkChangeCallback(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *callback;
    ns3::Ptr<PythonCallbackImpl0> callback_cb_impl;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    const char *keywords[] = {"callback", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &callback)) {
        return NULL;
    }
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'callback' must be callbale");
        return NULL;
    }
    callback_cb_impl = ns3::Create<PythonCallbackImpl0> (callback);
    (helper_class == NULL)? (self->obj->AddLinkChangeCallback(ns3::Callback<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (callback_cb_impl))) : (self->obj->ns3::LoopbackNetDevice::AddLinkChangeCallback(ns3::Callback<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (callback_cb_impl)));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_SetReceiveCallback(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl10> cb_cb_impl;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl10> (cb);
    (helper_class == NULL)? (self->obj->SetReceiveCallback(ns3::Callback<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<ns3::Packet const>, unsigned short, ns3::Address const&, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl))) : (self->obj->ns3::LoopbackNetDevice::SetReceiveCallback(ns3::Callback<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<ns3::Packet const>, unsigned short, ns3::Address const&, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl)));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_IsMulticast(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->IsMulticast()) : (self->obj->ns3::LoopbackNetDevice::IsMulticast());
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_SetMtu(PyNs3LoopbackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    int mtu;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    const char *keywords[] = {"mtu", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &mtu)) {
        return NULL;
    }
    if (mtu > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    retval = (helper_class == NULL)? (self->obj->SetMtu(mtu)) : (self->obj->ns3::LoopbackNetDevice::SetMtu(mtu));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_SupportsSendFrom(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    
    retval = (helper_class == NULL)? (self->obj->SupportsSendFrom()) : (self->obj->ns3::LoopbackNetDevice::SupportsSendFrom());
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3LoopbackNetDevice_GetChannel(PyNs3LoopbackNetDevice *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Channel > retval;
    PyNs3LoopbackNetDevice__PythonHelper *helper_class = dynamic_cast<PyNs3LoopbackNetDevice__PythonHelper*> (self->obj);
    PyNs3Channel *py_Channel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = (helper_class == NULL)? (self->obj->GetChannel()) : (self->obj->ns3::LoopbackNetDevice::GetChannel());
    if (!(const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Channel__PythonHelper).name())
    {
        py_Channel = reinterpret_cast< PyNs3Channel* >(reinterpret_cast< PyNs3Channel__PythonHelper* >(const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Channel->obj = const_cast<ns3::Channel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Channel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Channel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Channel = NULL;
        } else {
            py_Channel = (PyNs3Channel *) wrapper_lookup_iter->second;
            Py_INCREF(py_Channel);
        }
    
        if (py_Channel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))), &PyNs3Channel_Type);
            py_Channel = PyObject_GC_New(PyNs3Channel, wrapper_type);
            py_Channel->inst_dict = NULL;
            py_Channel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Channel *> (ns3::PeekPointer (retval))->Ref();
            py_Channel->obj = const_cast<ns3::Channel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Channel->obj] = (PyObject *) py_Channel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Channel);
    return py_retval;
}


static PyObject*
_wrap_PyNs3LoopbackNetDevice__copy__(PyNs3LoopbackNetDevice *self)
{

    PyNs3LoopbackNetDevice *py_copy;
    py_copy = PyObject_GC_New(PyNs3LoopbackNetDevice, &PyNs3LoopbackNetDevice_Type);
    py_copy->obj = new ns3::LoopbackNetDevice(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3LoopbackNetDevice_methods[] = {
    {(char *) "GetMulticast", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_GetMulticast, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsPointToPoint", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_IsPointToPoint, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Send", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetIfIndex", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_GetIfIndex, METH_NOARGS, NULL },
    {(char *) "NeedsArp", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_NeedsArp, METH_NOARGS, NULL },
    {(char *) "SetPromiscReceiveCallback", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_SetPromiscReceiveCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNode", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_GetNode, METH_NOARGS, NULL },
    {(char *) "SendFrom", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_SendFrom, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsBroadcast", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_IsBroadcast, METH_NOARGS, NULL },
    {(char *) "GetMtu", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_GetMtu, METH_NOARGS, NULL },
    {(char *) "IsBridge", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_IsBridge, METH_NOARGS, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_GetAddress, METH_NOARGS, NULL },
    {(char *) "IsLinkUp", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_IsLinkUp, METH_NOARGS, NULL },
    {(char *) "SetIfIndex", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_SetIfIndex, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetAddress", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_SetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetBroadcast", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_GetBroadcast, METH_NOARGS, NULL },
    {(char *) "AddLinkChangeCallback", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_AddLinkChangeCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetReceiveCallback", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_SetReceiveCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsMulticast", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_IsMulticast, METH_NOARGS, NULL },
    {(char *) "SetMtu", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_SetMtu, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SupportsSendFrom", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_SupportsSendFrom, METH_NOARGS, NULL },
    {(char *) "GetChannel", (PyCFunction) _wrap_PyNs3LoopbackNetDevice_GetChannel, METH_NOARGS, NULL },
    {(char *) "NotifyConstructionCompleted", (PyCFunction) PyNs3LoopbackNetDevice__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "NotifyNewAggregate", (PyCFunction) PyNs3LoopbackNetDevice__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "DoStart", (PyCFunction) PyNs3LoopbackNetDevice__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "DoDispose", (PyCFunction) PyNs3LoopbackNetDevice__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3LoopbackNetDevice__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3LoopbackNetDevice__tp_clear(PyNs3LoopbackNetDevice *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::LoopbackNetDevice *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3LoopbackNetDevice__tp_traverse(PyNs3LoopbackNetDevice *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3LoopbackNetDevice__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3LoopbackNetDevice__tp_dealloc(PyNs3LoopbackNetDevice *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3LoopbackNetDevice__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3LoopbackNetDevice__tp_richcompare (PyNs3LoopbackNetDevice *PYBINDGEN_UNUSED(self), PyNs3LoopbackNetDevice *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3LoopbackNetDevice_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3LoopbackNetDevice_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.LoopbackNetDevice",            /* tp_name */
    sizeof(PyNs3LoopbackNetDevice),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3LoopbackNetDevice__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3LoopbackNetDevice__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3LoopbackNetDevice__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3LoopbackNetDevice__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3LoopbackNetDevice_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3LoopbackNetDevice, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3LoopbackNetDevice__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


/* --- containers --- */



static void
Pystd__vector__lt___unsigned_int___gt__Iter__tp_clear(Pystd__vector__lt___unsigned_int___gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__vector__lt___unsigned_int___gt__Iter__tp_traverse(Pystd__vector__lt___unsigned_int___gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__vector__lt___unsigned_int___gt____tp_dealloc(Pystd__vector__lt___unsigned_int___gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt___unsigned_int___gt__Iter__tp_dealloc(Pystd__vector__lt___unsigned_int___gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt___unsigned_int___gt____tp_iter(Pystd__vector__lt___unsigned_int___gt__ *self)
{
    Pystd__vector__lt___unsigned_int___gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt___unsigned_int___gt__Iter, &Pystd__vector__lt___unsigned_int___gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::vector< unsigned int >::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__vector__lt___unsigned_int___gt__Iter__tp_iter(Pystd__vector__lt___unsigned_int___gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__vector__lt___unsigned_int___gt__Iter__tp_iternext(Pystd__vector__lt___unsigned_int___gt__Iter *self)
{
    PyObject *py_retval;
    std::vector< unsigned int >::iterator iter;
    
    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong((*iter)));
    return py_retval;
}

int _wrap_convert_py2c__unsigned_int(PyObject *value, unsigned int *address)
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &*address)) {
        Py_DECREF(py_retval);
        return 0;
    }
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__std__vector__lt___unsigned_int___gt__(PyObject *arg, std::vector< unsigned int > *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__vector__lt___unsigned_int___gt___Type)) {
        *container = *((Pystd__vector__lt___unsigned_int___gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            unsigned int item;
            if (!_wrap_convert_py2c__unsigned_int(PyList_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Std__vector__lt___unsigned_int___gt__ instance, or a list of unsigned int");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__vector__lt___unsigned_int___gt____tp_init(Pystd__vector__lt___unsigned_int___gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::vector< unsigned int >;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__vector__lt___unsigned_int___gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__vector__lt___unsigned_int___gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Std__vector__lt___unsigned_int___gt__",            /* tp_name */
    sizeof(Pystd__vector__lt___unsigned_int___gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt___unsigned_int___gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt___unsigned_int___gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__vector__lt___unsigned_int___gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt___unsigned_int___gt__Iter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Std__vector__lt___unsigned_int___gt__Iter",            /* tp_name */
    sizeof(Pystd__vector__lt___unsigned_int___gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt___unsigned_int___gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__vector__lt___unsigned_int___gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__vector__lt___unsigned_int___gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt___unsigned_int___gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__vector__lt___unsigned_int___gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static void
Pystd__vector__lt___bool___gt__Iter__tp_clear(Pystd__vector__lt___bool___gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__vector__lt___bool___gt__Iter__tp_traverse(Pystd__vector__lt___bool___gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__vector__lt___bool___gt____tp_dealloc(Pystd__vector__lt___bool___gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt___bool___gt__Iter__tp_dealloc(Pystd__vector__lt___bool___gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt___bool___gt____tp_iter(Pystd__vector__lt___bool___gt__ *self)
{
    Pystd__vector__lt___bool___gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt___bool___gt__Iter, &Pystd__vector__lt___bool___gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::vector< bool >::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__vector__lt___bool___gt__Iter__tp_iter(Pystd__vector__lt___bool___gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__vector__lt___bool___gt__Iter__tp_iternext(Pystd__vector__lt___bool___gt__Iter *self)
{
    PyObject *py_retval;
    std::vector< bool >::iterator iter;
    
    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong((*iter)));
    return py_retval;
}

int _wrap_convert_py2c__bool(PyObject *value, bool *address)
{
    PyObject *py_retval;
    PyObject *py_boolretval;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__std__vector__lt___bool___gt__(PyObject *arg, std::vector< bool > *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__vector__lt___bool___gt___Type)) {
        *container = *((Pystd__vector__lt___bool___gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            bool item;
            if (!_wrap_convert_py2c__bool(PyList_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Std__vector__lt___bool___gt__ instance, or a list of bool");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__vector__lt___bool___gt____tp_init(Pystd__vector__lt___bool___gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::vector< bool >;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__vector__lt___bool___gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__vector__lt___bool___gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Std__vector__lt___bool___gt__",            /* tp_name */
    sizeof(Pystd__vector__lt___bool___gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt___bool___gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt___bool___gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__vector__lt___bool___gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt___bool___gt__Iter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Std__vector__lt___bool___gt__Iter",            /* tp_name */
    sizeof(Pystd__vector__lt___bool___gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt___bool___gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__vector__lt___bool___gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__vector__lt___bool___gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt___bool___gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__vector__lt___bool___gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static void
Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter__tp_clear(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter__tp_traverse(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt____tp_dealloc(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter__tp_dealloc(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt____tp_iter(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__ *self)
{
    Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter *iter = PyObject_GC_New(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter, &Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::list< ns3::Ptr< ns3::Packet > >::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter__tp_iter(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter__tp_iternext(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter *self)
{
    PyObject *py_retval;
    std::list< ns3::Ptr< ns3::Packet > >::iterator iter;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer ((*iter))))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer ((*iter))));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer ((*iter))))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer ((*iter)))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer ((*iter)));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}

int _wrap_convert_py2c__ns3__Ptr__lt___ns3__Packet___gt__(PyObject *value, ns3::Ptr< ns3::Packet > *address)
{
    PyObject *py_retval;
    PyNs3Packet *tmp_Packet;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Packet_Type, &tmp_Packet)) {
        Py_DECREF(py_retval);
        return 0;
    }
    // dangerous!
    *address = ns3::Ptr< ns3::Packet  > (tmp_Packet->obj);
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__(PyObject *arg, std::list< ns3::Ptr< ns3::Packet > > *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt___Type)) {
        *container = *((Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            ns3::Ptr< ns3::Packet > item;
            if (!_wrap_convert_py2c__ns3__Ptr__lt___ns3__Packet___gt__(PyList_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__ instance, or a list of ns3::Ptr< ns3::Packet >");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt____tp_init(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::list< ns3::Ptr< ns3::Packet > >;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__",            /* tp_name */
    sizeof(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter",            /* tp_name */
    sizeof(Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static void
Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter__tp_clear(Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter__tp_traverse(Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__map__lt___unsigned_int__unsigned_int___gt____tp_dealloc(Pystd__map__lt___unsigned_int__unsigned_int___gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter__tp_dealloc(Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__map__lt___unsigned_int__unsigned_int___gt____tp_iter(Pystd__map__lt___unsigned_int__unsigned_int___gt__ *self)
{
    Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter *iter = PyObject_GC_New(Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter, &Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::map< unsigned int, unsigned int >::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter__tp_iter(Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter__tp_iternext(Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter *self)
{
    PyObject *py_retval;
    std::map< unsigned int, unsigned int >::iterator iter;
    
    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    py_retval = Py_BuildValue((char *) "NN", PyLong_FromUnsignedLong(iter->first), PyLong_FromUnsignedLong(iter->second));
    return py_retval;
}

int _wrap_convert_py2c__std__map__lt___unsigned_int__unsigned_int___gt__(PyObject *arg, std::map< unsigned int, unsigned int > *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__map__lt___unsigned_int__unsigned_int___gt___Type)) {
        *container = *((Pystd__map__lt___unsigned_int__unsigned_int___gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            PyObject *tup = PyList_GET_ITEM(arg, i);
            if (!PyTuple_Check(tup) || PyTuple_Size(tup) != 2) {
                PyErr_SetString(PyExc_TypeError, "items must be tuples with two elements");
                return 0;
            }
            std::pair< unsigned int, unsigned int > item;
            if (!_wrap_convert_py2c__unsigned_int(PyTuple_GET_ITEM(tup, 0), &item.first)) {
                return 0;
            }
            if (!_wrap_convert_py2c__unsigned_int(PyTuple_GET_ITEM(tup, 1), &item.second)) {
                return 0;
            }
            container->insert(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Std__map__lt___unsigned_int__unsigned_int___gt__ instance, or a list of unsigned int");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__map__lt___unsigned_int__unsigned_int___gt____tp_init(Pystd__map__lt___unsigned_int__unsigned_int___gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::map< unsigned int, unsigned int >;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__map__lt___unsigned_int__unsigned_int___gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__map__lt___unsigned_int__unsigned_int___gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Std__map__lt___unsigned_int__unsigned_int___gt__",            /* tp_name */
    sizeof(Pystd__map__lt___unsigned_int__unsigned_int___gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__map__lt___unsigned_int__unsigned_int___gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__map__lt___unsigned_int__unsigned_int___gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__map__lt___unsigned_int__unsigned_int___gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Std__map__lt___unsigned_int__unsigned_int___gt__Iter",            /* tp_name */
    sizeof(Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static void
Pystd__vector__lt___ns3__Ipv6Address___gt__Iter__tp_clear(Pystd__vector__lt___ns3__Ipv6Address___gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__vector__lt___ns3__Ipv6Address___gt__Iter__tp_traverse(Pystd__vector__lt___ns3__Ipv6Address___gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__vector__lt___ns3__Ipv6Address___gt____tp_dealloc(Pystd__vector__lt___ns3__Ipv6Address___gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt___ns3__Ipv6Address___gt__Iter__tp_dealloc(Pystd__vector__lt___ns3__Ipv6Address___gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt___ns3__Ipv6Address___gt____tp_iter(Pystd__vector__lt___ns3__Ipv6Address___gt__ *self)
{
    Pystd__vector__lt___ns3__Ipv6Address___gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt___ns3__Ipv6Address___gt__Iter, &Pystd__vector__lt___ns3__Ipv6Address___gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::vector< ns3::Ipv6Address >::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__vector__lt___ns3__Ipv6Address___gt__Iter__tp_iter(Pystd__vector__lt___ns3__Ipv6Address___gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__vector__lt___ns3__Ipv6Address___gt__Iter__tp_iternext(Pystd__vector__lt___ns3__Ipv6Address___gt__Iter *self)
{
    PyObject *py_retval;
    std::vector< ns3::Ipv6Address >::iterator iter;
    PyNs3Ipv6Address *py_Ipv6Address;
    
    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address((*iter));
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = Py_BuildValue((char *) "N", py_Ipv6Address);
    return py_retval;
}

int _wrap_convert_py2c__ns3__Ipv6Address(PyObject *value, ns3::Ipv6Address *address)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *tmp_Ipv6Address;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Ipv6Address_Type, &tmp_Ipv6Address)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_Ipv6Address->obj;
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__std__vector__lt___ns3__Ipv6Address___gt__(PyObject *arg, std::vector< ns3::Ipv6Address > *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__vector__lt___ns3__Ipv6Address___gt___Type)) {
        *container = *((Pystd__vector__lt___ns3__Ipv6Address___gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            ns3::Ipv6Address item;
            if (!_wrap_convert_py2c__ns3__Ipv6Address(PyList_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Std__vector__lt___ns3__Ipv6Address___gt__ instance, or a list of ns3::Ipv6Address");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__vector__lt___ns3__Ipv6Address___gt____tp_init(Pystd__vector__lt___ns3__Ipv6Address___gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::vector< ns3::Ipv6Address >;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__vector__lt___ns3__Ipv6Address___gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__vector__lt___ns3__Ipv6Address___gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Std__vector__lt___ns3__Ipv6Address___gt__",            /* tp_name */
    sizeof(Pystd__vector__lt___ns3__Ipv6Address___gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt___ns3__Ipv6Address___gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt___ns3__Ipv6Address___gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__vector__lt___ns3__Ipv6Address___gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt___ns3__Ipv6Address___gt__Iter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "internet.Std__vector__lt___ns3__Ipv6Address___gt__Iter",            /* tp_name */
    sizeof(Pystd__vector__lt___ns3__Ipv6Address___gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt___ns3__Ipv6Address___gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__vector__lt___ns3__Ipv6Address___gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__vector__lt___ns3__Ipv6Address___gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt___ns3__Ipv6Address___gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__vector__lt___ns3__Ipv6Address___gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


/* --- enumerations --- */





















































































PyMODINIT_FUNC
#if defined(__GNUC__) && __GNUC__ >= 4
__attribute__ ((visibility("default")))
#endif
initinternet(void)
{
    PyObject *m;
    PyObject *submodule;
    m = Py_InitModule3((char *) "internet", internet_functions, NULL);
    if (m == NULL) {
        return;
    }
    PyModule_AddIntConstant(m, (char *) "STD_IOS_IN", std::ios::in);
    PyModule_AddIntConstant(m, (char *) "STD_IOS_OUT", std::ios::out);
    PyModule_AddIntConstant(m, (char *) "STD_IOS_ATE", std::ios::ate);
    PyModule_AddIntConstant(m, (char *) "STD_IOS_APP", std::ios::app);
    PyModule_AddIntConstant(m, (char *) "STD_IOS_TRUNC", std::ios::trunc);
    PyModule_AddIntConstant(m, (char *) "STD_IOS_BINARY", std::ios::binary);
    /* Import the 'ns3::Address' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Address_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Address");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3Address_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Address_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Address_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::AsciiTraceHelper' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3AsciiTraceHelper_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "AsciiTraceHelper");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3AsciiTraceHelper_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3AsciiTraceHelper_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3AsciiTraceHelper_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::AsciiTraceHelperForDevice' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3AsciiTraceHelperForDevice_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "AsciiTraceHelperForDevice");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3AsciiTraceHelperForDevice_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3AsciiTraceHelperForDevice_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3AsciiTraceHelperForDevice_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::AttributeConstructionList' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3AttributeConstructionList_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "AttributeConstructionList");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3AttributeConstructionList_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3AttributeConstructionList_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3AttributeConstructionList_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::AttributeConstructionList::Item' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3AttributeConstructionListItem_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Item");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3AttributeConstructionListItem_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3AttributeConstructionListItem_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3AttributeConstructionListItem_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Buffer' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Buffer_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Buffer");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3Buffer_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Buffer_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Buffer_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Buffer::Iterator' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3BufferIterator_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Iterator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3BufferIterator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3BufferIterator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3BufferIterator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ByteTagIterator' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3ByteTagIterator_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ByteTagIterator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3ByteTagIterator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ByteTagIterator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ByteTagIterator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ByteTagIterator::Item' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3ByteTagIteratorItem_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Item");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3ByteTagIteratorItem_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ByteTagIteratorItem_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ByteTagIteratorItem_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ByteTagList' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3ByteTagList_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ByteTagList");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3ByteTagList_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ByteTagList_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ByteTagList_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ByteTagList::Iterator' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3ByteTagListIterator_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Iterator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3ByteTagListIterator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ByteTagListIterator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ByteTagListIterator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ByteTagList::Iterator::Item' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3ByteTagListIteratorItem_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Item");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3ByteTagListIteratorItem_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ByteTagListIteratorItem_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ByteTagListIteratorItem_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::CallbackBase' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3CallbackBase_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "CallbackBase");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3CallbackBase_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3CallbackBase_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3CallbackBase_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::EventId' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3EventId_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "EventId");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3EventId_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3EventId_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3EventId_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::IntToType< 0 >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3IntToType__0_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "IntToType__0");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3IntToType__0_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3IntToType__0_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3IntToType__0_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::IntToType< 1 >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3IntToType__1_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "IntToType__1");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3IntToType__1_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3IntToType__1_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3IntToType__1_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::IntToType< 2 >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3IntToType__2_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "IntToType__2");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3IntToType__2_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3IntToType__2_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3IntToType__2_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::IntToType< 3 >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3IntToType__3_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "IntToType__3");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3IntToType__3_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3IntToType__3_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3IntToType__3_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::IntToType< 4 >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3IntToType__4_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "IntToType__4");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3IntToType__4_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3IntToType__4_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3IntToType__4_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::IntToType< 5 >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3IntToType__5_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "IntToType__5");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3IntToType__5_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3IntToType__5_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3IntToType__5_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::IntToType< 6 >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3IntToType__6_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "IntToType__6");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3IntToType__6_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3IntToType__6_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3IntToType__6_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Ipv4Address' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv4Address_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Ipv4Address");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3Ipv4Address_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Ipv4Address_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Ipv4Address_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Ipv4Mask' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv4Mask_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Ipv4Mask");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3Ipv4Mask_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Ipv4Mask_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Ipv4Mask_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Ipv6Address' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv6Address_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Ipv6Address");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3Ipv6Address_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Ipv6Address_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Ipv6Address_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Ipv6Prefix' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv6Prefix_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Ipv6Prefix");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3Ipv6Prefix_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Ipv6Prefix_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Ipv6Prefix_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Mac48Address' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Mac48Address_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Mac48Address");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3Mac48Address_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Mac48Address_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Mac48Address_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::NetDeviceContainer' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3NetDeviceContainer_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "NetDeviceContainer");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3NetDeviceContainer_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3NetDeviceContainer_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3NetDeviceContainer_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::NodeContainer' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3NodeContainer_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "NodeContainer");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3NodeContainer_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3NodeContainer_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3NodeContainer_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ObjectBase' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ObjectBase_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ObjectBase");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3ObjectBase_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ObjectBase_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ObjectBase_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ObjectDeleter' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ObjectDeleter_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ObjectDeleter");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3ObjectDeleter_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ObjectDeleter_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ObjectDeleter_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ObjectFactory' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ObjectFactory_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ObjectFactory");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3ObjectFactory_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ObjectFactory_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ObjectFactory_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketMetadata' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketMetadata_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "PacketMetadata");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3PacketMetadata_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketMetadata_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketMetadata_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketMetadata::Item' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketMetadataItem_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Item");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3PacketMetadataItem_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketMetadataItem_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketMetadataItem_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketMetadata::ItemIterator' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketMetadataItemIterator_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ItemIterator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3PacketMetadataItemIterator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketMetadataItemIterator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketMetadataItemIterator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketTagIterator' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketTagIterator_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "PacketTagIterator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3PacketTagIterator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketTagIterator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketTagIterator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketTagIterator::Item' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketTagIteratorItem_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Item");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3PacketTagIteratorItem_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketTagIteratorItem_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketTagIteratorItem_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketTagList' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketTagList_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "PacketTagList");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3PacketTagList_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketTagList_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketTagList_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketTagList::TagData' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketTagListTagData_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "TagData");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3PacketTagListTagData_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketTagListTagData_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketTagListTagData_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PcapFile' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PcapFile_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "PcapFile");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3PcapFile_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PcapFile_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PcapFile_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PcapHelper' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PcapHelper_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "PcapHelper");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3PcapHelper_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PcapHelper_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PcapHelper_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PcapHelperForDevice' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PcapHelperForDevice_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "PcapHelperForDevice");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3PcapHelperForDevice_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PcapHelperForDevice_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PcapHelperForDevice_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SequenceNumber32' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3SequenceNumber32_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SequenceNumber32");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3SequenceNumber32_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3SequenceNumber32_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3SequenceNumber32_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Simulator' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Simulator_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Simulator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3Simulator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Simulator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Simulator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Tag' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Tag_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Tag");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TagBuffer' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3TagBuffer_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "TagBuffer");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3TagBuffer_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3TagBuffer_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3TagBuffer_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Timer' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Timer_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Timer");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3Timer_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Timer_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Timer_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::TimerImpl' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TimerImpl_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "TimerImpl");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3TimerImpl_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3TimerImpl_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3TimerImpl_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::TypeId' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TypeId_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "TypeId");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3TypeId_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3TypeId_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3TypeId_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::TypeId::AttributeInformation' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TypeIdAttributeInformation_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "AttributeInformation");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3TypeIdAttributeInformation_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3TypeIdAttributeInformation_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3TypeIdAttributeInformation_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::TypeId::TraceSourceInformation' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TypeIdTraceSourceInformation_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "TraceSourceInformation");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3TypeIdTraceSourceInformation_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3TypeIdTraceSourceInformation_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3TypeIdTraceSourceInformation_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::empty' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Empty_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "empty");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3Empty_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Empty_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Empty_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::int64x64_t' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Int64x64_t_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "int64x64_t");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3Int64x64_t_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Int64x64_t_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Int64x64_t_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Chunk' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Chunk_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Chunk");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Header' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Header_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Header");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Object' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Object_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Object");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Object::AggregateIterator' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ObjectAggregateIterator_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "AggregateIterator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3ObjectAggregateIterator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ObjectAggregateIterator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ObjectAggregateIterator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PcapFileWrapper' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PcapFileWrapper_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "PcapFileWrapper");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::RandomVariableStream' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3RandomVariableStream_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "RandomVariableStream");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::SequentialRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SequentialRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SequentialRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter<ns3::OutputStreamWrapper> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter<ns3::OutputStreamWrapper> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Socket' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Socket_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Socket");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::SocketAddressTag' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3SocketAddressTag_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SocketAddressTag");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::SocketFactory' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3SocketFactory_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SocketFactory");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::SocketIpTtlTag' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3SocketIpTtlTag_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SocketIpTtlTag");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::SocketSetDontFragmentTag' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3SocketSetDontFragmentTag_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "SocketSetDontFragmentTag");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Time' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Time_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Time");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, (char*) "_PyNs3Time_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Time_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Time_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::TraceSourceAccessor' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TraceSourceAccessor_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "TraceSourceAccessor");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Trailer' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Trailer_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Trailer");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TriangularRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TriangularRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "TriangularRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::UniformRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3UniformRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "UniformRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::WeibullRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3WeibullRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "WeibullRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ZetaRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ZetaRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ZetaRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ZipfRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ZipfRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ZipfRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::AttributeAccessor' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3AttributeAccessor_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "AttributeAccessor");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::AttributeChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3AttributeChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "AttributeChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::AttributeValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3AttributeValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "AttributeValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::CallbackChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3CallbackChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "CallbackChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::CallbackImplBase' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3CallbackImplBase_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "CallbackImplBase");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::CallbackValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3CallbackValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "CallbackValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Channel' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Channel_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Channel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ConstantRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ConstantRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ConstantRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::DeterministicRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3DeterministicRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "DeterministicRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::EmpiricalRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3EmpiricalRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "EmpiricalRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::EmptyAttributeValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3EmptyAttributeValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "EmptyAttributeValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ErlangRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ErlangRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ErlangRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::EventImpl' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3EventImpl_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "EventImpl");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ExponentialRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ExponentialRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ExponentialRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::GammaRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3GammaRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "GammaRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv4AddressChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv4AddressChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Ipv4AddressChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv4AddressValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv4AddressValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Ipv4AddressValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv4MaskChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv4MaskChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Ipv4MaskChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv4MaskValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv4MaskValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Ipv4MaskValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv6AddressChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv6AddressChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Ipv6AddressChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv6AddressValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv6AddressValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Ipv6AddressValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv6PrefixChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv6PrefixChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Ipv6PrefixChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv6PrefixValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv6PrefixValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Ipv6PrefixValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::LogNormalRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3LogNormalRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "LogNormalRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Mac48AddressChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Mac48AddressChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Mac48AddressChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Mac48AddressValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Mac48AddressValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Mac48AddressValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::NetDevice' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3NetDevice_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "NetDevice");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::NixVector' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3NixVector_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "NixVector");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Node' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Node_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Node");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::NormalRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3NormalRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "NormalRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ObjectFactoryChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ObjectFactoryChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ObjectFactoryChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ObjectFactoryValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ObjectFactoryValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ObjectFactoryValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::OutputStreamWrapper' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3OutputStreamWrapper_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "OutputStreamWrapper");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Packet' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Packet_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "Packet");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ParetoRandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ParetoRandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "ParetoRandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TimeChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TimeChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "TimeChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TimeValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TimeValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "TimeValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TypeIdChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TypeIdChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "TypeIdChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TypeIdValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TypeIdValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "TypeIdValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::AddressChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3AddressChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "AddressChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::AddressValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3AddressValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "AddressValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::BridgeChannel' class from module 'ns.bridge' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.bridge");
        if (module == NULL) {
            return ;
        }
        _PyNs3BridgeChannel_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "BridgeChannel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::BridgeNetDevice' class from module 'ns.bridge' */
    {
        PyObject *module = PyImport_ImportModule((char*) "ns.bridge");
        if (module == NULL) {
            return ;
        }
        _PyNs3BridgeNetDevice_Type = (PyTypeObject*) PyObject_GetAttrString(module, (char*) "BridgeNetDevice");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    PyModule_AddObject(m, (char *) "_PyNs3AsciiTraceHelperForIpv4_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3AsciiTraceHelperForIpv4_wrapper_registry, NULL));
    /* Register the 'ns3::AsciiTraceHelperForIpv4' class */
    if (PyType_Ready(&PyNs3AsciiTraceHelperForIpv4_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "AsciiTraceHelperForIpv4", (PyObject *) &PyNs3AsciiTraceHelperForIpv4_Type);
    PyModule_AddObject(m, (char *) "_PyNs3AsciiTraceHelperForIpv6_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3AsciiTraceHelperForIpv6_wrapper_registry, NULL));
    /* Register the 'ns3::AsciiTraceHelperForIpv6' class */
    if (PyType_Ready(&PyNs3AsciiTraceHelperForIpv6_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "AsciiTraceHelperForIpv6", (PyObject *) &PyNs3AsciiTraceHelperForIpv6_Type);
    PyModule_AddObject(m, (char *) "_PyNs3CandidateQueue_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3CandidateQueue_wrapper_registry, NULL));
    /* Register the 'ns3::CandidateQueue' class */
    if (PyType_Ready(&PyNs3CandidateQueue_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "CandidateQueue", (PyObject *) &PyNs3CandidateQueue_Type);
    PyModule_AddObject(m, (char *) "_PyNs3GlobalRouteManager_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3GlobalRouteManager_wrapper_registry, NULL));
    /* Register the 'ns3::GlobalRouteManager' class */
    if (PyType_Ready(&PyNs3GlobalRouteManager_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "GlobalRouteManager", (PyObject *) &PyNs3GlobalRouteManager_Type);
    PyModule_AddObject(m, (char *) "_PyNs3GlobalRouteManagerImpl_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3GlobalRouteManagerImpl_wrapper_registry, NULL));
    /* Register the 'ns3::GlobalRouteManagerImpl' class */
    if (PyType_Ready(&PyNs3GlobalRouteManagerImpl_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "GlobalRouteManagerImpl", (PyObject *) &PyNs3GlobalRouteManagerImpl_Type);
    PyModule_AddObject(m, (char *) "_PyNs3GlobalRouteManagerLSDB_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3GlobalRouteManagerLSDB_wrapper_registry, NULL));
    /* Register the 'ns3::GlobalRouteManagerLSDB' class */
    if (PyType_Ready(&PyNs3GlobalRouteManagerLSDB_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "GlobalRouteManagerLSDB", (PyObject *) &PyNs3GlobalRouteManagerLSDB_Type);
    PyModule_AddObject(m, (char *) "_PyNs3GlobalRoutingLSA_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3GlobalRoutingLSA_wrapper_registry, NULL));
    /* Register the 'ns3::GlobalRoutingLSA' class */
    if (PyType_Ready(&PyNs3GlobalRoutingLSA_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "GlobalRoutingLSA", (PyObject *) &PyNs3GlobalRoutingLSA_Type);
    PyModule_AddObject(m, (char *) "_PyNs3GlobalRoutingLinkRecord_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3GlobalRoutingLinkRecord_wrapper_registry, NULL));
    /* Register the 'ns3::GlobalRoutingLinkRecord' class */
    if (PyType_Ready(&PyNs3GlobalRoutingLinkRecord_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "GlobalRoutingLinkRecord", (PyObject *) &PyNs3GlobalRoutingLinkRecord_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv4AddressGenerator_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv4AddressGenerator_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv4AddressGenerator' class */
    if (PyType_Ready(&PyNs3Ipv4AddressGenerator_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4AddressGenerator", (PyObject *) &PyNs3Ipv4AddressGenerator_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv4AddressHelper_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv4AddressHelper_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv4AddressHelper' class */
    if (PyType_Ready(&PyNs3Ipv4AddressHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4AddressHelper", (PyObject *) &PyNs3Ipv4AddressHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv4EndPoint_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv4EndPoint_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv4EndPoint' class */
    if (PyType_Ready(&PyNs3Ipv4EndPoint_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4EndPoint", (PyObject *) &PyNs3Ipv4EndPoint_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv4InterfaceAddress_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv4InterfaceAddress_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv4InterfaceAddress' class */
    if (PyType_Ready(&PyNs3Ipv4InterfaceAddress_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4InterfaceAddress", (PyObject *) &PyNs3Ipv4InterfaceAddress_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv4InterfaceContainer_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv4InterfaceContainer_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv4InterfaceContainer' class */
    if (PyType_Ready(&PyNs3Ipv4InterfaceContainer_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4InterfaceContainer", (PyObject *) &PyNs3Ipv4InterfaceContainer_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv4MulticastRoutingTableEntry_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv4MulticastRoutingTableEntry_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv4MulticastRoutingTableEntry' class */
    if (PyType_Ready(&PyNs3Ipv4MulticastRoutingTableEntry_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4MulticastRoutingTableEntry", (PyObject *) &PyNs3Ipv4MulticastRoutingTableEntry_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv4RoutingHelper_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv4RoutingHelper_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv4RoutingHelper' class */
    if (PyType_Ready(&PyNs3Ipv4RoutingHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4RoutingHelper", (PyObject *) &PyNs3Ipv4RoutingHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv4RoutingTableEntry_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv4RoutingTableEntry_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv4RoutingTableEntry' class */
    if (PyType_Ready(&PyNs3Ipv4RoutingTableEntry_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4RoutingTableEntry", (PyObject *) &PyNs3Ipv4RoutingTableEntry_Type);
    /* Register the 'ns3::Ipv4StaticRoutingHelper' class */
    PyNs3Ipv4StaticRoutingHelper_Type.tp_base = &PyNs3Ipv4RoutingHelper_Type;
    if (PyType_Ready(&PyNs3Ipv4StaticRoutingHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4StaticRoutingHelper", (PyObject *) &PyNs3Ipv4StaticRoutingHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv6AddressGenerator_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv6AddressGenerator_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv6AddressGenerator' class */
    if (PyType_Ready(&PyNs3Ipv6AddressGenerator_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6AddressGenerator", (PyObject *) &PyNs3Ipv6AddressGenerator_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv6AddressHelper_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv6AddressHelper_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv6AddressHelper' class */
    if (PyType_Ready(&PyNs3Ipv6AddressHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6AddressHelper", (PyObject *) &PyNs3Ipv6AddressHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv6InterfaceAddress_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv6InterfaceAddress_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv6InterfaceAddress' class */
    if (PyType_Ready(&PyNs3Ipv6InterfaceAddress_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6InterfaceAddress", (PyObject *) &PyNs3Ipv6InterfaceAddress_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv6InterfaceContainer_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv6InterfaceContainer_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv6InterfaceContainer' class */
    if (PyType_Ready(&PyNs3Ipv6InterfaceContainer_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6InterfaceContainer", (PyObject *) &PyNs3Ipv6InterfaceContainer_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv6MulticastRoutingTableEntry_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv6MulticastRoutingTableEntry_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv6MulticastRoutingTableEntry' class */
    if (PyType_Ready(&PyNs3Ipv6MulticastRoutingTableEntry_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6MulticastRoutingTableEntry", (PyObject *) &PyNs3Ipv6MulticastRoutingTableEntry_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv6RoutingHelper_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv6RoutingHelper_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv6RoutingHelper' class */
    if (PyType_Ready(&PyNs3Ipv6RoutingHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6RoutingHelper", (PyObject *) &PyNs3Ipv6RoutingHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv6RoutingTableEntry_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv6RoutingTableEntry_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv6RoutingTableEntry' class */
    if (PyType_Ready(&PyNs3Ipv6RoutingTableEntry_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6RoutingTableEntry", (PyObject *) &PyNs3Ipv6RoutingTableEntry_Type);
    /* Register the 'ns3::Ipv6StaticRoutingHelper' class */
    PyNs3Ipv6StaticRoutingHelper_Type.tp_base = &PyNs3Ipv6RoutingHelper_Type;
    if (PyType_Ready(&PyNs3Ipv6StaticRoutingHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6StaticRoutingHelper", (PyObject *) &PyNs3Ipv6StaticRoutingHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3OptionField_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3OptionField_wrapper_registry, NULL));
    /* Register the 'ns3::OptionField' class */
    if (PyType_Ready(&PyNs3OptionField_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "OptionField", (PyObject *) &PyNs3OptionField_Type);
    PyModule_AddObject(m, (char *) "_PyNs3PcapHelperForIpv4_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3PcapHelperForIpv4_wrapper_registry, NULL));
    /* Register the 'ns3::PcapHelperForIpv4' class */
    if (PyType_Ready(&PyNs3PcapHelperForIpv4_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "PcapHelperForIpv4", (PyObject *) &PyNs3PcapHelperForIpv4_Type);
    PyModule_AddObject(m, (char *) "_PyNs3PcapHelperForIpv6_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3PcapHelperForIpv6_wrapper_registry, NULL));
    /* Register the 'ns3::PcapHelperForIpv6' class */
    if (PyType_Ready(&PyNs3PcapHelperForIpv6_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "PcapHelperForIpv6", (PyObject *) &PyNs3PcapHelperForIpv6_Type);
    PyModule_AddObject(m, (char *) "_PyNs3SPFVertex_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3SPFVertex_wrapper_registry, NULL));
    /* Register the 'ns3::SPFVertex' class */
    if (PyType_Ready(&PyNs3SPFVertex_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SPFVertex", (PyObject *) &PyNs3SPFVertex_Type);
    /* Register the 'ns3::Icmpv4DestinationUnreachable' class */
    PyNs3Icmpv4DestinationUnreachable_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3Icmpv4DestinationUnreachable_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv4DestinationUnreachable", (PyObject *) &PyNs3Icmpv4DestinationUnreachable_Type);
    /* Register the 'ns3::Icmpv4Echo' class */
    PyNs3Icmpv4Echo_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3Icmpv4Echo_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv4Echo", (PyObject *) &PyNs3Icmpv4Echo_Type);
    /* Register the 'ns3::Icmpv4Header' class */
    PyNs3Icmpv4Header_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3Icmpv4Header_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv4Header", (PyObject *) &PyNs3Icmpv4Header_Type);
    /* Register the 'ns3::Icmpv4TimeExceeded' class */
    PyNs3Icmpv4TimeExceeded_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3Icmpv4TimeExceeded_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv4TimeExceeded", (PyObject *) &PyNs3Icmpv4TimeExceeded_Type);
    /* Register the 'ns3::Icmpv6Header' class */
    PyNs3Icmpv6Header_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3Icmpv6Header_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6Header", (PyObject *) &PyNs3Icmpv6Header_Type);
    /* Register the 'ns3::Icmpv6NA' class */
    PyNs3Icmpv6NA_Type.tp_base = &PyNs3Icmpv6Header_Type;
    if (PyType_Ready(&PyNs3Icmpv6NA_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6NA", (PyObject *) &PyNs3Icmpv6NA_Type);
    /* Register the 'ns3::Icmpv6NS' class */
    PyNs3Icmpv6NS_Type.tp_base = &PyNs3Icmpv6Header_Type;
    if (PyType_Ready(&PyNs3Icmpv6NS_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6NS", (PyObject *) &PyNs3Icmpv6NS_Type);
    /* Register the 'ns3::Icmpv6OptionHeader' class */
    PyNs3Icmpv6OptionHeader_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3Icmpv6OptionHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6OptionHeader", (PyObject *) &PyNs3Icmpv6OptionHeader_Type);
    /* Register the 'ns3::Icmpv6OptionLinkLayerAddress' class */
    PyNs3Icmpv6OptionLinkLayerAddress_Type.tp_base = &PyNs3Icmpv6OptionHeader_Type;
    if (PyType_Ready(&PyNs3Icmpv6OptionLinkLayerAddress_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6OptionLinkLayerAddress", (PyObject *) &PyNs3Icmpv6OptionLinkLayerAddress_Type);
    /* Register the 'ns3::Icmpv6OptionMtu' class */
    PyNs3Icmpv6OptionMtu_Type.tp_base = &PyNs3Icmpv6OptionHeader_Type;
    if (PyType_Ready(&PyNs3Icmpv6OptionMtu_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6OptionMtu", (PyObject *) &PyNs3Icmpv6OptionMtu_Type);
    /* Register the 'ns3::Icmpv6OptionPrefixInformation' class */
    PyNs3Icmpv6OptionPrefixInformation_Type.tp_base = &PyNs3Icmpv6OptionHeader_Type;
    if (PyType_Ready(&PyNs3Icmpv6OptionPrefixInformation_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6OptionPrefixInformation", (PyObject *) &PyNs3Icmpv6OptionPrefixInformation_Type);
    /* Register the 'ns3::Icmpv6OptionRedirected' class */
    PyNs3Icmpv6OptionRedirected_Type.tp_base = &PyNs3Icmpv6OptionHeader_Type;
    if (PyType_Ready(&PyNs3Icmpv6OptionRedirected_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6OptionRedirected", (PyObject *) &PyNs3Icmpv6OptionRedirected_Type);
    /* Register the 'ns3::Icmpv6ParameterError' class */
    PyNs3Icmpv6ParameterError_Type.tp_base = &PyNs3Icmpv6Header_Type;
    if (PyType_Ready(&PyNs3Icmpv6ParameterError_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6ParameterError", (PyObject *) &PyNs3Icmpv6ParameterError_Type);
    /* Register the 'ns3::Icmpv6RA' class */
    PyNs3Icmpv6RA_Type.tp_base = &PyNs3Icmpv6Header_Type;
    if (PyType_Ready(&PyNs3Icmpv6RA_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6RA", (PyObject *) &PyNs3Icmpv6RA_Type);
    /* Register the 'ns3::Icmpv6RS' class */
    PyNs3Icmpv6RS_Type.tp_base = &PyNs3Icmpv6Header_Type;
    if (PyType_Ready(&PyNs3Icmpv6RS_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6RS", (PyObject *) &PyNs3Icmpv6RS_Type);
    /* Register the 'ns3::Icmpv6Redirection' class */
    PyNs3Icmpv6Redirection_Type.tp_base = &PyNs3Icmpv6Header_Type;
    if (PyType_Ready(&PyNs3Icmpv6Redirection_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6Redirection", (PyObject *) &PyNs3Icmpv6Redirection_Type);
    /* Register the 'ns3::Icmpv6TimeExceeded' class */
    PyNs3Icmpv6TimeExceeded_Type.tp_base = &PyNs3Icmpv6Header_Type;
    if (PyType_Ready(&PyNs3Icmpv6TimeExceeded_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6TimeExceeded", (PyObject *) &PyNs3Icmpv6TimeExceeded_Type);
    /* Register the 'ns3::Icmpv6TooBig' class */
    PyNs3Icmpv6TooBig_Type.tp_base = &PyNs3Icmpv6Header_Type;
    if (PyType_Ready(&PyNs3Icmpv6TooBig_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6TooBig", (PyObject *) &PyNs3Icmpv6TooBig_Type);
    /* Register the 'ns3::InternetStackHelper' class */
    PyNs3InternetStackHelper_Type.tp_base = &PyNs3PcapHelperForIpv4_Type;
    PyNs3InternetStackHelper_Type.tp_bases = PyTuple_New(4);
        Py_INCREF((PyObject *) &PyNs3PcapHelperForIpv4_Type);
        PyTuple_SET_ITEM(PyNs3InternetStackHelper_Type.tp_bases, 0, (PyObject *) &PyNs3PcapHelperForIpv4_Type);
        Py_INCREF((PyObject *) &PyNs3PcapHelperForIpv6_Type);
        PyTuple_SET_ITEM(PyNs3InternetStackHelper_Type.tp_bases, 1, (PyObject *) &PyNs3PcapHelperForIpv6_Type);
        Py_INCREF((PyObject *) &PyNs3AsciiTraceHelperForIpv4_Type);
        PyTuple_SET_ITEM(PyNs3InternetStackHelper_Type.tp_bases, 2, (PyObject *) &PyNs3AsciiTraceHelperForIpv4_Type);
        Py_INCREF((PyObject *) &PyNs3AsciiTraceHelperForIpv6_Type);
        PyTuple_SET_ITEM(PyNs3InternetStackHelper_Type.tp_bases, 3, (PyObject *) &PyNs3AsciiTraceHelperForIpv6_Type);
    if (PyType_Ready(&PyNs3InternetStackHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "InternetStackHelper", (PyObject *) &PyNs3InternetStackHelper_Type);
    /* Register the 'ns3::Ipv4GlobalRoutingHelper' class */
    PyNs3Ipv4GlobalRoutingHelper_Type.tp_base = &PyNs3Ipv4RoutingHelper_Type;
    if (PyType_Ready(&PyNs3Ipv4GlobalRoutingHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4GlobalRoutingHelper", (PyObject *) &PyNs3Ipv4GlobalRoutingHelper_Type);
    /* Register the 'ns3::Ipv4Header' class */
    PyNs3Ipv4Header_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3Ipv4Header_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4Header", (PyObject *) &PyNs3Ipv4Header_Type);
    /* Register the 'ns3::Ipv4ListRoutingHelper' class */
    PyNs3Ipv4ListRoutingHelper_Type.tp_base = &PyNs3Ipv4RoutingHelper_Type;
    if (PyType_Ready(&PyNs3Ipv4ListRoutingHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4ListRoutingHelper", (PyObject *) &PyNs3Ipv4ListRoutingHelper_Type);
    /* Register the 'ns3::Ipv4PacketInfoTag' class */
    PyNs3Ipv4PacketInfoTag_Type.tp_base = &PyNs3Tag_Type;
    if (PyType_Ready(&PyNs3Ipv4PacketInfoTag_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4PacketInfoTag", (PyObject *) &PyNs3Ipv4PacketInfoTag_Type);
    /* Register the 'ns3::Ipv6ExtensionHeader' class */
    PyNs3Ipv6ExtensionHeader_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionHeader", (PyObject *) &PyNs3Ipv6ExtensionHeader_Type);
    /* Register the 'ns3::Ipv6ExtensionHopByHopHeader' class */
    PyNs3Ipv6ExtensionHopByHopHeader_Type.tp_base = &PyNs3Ipv6ExtensionHeader_Type;
    PyNs3Ipv6ExtensionHopByHopHeader_Type.tp_bases = PyTuple_New(2);
        Py_INCREF((PyObject *) &PyNs3Ipv6ExtensionHeader_Type);
        PyTuple_SET_ITEM(PyNs3Ipv6ExtensionHopByHopHeader_Type.tp_bases, 0, (PyObject *) &PyNs3Ipv6ExtensionHeader_Type);
        Py_INCREF((PyObject *) &PyNs3OptionField_Type);
        PyTuple_SET_ITEM(PyNs3Ipv6ExtensionHopByHopHeader_Type.tp_bases, 1, (PyObject *) &PyNs3OptionField_Type);
    if (PyType_Ready(&PyNs3Ipv6ExtensionHopByHopHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionHopByHopHeader", (PyObject *) &PyNs3Ipv6ExtensionHopByHopHeader_Type);
    /* Register the 'ns3::Ipv6ExtensionRoutingHeader' class */
    PyNs3Ipv6ExtensionRoutingHeader_Type.tp_base = &PyNs3Ipv6ExtensionHeader_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionRoutingHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionRoutingHeader", (PyObject *) &PyNs3Ipv6ExtensionRoutingHeader_Type);
    /* Register the 'ns3::Ipv6Header' class */
    PyNs3Ipv6Header_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3Ipv6Header_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6Header", (PyObject *) &PyNs3Ipv6Header_Type);
    /* Register the 'ns3::Ipv6ListRoutingHelper' class */
    PyNs3Ipv6ListRoutingHelper_Type.tp_base = &PyNs3Ipv6RoutingHelper_Type;
    if (PyType_Ready(&PyNs3Ipv6ListRoutingHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ListRoutingHelper", (PyObject *) &PyNs3Ipv6ListRoutingHelper_Type);
    /* Register the 'ns3::Ipv6OptionHeader' class */
    PyNs3Ipv6OptionHeader_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3Ipv6OptionHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6OptionHeader", (PyObject *) &PyNs3Ipv6OptionHeader_Type);
    PyModule_AddObject(m, (char *) "_PyNs3Ipv6OptionHeaderAlignment_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3Ipv6OptionHeaderAlignment_wrapper_registry, NULL));
    /* Register the 'ns3::Ipv6OptionHeader::Alignment' class */
    if (PyType_Ready(&PyNs3Ipv6OptionHeaderAlignment_Type)) {
        return;
    }
    PyDict_SetItemString((PyObject*) PyNs3Ipv6OptionHeader_Type.tp_dict, (char *) "Alignment", (PyObject *) &PyNs3Ipv6OptionHeaderAlignment_Type);
    /* Register the 'ns3::Ipv6OptionJumbogramHeader' class */
    PyNs3Ipv6OptionJumbogramHeader_Type.tp_base = &PyNs3Ipv6OptionHeader_Type;
    if (PyType_Ready(&PyNs3Ipv6OptionJumbogramHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6OptionJumbogramHeader", (PyObject *) &PyNs3Ipv6OptionJumbogramHeader_Type);
    /* Register the 'ns3::Ipv6OptionPad1Header' class */
    PyNs3Ipv6OptionPad1Header_Type.tp_base = &PyNs3Ipv6OptionHeader_Type;
    if (PyType_Ready(&PyNs3Ipv6OptionPad1Header_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6OptionPad1Header", (PyObject *) &PyNs3Ipv6OptionPad1Header_Type);
    /* Register the 'ns3::Ipv6OptionPadnHeader' class */
    PyNs3Ipv6OptionPadnHeader_Type.tp_base = &PyNs3Ipv6OptionHeader_Type;
    if (PyType_Ready(&PyNs3Ipv6OptionPadnHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6OptionPadnHeader", (PyObject *) &PyNs3Ipv6OptionPadnHeader_Type);
    /* Register the 'ns3::Ipv6OptionRouterAlertHeader' class */
    PyNs3Ipv6OptionRouterAlertHeader_Type.tp_base = &PyNs3Ipv6OptionHeader_Type;
    if (PyType_Ready(&PyNs3Ipv6OptionRouterAlertHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6OptionRouterAlertHeader", (PyObject *) &PyNs3Ipv6OptionRouterAlertHeader_Type);
    /* Register the 'ns3::Ipv6PacketInfoTag' class */
    PyNs3Ipv6PacketInfoTag_Type.tp_base = &PyNs3Tag_Type;
    if (PyType_Ready(&PyNs3Ipv6PacketInfoTag_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6PacketInfoTag", (PyObject *) &PyNs3Ipv6PacketInfoTag_Type);
    PyModule_AddObject(m, (char *) "_PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____typeid_map", PyCObject_FromVoidPtr(&PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____typeid_map, NULL));
    PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____typeid_map.register_wrapper(typeid(ns3::SimpleRefCount< ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> >), &PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type);
    /* Register the 'ns3::SimpleRefCount< ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> >' class */
    PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type.tp_base = &PyNs3Empty_Type;
    if (PyType_Ready(&PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt__", (PyObject *) &PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type);
    PyModule_AddObject(m, (char *) "_PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map", PyCObject_FromVoidPtr(&PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map, NULL));
    PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map.register_wrapper(typeid(ns3::SimpleRefCount< ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> >), &PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___Type);
    /* Register the 'ns3::SimpleRefCount< ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> >' class */
    PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___Type.tp_base = &PyNs3Empty_Type;
    if (PyType_Ready(&PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt__", (PyObject *) &PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___Type);
    PyModule_AddObject(m, (char *) "_PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____typeid_map", PyCObject_FromVoidPtr(&PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____typeid_map, NULL));
    PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____typeid_map.register_wrapper(typeid(ns3::SimpleRefCount< ns3::Ipv6MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6MulticastRoute> >), &PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type);
    /* Register the 'ns3::SimpleRefCount< ns3::Ipv6MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6MulticastRoute> >' class */
    PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type.tp_base = &PyNs3Empty_Type;
    if (PyType_Ready(&PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt__", (PyObject *) &PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type);
    PyModule_AddObject(m, (char *) "_PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____typeid_map", PyCObject_FromVoidPtr(&PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____typeid_map, NULL));
    PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____typeid_map.register_wrapper(typeid(ns3::SimpleRefCount< ns3::Ipv6Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6Route> >), &PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___Type);
    /* Register the 'ns3::SimpleRefCount< ns3::Ipv6Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv6Route> >' class */
    PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___Type.tp_base = &PyNs3Empty_Type;
    if (PyType_Ready(&PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt__", (PyObject *) &PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___Type);
    /* Register the 'ns3::TcpHeader' class */
    PyNs3TcpHeader_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3TcpHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "TcpHeader", (PyObject *) &PyNs3TcpHeader_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::TcpSocket), &PyNs3TcpSocket_Type);
    /* Register the 'ns3::TcpSocket' class */
    PyNs3TcpSocket_Type.tp_base = &PyNs3Socket_Type;
    if (PyType_Ready(&PyNs3TcpSocket_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "TcpSocket", (PyObject *) &PyNs3TcpSocket_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::TcpSocketFactory), &PyNs3TcpSocketFactory_Type);
    /* Register the 'ns3::TcpSocketFactory' class */
    PyNs3TcpSocketFactory_Type.tp_base = &PyNs3SocketFactory_Type;
    if (PyType_Ready(&PyNs3TcpSocketFactory_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "TcpSocketFactory", (PyObject *) &PyNs3TcpSocketFactory_Type);
    /* Register the 'ns3::UdpHeader' class */
    PyNs3UdpHeader_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3UdpHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "UdpHeader", (PyObject *) &PyNs3UdpHeader_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::UdpSocket), &PyNs3UdpSocket_Type);
    /* Register the 'ns3::UdpSocket' class */
    PyNs3UdpSocket_Type.tp_base = &PyNs3Socket_Type;
    if (PyType_Ready(&PyNs3UdpSocket_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "UdpSocket", (PyObject *) &PyNs3UdpSocket_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::UdpSocketFactory), &PyNs3UdpSocketFactory_Type);
    /* Register the 'ns3::UdpSocketFactory' class */
    PyNs3UdpSocketFactory_Type.tp_base = &PyNs3SocketFactory_Type;
    if (PyType_Ready(&PyNs3UdpSocketFactory_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "UdpSocketFactory", (PyObject *) &PyNs3UdpSocketFactory_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::ArpCache), &PyNs3ArpCache_Type);
    /* Register the 'ns3::ArpCache' class */
    PyNs3ArpCache_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3ArpCache_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "ArpCache", (PyObject *) &PyNs3ArpCache_Type);
    PyModule_AddObject(m, (char *) "_PyNs3ArpCacheEntry_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3ArpCacheEntry_wrapper_registry, NULL));
    /* Register the 'ns3::ArpCache::Entry' class */
    if (PyType_Ready(&PyNs3ArpCacheEntry_Type)) {
        return;
    }
    PyDict_SetItemString((PyObject*) PyNs3ArpCache_Type.tp_dict, (char *) "Entry", (PyObject *) &PyNs3ArpCacheEntry_Type);
    /* Register the 'ns3::ArpHeader' class */
    PyNs3ArpHeader_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3ArpHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "ArpHeader", (PyObject *) &PyNs3ArpHeader_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::ArpL3Protocol), &PyNs3ArpL3Protocol_Type);
    /* Register the 'ns3::ArpL3Protocol' class */
    
    PyNs3ArpL3ProtocolMeta_Type.tp_base = PyNs3Object_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3ArpL3ProtocolMeta_Type.tp_traverse = PyNs3Object_Type.ob_type->tp_traverse;
    PyNs3ArpL3ProtocolMeta_Type.tp_clear = PyNs3Object_Type.ob_type->tp_clear;
    PyNs3ArpL3ProtocolMeta_Type.tp_is_gc = PyNs3Object_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3ArpL3ProtocolMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3ArpL3ProtocolMeta_Type);
    
    PyNs3ArpL3Protocol_Type.tp_base = &PyNs3Object_Type;
    PyNs3ArpL3Protocol_Type.ob_type = &PyNs3ArpL3ProtocolMeta_Type;
    if (PyType_Ready(&PyNs3ArpL3Protocol_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "ArpL3Protocol", (PyObject *) &PyNs3ArpL3Protocol_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::GlobalRouter), &PyNs3GlobalRouter_Type);
    /* Register the 'ns3::GlobalRouter' class */
    PyNs3GlobalRouter_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3GlobalRouter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "GlobalRouter", (PyObject *) &PyNs3GlobalRouter_Type);
    /* Register the 'ns3::Icmpv6DestinationUnreachable' class */
    PyNs3Icmpv6DestinationUnreachable_Type.tp_base = &PyNs3Icmpv6Header_Type;
    if (PyType_Ready(&PyNs3Icmpv6DestinationUnreachable_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6DestinationUnreachable", (PyObject *) &PyNs3Icmpv6DestinationUnreachable_Type);
    /* Register the 'ns3::Icmpv6Echo' class */
    PyNs3Icmpv6Echo_Type.tp_base = &PyNs3Icmpv6Header_Type;
    if (PyType_Ready(&PyNs3Icmpv6Echo_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6Echo", (PyObject *) &PyNs3Icmpv6Echo_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::IpL4Protocol), &PyNs3IpL4Protocol_Type);
    /* Register the 'ns3::IpL4Protocol' class */
    PyNs3IpL4Protocol_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3IpL4Protocol_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "IpL4Protocol", (PyObject *) &PyNs3IpL4Protocol_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv4), &PyNs3Ipv4_Type);
    /* Register the 'ns3::Ipv4' class */
    
    PyNs3Ipv4Meta_Type.tp_base = PyNs3Object_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv4Meta_Type.tp_traverse = PyNs3Object_Type.ob_type->tp_traverse;
    PyNs3Ipv4Meta_Type.tp_clear = PyNs3Object_Type.ob_type->tp_clear;
    PyNs3Ipv4Meta_Type.tp_is_gc = PyNs3Object_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv4Meta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv4Meta_Type);
    
    PyNs3Ipv4_Type.tp_base = &PyNs3Object_Type;
    PyNs3Ipv4_Type.ob_type = &PyNs3Ipv4Meta_Type;
    if (PyType_Ready(&PyNs3Ipv4_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4", (PyObject *) &PyNs3Ipv4_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv4Interface), &PyNs3Ipv4Interface_Type);
    /* Register the 'ns3::Ipv4Interface' class */
    PyNs3Ipv4Interface_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3Ipv4Interface_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4Interface", (PyObject *) &PyNs3Ipv4Interface_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv4L3Protocol), &PyNs3Ipv4L3Protocol_Type);
    /* Register the 'ns3::Ipv4L3Protocol' class */
    
    PyNs3Ipv4L3ProtocolMeta_Type.tp_base = PyNs3Ipv4_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv4L3ProtocolMeta_Type.tp_traverse = PyNs3Ipv4_Type.ob_type->tp_traverse;
    PyNs3Ipv4L3ProtocolMeta_Type.tp_clear = PyNs3Ipv4_Type.ob_type->tp_clear;
    PyNs3Ipv4L3ProtocolMeta_Type.tp_is_gc = PyNs3Ipv4_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv4L3ProtocolMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv4L3ProtocolMeta_Type);
    
    PyNs3Ipv4L3Protocol_Type.tp_base = &PyNs3Ipv4_Type;
    PyNs3Ipv4L3Protocol_Type.ob_type = &PyNs3Ipv4L3ProtocolMeta_Type;
    if (PyType_Ready(&PyNs3Ipv4L3Protocol_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4L3Protocol", (PyObject *) &PyNs3Ipv4L3Protocol_Type);
    PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt____typeid_map.register_wrapper(typeid(ns3::Ipv4MulticastRoute), &PyNs3Ipv4MulticastRoute_Type);
    /* Register the 'ns3::Ipv4MulticastRoute' class */
    
    PyNs3Ipv4MulticastRouteMeta_Type.tp_base = PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv4MulticastRouteMeta_Type.tp_traverse = PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type.ob_type->tp_traverse;
    PyNs3Ipv4MulticastRouteMeta_Type.tp_clear = PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type.ob_type->tp_clear;
    PyNs3Ipv4MulticastRouteMeta_Type.tp_is_gc = PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv4MulticastRouteMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv4MulticastRouteMeta_Type);
    
    PyNs3Ipv4MulticastRoute_Type.tp_base = &PyNs3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___Type;
    PyNs3Ipv4MulticastRoute_Type.ob_type = &PyNs3Ipv4MulticastRouteMeta_Type;
    if (PyType_Ready(&PyNs3Ipv4MulticastRoute_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4MulticastRoute", (PyObject *) &PyNs3Ipv4MulticastRoute_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv4RawSocketFactory), &PyNs3Ipv4RawSocketFactory_Type);
    /* Register the 'ns3::Ipv4RawSocketFactory' class */
    PyNs3Ipv4RawSocketFactory_Type.tp_base = &PyNs3SocketFactory_Type;
    if (PyType_Ready(&PyNs3Ipv4RawSocketFactory_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4RawSocketFactory", (PyObject *) &PyNs3Ipv4RawSocketFactory_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv4RawSocketImpl), &PyNs3Ipv4RawSocketImpl_Type);
    /* Register the 'ns3::Ipv4RawSocketImpl' class */
    PyNs3Ipv4RawSocketImpl_Type.tp_base = &PyNs3Socket_Type;
    if (PyType_Ready(&PyNs3Ipv4RawSocketImpl_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4RawSocketImpl", (PyObject *) &PyNs3Ipv4RawSocketImpl_Type);
    PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt____typeid_map.register_wrapper(typeid(ns3::Ipv4Route), &PyNs3Ipv4Route_Type);
    /* Register the 'ns3::Ipv4Route' class */
    PyNs3Ipv4Route_Type.tp_base = &PyNs3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___Type;
    if (PyType_Ready(&PyNs3Ipv4Route_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4Route", (PyObject *) &PyNs3Ipv4Route_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv4RoutingProtocol), &PyNs3Ipv4RoutingProtocol_Type);
    /* Register the 'ns3::Ipv4RoutingProtocol' class */
    PyNs3Ipv4RoutingProtocol_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3Ipv4RoutingProtocol_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4RoutingProtocol", (PyObject *) &PyNs3Ipv4RoutingProtocol_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv4StaticRouting), &PyNs3Ipv4StaticRouting_Type);
    /* Register the 'ns3::Ipv4StaticRouting' class */
    PyNs3Ipv4StaticRouting_Type.tp_base = &PyNs3Ipv4RoutingProtocol_Type;
    if (PyType_Ready(&PyNs3Ipv4StaticRouting_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4StaticRouting", (PyObject *) &PyNs3Ipv4StaticRouting_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6), &PyNs3Ipv6_Type);
    /* Register the 'ns3::Ipv6' class */
    
    PyNs3Ipv6Meta_Type.tp_base = PyNs3Object_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv6Meta_Type.tp_traverse = PyNs3Object_Type.ob_type->tp_traverse;
    PyNs3Ipv6Meta_Type.tp_clear = PyNs3Object_Type.ob_type->tp_clear;
    PyNs3Ipv6Meta_Type.tp_is_gc = PyNs3Object_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv6Meta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv6Meta_Type);
    
    PyNs3Ipv6_Type.tp_base = &PyNs3Object_Type;
    PyNs3Ipv6_Type.ob_type = &PyNs3Ipv6Meta_Type;
    if (PyType_Ready(&PyNs3Ipv6_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6", (PyObject *) &PyNs3Ipv6_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6Extension), &PyNs3Ipv6Extension_Type);
    /* Register the 'ns3::Ipv6Extension' class */
    PyNs3Ipv6Extension_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3Ipv6Extension_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6Extension", (PyObject *) &PyNs3Ipv6Extension_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6ExtensionAH), &PyNs3Ipv6ExtensionAH_Type);
    /* Register the 'ns3::Ipv6ExtensionAH' class */
    
    PyNs3Ipv6ExtensionAHMeta_Type.tp_base = PyNs3Ipv6Extension_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv6ExtensionAHMeta_Type.tp_traverse = PyNs3Ipv6Extension_Type.ob_type->tp_traverse;
    PyNs3Ipv6ExtensionAHMeta_Type.tp_clear = PyNs3Ipv6Extension_Type.ob_type->tp_clear;
    PyNs3Ipv6ExtensionAHMeta_Type.tp_is_gc = PyNs3Ipv6Extension_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv6ExtensionAHMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv6ExtensionAHMeta_Type);
    
    PyNs3Ipv6ExtensionAH_Type.tp_base = &PyNs3Ipv6Extension_Type;
    PyNs3Ipv6ExtensionAH_Type.ob_type = &PyNs3Ipv6ExtensionAHMeta_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionAH_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionAH", (PyObject *) &PyNs3Ipv6ExtensionAH_Type);
    /* Register the 'ns3::Ipv6ExtensionAHHeader' class */
    PyNs3Ipv6ExtensionAHHeader_Type.tp_base = &PyNs3Ipv6ExtensionHeader_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionAHHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionAHHeader", (PyObject *) &PyNs3Ipv6ExtensionAHHeader_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6ExtensionDemux), &PyNs3Ipv6ExtensionDemux_Type);
    /* Register the 'ns3::Ipv6ExtensionDemux' class */
    PyNs3Ipv6ExtensionDemux_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionDemux_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionDemux", (PyObject *) &PyNs3Ipv6ExtensionDemux_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6ExtensionDestination), &PyNs3Ipv6ExtensionDestination_Type);
    /* Register the 'ns3::Ipv6ExtensionDestination' class */
    
    PyNs3Ipv6ExtensionDestinationMeta_Type.tp_base = PyNs3Ipv6Extension_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv6ExtensionDestinationMeta_Type.tp_traverse = PyNs3Ipv6Extension_Type.ob_type->tp_traverse;
    PyNs3Ipv6ExtensionDestinationMeta_Type.tp_clear = PyNs3Ipv6Extension_Type.ob_type->tp_clear;
    PyNs3Ipv6ExtensionDestinationMeta_Type.tp_is_gc = PyNs3Ipv6Extension_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv6ExtensionDestinationMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv6ExtensionDestinationMeta_Type);
    
    PyNs3Ipv6ExtensionDestination_Type.tp_base = &PyNs3Ipv6Extension_Type;
    PyNs3Ipv6ExtensionDestination_Type.ob_type = &PyNs3Ipv6ExtensionDestinationMeta_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionDestination_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionDestination", (PyObject *) &PyNs3Ipv6ExtensionDestination_Type);
    /* Register the 'ns3::Ipv6ExtensionDestinationHeader' class */
    PyNs3Ipv6ExtensionDestinationHeader_Type.tp_base = &PyNs3Ipv6ExtensionHeader_Type;
    PyNs3Ipv6ExtensionDestinationHeader_Type.tp_bases = PyTuple_New(2);
        Py_INCREF((PyObject *) &PyNs3Ipv6ExtensionHeader_Type);
        PyTuple_SET_ITEM(PyNs3Ipv6ExtensionDestinationHeader_Type.tp_bases, 0, (PyObject *) &PyNs3Ipv6ExtensionHeader_Type);
        Py_INCREF((PyObject *) &PyNs3OptionField_Type);
        PyTuple_SET_ITEM(PyNs3Ipv6ExtensionDestinationHeader_Type.tp_bases, 1, (PyObject *) &PyNs3OptionField_Type);
    if (PyType_Ready(&PyNs3Ipv6ExtensionDestinationHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionDestinationHeader", (PyObject *) &PyNs3Ipv6ExtensionDestinationHeader_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6ExtensionESP), &PyNs3Ipv6ExtensionESP_Type);
    /* Register the 'ns3::Ipv6ExtensionESP' class */
    
    PyNs3Ipv6ExtensionESPMeta_Type.tp_base = PyNs3Ipv6Extension_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv6ExtensionESPMeta_Type.tp_traverse = PyNs3Ipv6Extension_Type.ob_type->tp_traverse;
    PyNs3Ipv6ExtensionESPMeta_Type.tp_clear = PyNs3Ipv6Extension_Type.ob_type->tp_clear;
    PyNs3Ipv6ExtensionESPMeta_Type.tp_is_gc = PyNs3Ipv6Extension_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv6ExtensionESPMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv6ExtensionESPMeta_Type);
    
    PyNs3Ipv6ExtensionESP_Type.tp_base = &PyNs3Ipv6Extension_Type;
    PyNs3Ipv6ExtensionESP_Type.ob_type = &PyNs3Ipv6ExtensionESPMeta_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionESP_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionESP", (PyObject *) &PyNs3Ipv6ExtensionESP_Type);
    /* Register the 'ns3::Ipv6ExtensionESPHeader' class */
    PyNs3Ipv6ExtensionESPHeader_Type.tp_base = &PyNs3Ipv6ExtensionHeader_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionESPHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionESPHeader", (PyObject *) &PyNs3Ipv6ExtensionESPHeader_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6ExtensionFragment), &PyNs3Ipv6ExtensionFragment_Type);
    /* Register the 'ns3::Ipv6ExtensionFragment' class */
    
    PyNs3Ipv6ExtensionFragmentMeta_Type.tp_base = PyNs3Ipv6Extension_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv6ExtensionFragmentMeta_Type.tp_traverse = PyNs3Ipv6Extension_Type.ob_type->tp_traverse;
    PyNs3Ipv6ExtensionFragmentMeta_Type.tp_clear = PyNs3Ipv6Extension_Type.ob_type->tp_clear;
    PyNs3Ipv6ExtensionFragmentMeta_Type.tp_is_gc = PyNs3Ipv6Extension_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv6ExtensionFragmentMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv6ExtensionFragmentMeta_Type);
    
    PyNs3Ipv6ExtensionFragment_Type.tp_base = &PyNs3Ipv6Extension_Type;
    PyNs3Ipv6ExtensionFragment_Type.ob_type = &PyNs3Ipv6ExtensionFragmentMeta_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionFragment_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionFragment", (PyObject *) &PyNs3Ipv6ExtensionFragment_Type);
    /* Register the 'ns3::Ipv6ExtensionFragmentHeader' class */
    PyNs3Ipv6ExtensionFragmentHeader_Type.tp_base = &PyNs3Ipv6ExtensionHeader_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionFragmentHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionFragmentHeader", (PyObject *) &PyNs3Ipv6ExtensionFragmentHeader_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6ExtensionHopByHop), &PyNs3Ipv6ExtensionHopByHop_Type);
    /* Register the 'ns3::Ipv6ExtensionHopByHop' class */
    
    PyNs3Ipv6ExtensionHopByHopMeta_Type.tp_base = PyNs3Ipv6Extension_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv6ExtensionHopByHopMeta_Type.tp_traverse = PyNs3Ipv6Extension_Type.ob_type->tp_traverse;
    PyNs3Ipv6ExtensionHopByHopMeta_Type.tp_clear = PyNs3Ipv6Extension_Type.ob_type->tp_clear;
    PyNs3Ipv6ExtensionHopByHopMeta_Type.tp_is_gc = PyNs3Ipv6Extension_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv6ExtensionHopByHopMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv6ExtensionHopByHopMeta_Type);
    
    PyNs3Ipv6ExtensionHopByHop_Type.tp_base = &PyNs3Ipv6Extension_Type;
    PyNs3Ipv6ExtensionHopByHop_Type.ob_type = &PyNs3Ipv6ExtensionHopByHopMeta_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionHopByHop_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionHopByHop", (PyObject *) &PyNs3Ipv6ExtensionHopByHop_Type);
    /* Register the 'ns3::Ipv6ExtensionLooseRoutingHeader' class */
    PyNs3Ipv6ExtensionLooseRoutingHeader_Type.tp_base = &PyNs3Ipv6ExtensionRoutingHeader_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionLooseRoutingHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionLooseRoutingHeader", (PyObject *) &PyNs3Ipv6ExtensionLooseRoutingHeader_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6ExtensionRouting), &PyNs3Ipv6ExtensionRouting_Type);
    /* Register the 'ns3::Ipv6ExtensionRouting' class */
    
    PyNs3Ipv6ExtensionRoutingMeta_Type.tp_base = PyNs3Ipv6Extension_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv6ExtensionRoutingMeta_Type.tp_traverse = PyNs3Ipv6Extension_Type.ob_type->tp_traverse;
    PyNs3Ipv6ExtensionRoutingMeta_Type.tp_clear = PyNs3Ipv6Extension_Type.ob_type->tp_clear;
    PyNs3Ipv6ExtensionRoutingMeta_Type.tp_is_gc = PyNs3Ipv6Extension_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv6ExtensionRoutingMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv6ExtensionRoutingMeta_Type);
    
    PyNs3Ipv6ExtensionRouting_Type.tp_base = &PyNs3Ipv6Extension_Type;
    PyNs3Ipv6ExtensionRouting_Type.ob_type = &PyNs3Ipv6ExtensionRoutingMeta_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionRouting_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionRouting", (PyObject *) &PyNs3Ipv6ExtensionRouting_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6ExtensionRoutingDemux), &PyNs3Ipv6ExtensionRoutingDemux_Type);
    /* Register the 'ns3::Ipv6ExtensionRoutingDemux' class */
    PyNs3Ipv6ExtensionRoutingDemux_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionRoutingDemux_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionRoutingDemux", (PyObject *) &PyNs3Ipv6ExtensionRoutingDemux_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6Interface), &PyNs3Ipv6Interface_Type);
    /* Register the 'ns3::Ipv6Interface' class */
    PyNs3Ipv6Interface_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3Ipv6Interface_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6Interface", (PyObject *) &PyNs3Ipv6Interface_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6L3Protocol), &PyNs3Ipv6L3Protocol_Type);
    /* Register the 'ns3::Ipv6L3Protocol' class */
    
    PyNs3Ipv6L3ProtocolMeta_Type.tp_base = PyNs3Ipv6_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv6L3ProtocolMeta_Type.tp_traverse = PyNs3Ipv6_Type.ob_type->tp_traverse;
    PyNs3Ipv6L3ProtocolMeta_Type.tp_clear = PyNs3Ipv6_Type.ob_type->tp_clear;
    PyNs3Ipv6L3ProtocolMeta_Type.tp_is_gc = PyNs3Ipv6_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv6L3ProtocolMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv6L3ProtocolMeta_Type);
    
    PyNs3Ipv6L3Protocol_Type.tp_base = &PyNs3Ipv6_Type;
    PyNs3Ipv6L3Protocol_Type.ob_type = &PyNs3Ipv6L3ProtocolMeta_Type;
    if (PyType_Ready(&PyNs3Ipv6L3Protocol_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6L3Protocol", (PyObject *) &PyNs3Ipv6L3Protocol_Type);
    PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt____typeid_map.register_wrapper(typeid(ns3::Ipv6MulticastRoute), &PyNs3Ipv6MulticastRoute_Type);
    /* Register the 'ns3::Ipv6MulticastRoute' class */
    
    PyNs3Ipv6MulticastRouteMeta_Type.tp_base = PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv6MulticastRouteMeta_Type.tp_traverse = PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type.ob_type->tp_traverse;
    PyNs3Ipv6MulticastRouteMeta_Type.tp_clear = PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type.ob_type->tp_clear;
    PyNs3Ipv6MulticastRouteMeta_Type.tp_is_gc = PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv6MulticastRouteMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv6MulticastRouteMeta_Type);
    
    PyNs3Ipv6MulticastRoute_Type.tp_base = &PyNs3SimpleRefCount__Ns3Ipv6MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6MulticastRoute__gt___Type;
    PyNs3Ipv6MulticastRoute_Type.ob_type = &PyNs3Ipv6MulticastRouteMeta_Type;
    if (PyType_Ready(&PyNs3Ipv6MulticastRoute_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6MulticastRoute", (PyObject *) &PyNs3Ipv6MulticastRoute_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6RawSocketFactory), &PyNs3Ipv6RawSocketFactory_Type);
    /* Register the 'ns3::Ipv6RawSocketFactory' class */
    PyNs3Ipv6RawSocketFactory_Type.tp_base = &PyNs3SocketFactory_Type;
    if (PyType_Ready(&PyNs3Ipv6RawSocketFactory_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6RawSocketFactory", (PyObject *) &PyNs3Ipv6RawSocketFactory_Type);
    PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt____typeid_map.register_wrapper(typeid(ns3::Ipv6Route), &PyNs3Ipv6Route_Type);
    /* Register the 'ns3::Ipv6Route' class */
    PyNs3Ipv6Route_Type.tp_base = &PyNs3SimpleRefCount__Ns3Ipv6Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv6Route__gt___Type;
    if (PyType_Ready(&PyNs3Ipv6Route_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6Route", (PyObject *) &PyNs3Ipv6Route_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6RoutingProtocol), &PyNs3Ipv6RoutingProtocol_Type);
    /* Register the 'ns3::Ipv6RoutingProtocol' class */
    PyNs3Ipv6RoutingProtocol_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3Ipv6RoutingProtocol_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6RoutingProtocol", (PyObject *) &PyNs3Ipv6RoutingProtocol_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6StaticRouting), &PyNs3Ipv6StaticRouting_Type);
    /* Register the 'ns3::Ipv6StaticRouting' class */
    PyNs3Ipv6StaticRouting_Type.tp_base = &PyNs3Ipv6RoutingProtocol_Type;
    if (PyType_Ready(&PyNs3Ipv6StaticRouting_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6StaticRouting", (PyObject *) &PyNs3Ipv6StaticRouting_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::NdiscCache), &PyNs3NdiscCache_Type);
    /* Register the 'ns3::NdiscCache' class */
    
    PyNs3NdiscCacheMeta_Type.tp_base = PyNs3Object_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3NdiscCacheMeta_Type.tp_traverse = PyNs3Object_Type.ob_type->tp_traverse;
    PyNs3NdiscCacheMeta_Type.tp_clear = PyNs3Object_Type.ob_type->tp_clear;
    PyNs3NdiscCacheMeta_Type.tp_is_gc = PyNs3Object_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3NdiscCacheMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3NdiscCacheMeta_Type);
    
    PyNs3NdiscCache_Type.tp_base = &PyNs3Object_Type;
    PyNs3NdiscCache_Type.ob_type = &PyNs3NdiscCacheMeta_Type;
    if (PyType_Ready(&PyNs3NdiscCache_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "NdiscCache", (PyObject *) &PyNs3NdiscCache_Type);
    PyModule_AddObject(m, (char *) "_PyNs3NdiscCacheEntry_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3NdiscCacheEntry_wrapper_registry, NULL));
    /* Register the 'ns3::NdiscCache::Entry' class */
    if (PyType_Ready(&PyNs3NdiscCacheEntry_Type)) {
        return;
    }
    PyDict_SetItemString((PyObject*) PyNs3NdiscCache_Type.tp_dict, (char *) "Entry", (PyObject *) &PyNs3NdiscCacheEntry_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::TcpL4Protocol), &PyNs3TcpL4Protocol_Type);
    /* Register the 'ns3::TcpL4Protocol' class */
    
    PyNs3TcpL4ProtocolMeta_Type.tp_base = PyNs3IpL4Protocol_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3TcpL4ProtocolMeta_Type.tp_traverse = PyNs3IpL4Protocol_Type.ob_type->tp_traverse;
    PyNs3TcpL4ProtocolMeta_Type.tp_clear = PyNs3IpL4Protocol_Type.ob_type->tp_clear;
    PyNs3TcpL4ProtocolMeta_Type.tp_is_gc = PyNs3IpL4Protocol_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3TcpL4ProtocolMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3TcpL4ProtocolMeta_Type);
    
    PyNs3TcpL4Protocol_Type.tp_base = &PyNs3IpL4Protocol_Type;
    PyNs3TcpL4Protocol_Type.ob_type = &PyNs3TcpL4ProtocolMeta_Type;
    if (PyType_Ready(&PyNs3TcpL4Protocol_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "TcpL4Protocol", (PyObject *) &PyNs3TcpL4Protocol_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::UdpL4Protocol), &PyNs3UdpL4Protocol_Type);
    /* Register the 'ns3::UdpL4Protocol' class */
    
    PyNs3UdpL4ProtocolMeta_Type.tp_base = PyNs3IpL4Protocol_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3UdpL4ProtocolMeta_Type.tp_traverse = PyNs3IpL4Protocol_Type.ob_type->tp_traverse;
    PyNs3UdpL4ProtocolMeta_Type.tp_clear = PyNs3IpL4Protocol_Type.ob_type->tp_clear;
    PyNs3UdpL4ProtocolMeta_Type.tp_is_gc = PyNs3IpL4Protocol_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3UdpL4ProtocolMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3UdpL4ProtocolMeta_Type);
    
    PyNs3UdpL4Protocol_Type.tp_base = &PyNs3IpL4Protocol_Type;
    PyNs3UdpL4Protocol_Type.ob_type = &PyNs3UdpL4ProtocolMeta_Type;
    if (PyType_Ready(&PyNs3UdpL4Protocol_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "UdpL4Protocol", (PyObject *) &PyNs3UdpL4Protocol_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Icmpv4L4Protocol), &PyNs3Icmpv4L4Protocol_Type);
    /* Register the 'ns3::Icmpv4L4Protocol' class */
    
    PyNs3Icmpv4L4ProtocolMeta_Type.tp_base = PyNs3IpL4Protocol_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Icmpv4L4ProtocolMeta_Type.tp_traverse = PyNs3IpL4Protocol_Type.ob_type->tp_traverse;
    PyNs3Icmpv4L4ProtocolMeta_Type.tp_clear = PyNs3IpL4Protocol_Type.ob_type->tp_clear;
    PyNs3Icmpv4L4ProtocolMeta_Type.tp_is_gc = PyNs3IpL4Protocol_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Icmpv4L4ProtocolMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Icmpv4L4ProtocolMeta_Type);
    
    PyNs3Icmpv4L4Protocol_Type.tp_base = &PyNs3IpL4Protocol_Type;
    PyNs3Icmpv4L4Protocol_Type.ob_type = &PyNs3Icmpv4L4ProtocolMeta_Type;
    if (PyType_Ready(&PyNs3Icmpv4L4Protocol_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv4L4Protocol", (PyObject *) &PyNs3Icmpv4L4Protocol_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Icmpv6L4Protocol), &PyNs3Icmpv6L4Protocol_Type);
    /* Register the 'ns3::Icmpv6L4Protocol' class */
    
    PyNs3Icmpv6L4ProtocolMeta_Type.tp_base = PyNs3IpL4Protocol_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Icmpv6L4ProtocolMeta_Type.tp_traverse = PyNs3IpL4Protocol_Type.ob_type->tp_traverse;
    PyNs3Icmpv6L4ProtocolMeta_Type.tp_clear = PyNs3IpL4Protocol_Type.ob_type->tp_clear;
    PyNs3Icmpv6L4ProtocolMeta_Type.tp_is_gc = PyNs3IpL4Protocol_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Icmpv6L4ProtocolMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Icmpv6L4ProtocolMeta_Type);
    
    PyNs3Icmpv6L4Protocol_Type.tp_base = &PyNs3IpL4Protocol_Type;
    PyNs3Icmpv6L4Protocol_Type.ob_type = &PyNs3Icmpv6L4ProtocolMeta_Type;
    if (PyType_Ready(&PyNs3Icmpv6L4Protocol_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Icmpv6L4Protocol", (PyObject *) &PyNs3Icmpv6L4Protocol_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv4GlobalRouting), &PyNs3Ipv4GlobalRouting_Type);
    /* Register the 'ns3::Ipv4GlobalRouting' class */
    PyNs3Ipv4GlobalRouting_Type.tp_base = &PyNs3Ipv4RoutingProtocol_Type;
    if (PyType_Ready(&PyNs3Ipv4GlobalRouting_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4GlobalRouting", (PyObject *) &PyNs3Ipv4GlobalRouting_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv4ListRouting), &PyNs3Ipv4ListRouting_Type);
    /* Register the 'ns3::Ipv4ListRouting' class */
    PyNs3Ipv4ListRouting_Type.tp_base = &PyNs3Ipv4RoutingProtocol_Type;
    if (PyType_Ready(&PyNs3Ipv4ListRouting_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv4ListRouting", (PyObject *) &PyNs3Ipv4ListRouting_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6ExtensionLooseRouting), &PyNs3Ipv6ExtensionLooseRouting_Type);
    /* Register the 'ns3::Ipv6ExtensionLooseRouting' class */
    
    PyNs3Ipv6ExtensionLooseRoutingMeta_Type.tp_base = PyNs3Ipv6ExtensionRouting_Type.ob_type;
    /* Some fields need to be manually inheritted from the parent metaclass */
    PyNs3Ipv6ExtensionLooseRoutingMeta_Type.tp_traverse = PyNs3Ipv6ExtensionRouting_Type.ob_type->tp_traverse;
    PyNs3Ipv6ExtensionLooseRoutingMeta_Type.tp_clear = PyNs3Ipv6ExtensionRouting_Type.ob_type->tp_clear;
    PyNs3Ipv6ExtensionLooseRoutingMeta_Type.tp_is_gc = PyNs3Ipv6ExtensionRouting_Type.ob_type->tp_is_gc;
    /* PyType tp_setattro is too restrictive */
    PyNs3Ipv6ExtensionLooseRoutingMeta_Type.tp_setattro = PyObject_GenericSetAttr;
    PyType_Ready(&PyNs3Ipv6ExtensionLooseRoutingMeta_Type);
    
    PyNs3Ipv6ExtensionLooseRouting_Type.tp_base = &PyNs3Ipv6ExtensionRouting_Type;
    PyNs3Ipv6ExtensionLooseRouting_Type.ob_type = &PyNs3Ipv6ExtensionLooseRoutingMeta_Type;
    if (PyType_Ready(&PyNs3Ipv6ExtensionLooseRouting_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ExtensionLooseRouting", (PyObject *) &PyNs3Ipv6ExtensionLooseRouting_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::Ipv6ListRouting), &PyNs3Ipv6ListRouting_Type);
    /* Register the 'ns3::Ipv6ListRouting' class */
    PyNs3Ipv6ListRouting_Type.tp_base = &PyNs3Ipv6RoutingProtocol_Type;
    if (PyType_Ready(&PyNs3Ipv6ListRouting_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ipv6ListRouting", (PyObject *) &PyNs3Ipv6ListRouting_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::LoopbackNetDevice), &PyNs3LoopbackNetDevice_Type);
    /* Register the 'ns3::LoopbackNetDevice' class */
    PyNs3LoopbackNetDevice_Type.tp_base = &PyNs3NetDevice_Type;
    if (PyType_Ready(&PyNs3LoopbackNetDevice_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "LoopbackNetDevice", (PyObject *) &PyNs3LoopbackNetDevice_Type);
    /* Register the 'std::vector< unsigned int >' class */
    if (PyType_Ready(&Pystd__vector__lt___unsigned_int___gt___Type)) {
        return;
    }
    if (PyType_Ready(&Pystd__vector__lt___unsigned_int___gt__Iter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Std__vector__lt___unsigned_int___gt__", (PyObject *) &Pystd__vector__lt___unsigned_int___gt___Type);
    PyModule_AddObject(m, (char *) "Std__vector__lt___unsigned_int___gt__Iter", (PyObject *) &Pystd__vector__lt___unsigned_int___gt__Iter_Type);
    /* Register the 'std::vector< bool >' class */
    if (PyType_Ready(&Pystd__vector__lt___bool___gt___Type)) {
        return;
    }
    if (PyType_Ready(&Pystd__vector__lt___bool___gt__Iter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Std__vector__lt___bool___gt__", (PyObject *) &Pystd__vector__lt___bool___gt___Type);
    PyModule_AddObject(m, (char *) "Std__vector__lt___bool___gt__Iter", (PyObject *) &Pystd__vector__lt___bool___gt__Iter_Type);
    /* Register the 'std::list< ns3::Ptr< ns3::Packet > >' class */
    if (PyType_Ready(&Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt___Type)) {
        return;
    }
    if (PyType_Ready(&Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__", (PyObject *) &Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt___Type);
    PyModule_AddObject(m, (char *) "Std__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter", (PyObject *) &Pystd__list__lt___ns3__Ptr__lt___ns3__Packet___gt_____gt__Iter_Type);
    /* Register the 'std::map< unsigned int, unsigned int >' class */
    if (PyType_Ready(&Pystd__map__lt___unsigned_int__unsigned_int___gt___Type)) {
        return;
    }
    if (PyType_Ready(&Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Std__map__lt___unsigned_int__unsigned_int___gt__", (PyObject *) &Pystd__map__lt___unsigned_int__unsigned_int___gt___Type);
    PyModule_AddObject(m, (char *) "Std__map__lt___unsigned_int__unsigned_int___gt__Iter", (PyObject *) &Pystd__map__lt___unsigned_int__unsigned_int___gt__Iter_Type);
    /* Register the 'std::vector< ns3::Ipv6Address >' class */
    if (PyType_Ready(&Pystd__vector__lt___ns3__Ipv6Address___gt___Type)) {
        return;
    }
    if (PyType_Ready(&Pystd__vector__lt___ns3__Ipv6Address___gt__Iter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Std__vector__lt___ns3__Ipv6Address___gt__", (PyObject *) &Pystd__vector__lt___ns3__Ipv6Address___gt___Type);
    PyModule_AddObject(m, (char *) "Std__vector__lt___ns3__Ipv6Address___gt__Iter", (PyObject *) &Pystd__vector__lt___ns3__Ipv6Address___gt__Iter_Type);
    PyModule_AddIntConstant(m, (char *) "CLOSED", ns3::CLOSED);
    PyModule_AddIntConstant(m, (char *) "LISTEN", ns3::LISTEN);
    PyModule_AddIntConstant(m, (char *) "SYN_SENT", ns3::SYN_SENT);
    PyModule_AddIntConstant(m, (char *) "SYN_RCVD", ns3::SYN_RCVD);
    PyModule_AddIntConstant(m, (char *) "ESTABLISHED", ns3::ESTABLISHED);
    PyModule_AddIntConstant(m, (char *) "CLOSE_WAIT", ns3::CLOSE_WAIT);
    PyModule_AddIntConstant(m, (char *) "LAST_ACK", ns3::LAST_ACK);
    PyModule_AddIntConstant(m, (char *) "FIN_WAIT_1", ns3::FIN_WAIT_1);
    PyModule_AddIntConstant(m, (char *) "FIN_WAIT_2", ns3::FIN_WAIT_2);
    PyModule_AddIntConstant(m, (char *) "CLOSING", ns3::CLOSING);
    PyModule_AddIntConstant(m, (char *) "TIME_WAIT", ns3::TIME_WAIT);
    PyModule_AddIntConstant(m, (char *) "LAST_STATE", ns3::LAST_STATE);
    {
        PyObject *tmp_value;
         // ns3::GlobalRoutingLSA::Unknown
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLSA::Unknown);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLSA_Type.tp_dict, "Unknown", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::GlobalRoutingLSA::RouterLSA
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLSA::RouterLSA);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLSA_Type.tp_dict, "RouterLSA", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::GlobalRoutingLSA::NetworkLSA
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLSA::NetworkLSA);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLSA_Type.tp_dict, "NetworkLSA", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::GlobalRoutingLSA::SummaryLSA
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLSA::SummaryLSA);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLSA_Type.tp_dict, "SummaryLSA", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::GlobalRoutingLSA::SummaryLSA_ASBR
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLSA::SummaryLSA_ASBR);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLSA_Type.tp_dict, "SummaryLSA_ASBR", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::GlobalRoutingLSA::ASExternalLSAs
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLSA::ASExternalLSAs);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLSA_Type.tp_dict, "ASExternalLSAs", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::GlobalRoutingLSA::LSA_SPF_NOT_EXPLORED
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLSA::LSA_SPF_NOT_EXPLORED);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLSA_Type.tp_dict, "LSA_SPF_NOT_EXPLORED", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::GlobalRoutingLSA::LSA_SPF_CANDIDATE
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLSA::LSA_SPF_CANDIDATE);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLSA_Type.tp_dict, "LSA_SPF_CANDIDATE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::GlobalRoutingLSA::LSA_SPF_IN_SPFTREE
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLSA::LSA_SPF_IN_SPFTREE);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLSA_Type.tp_dict, "LSA_SPF_IN_SPFTREE", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::GlobalRoutingLinkRecord::Unknown
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLinkRecord::Unknown);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLinkRecord_Type.tp_dict, "Unknown", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::GlobalRoutingLinkRecord::PointToPoint
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLinkRecord::PointToPoint);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLinkRecord_Type.tp_dict, "PointToPoint", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::GlobalRoutingLinkRecord::TransitNetwork
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLinkRecord::TransitNetwork);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLinkRecord_Type.tp_dict, "TransitNetwork", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::GlobalRoutingLinkRecord::StubNetwork
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLinkRecord::StubNetwork);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLinkRecord_Type.tp_dict, "StubNetwork", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::GlobalRoutingLinkRecord::VirtualLink
        tmp_value = PyInt_FromLong(ns3::GlobalRoutingLinkRecord::VirtualLink);
        PyDict_SetItemString((PyObject*) PyNs3GlobalRoutingLinkRecord_Type.tp_dict, "VirtualLink", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Ipv4InterfaceAddress::HOST
        tmp_value = PyInt_FromLong(ns3::Ipv4InterfaceAddress::HOST);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4InterfaceAddress_Type.tp_dict, "HOST", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4InterfaceAddress::LINK
        tmp_value = PyInt_FromLong(ns3::Ipv4InterfaceAddress::LINK);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4InterfaceAddress_Type.tp_dict, "LINK", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4InterfaceAddress::GLOBAL
        tmp_value = PyInt_FromLong(ns3::Ipv4InterfaceAddress::GLOBAL);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4InterfaceAddress_Type.tp_dict, "GLOBAL", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Ipv6InterfaceAddress::TENTATIVE
        tmp_value = PyInt_FromLong(ns3::Ipv6InterfaceAddress::TENTATIVE);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6InterfaceAddress_Type.tp_dict, "TENTATIVE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6InterfaceAddress::DEPRECATED
        tmp_value = PyInt_FromLong(ns3::Ipv6InterfaceAddress::DEPRECATED);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6InterfaceAddress_Type.tp_dict, "DEPRECATED", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6InterfaceAddress::PREFERRED
        tmp_value = PyInt_FromLong(ns3::Ipv6InterfaceAddress::PREFERRED);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6InterfaceAddress_Type.tp_dict, "PREFERRED", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6InterfaceAddress::PERMANENT
        tmp_value = PyInt_FromLong(ns3::Ipv6InterfaceAddress::PERMANENT);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6InterfaceAddress_Type.tp_dict, "PERMANENT", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6InterfaceAddress::HOMEADDRESS
        tmp_value = PyInt_FromLong(ns3::Ipv6InterfaceAddress::HOMEADDRESS);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6InterfaceAddress_Type.tp_dict, "HOMEADDRESS", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6InterfaceAddress::TENTATIVE_OPTIMISTIC
        tmp_value = PyInt_FromLong(ns3::Ipv6InterfaceAddress::TENTATIVE_OPTIMISTIC);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6InterfaceAddress_Type.tp_dict, "TENTATIVE_OPTIMISTIC", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6InterfaceAddress::INVALID
        tmp_value = PyInt_FromLong(ns3::Ipv6InterfaceAddress::INVALID);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6InterfaceAddress_Type.tp_dict, "INVALID", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Ipv6InterfaceAddress::HOST
        tmp_value = PyInt_FromLong(ns3::Ipv6InterfaceAddress::HOST);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6InterfaceAddress_Type.tp_dict, "HOST", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6InterfaceAddress::LINKLOCAL
        tmp_value = PyInt_FromLong(ns3::Ipv6InterfaceAddress::LINKLOCAL);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6InterfaceAddress_Type.tp_dict, "LINKLOCAL", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6InterfaceAddress::GLOBAL
        tmp_value = PyInt_FromLong(ns3::Ipv6InterfaceAddress::GLOBAL);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6InterfaceAddress_Type.tp_dict, "GLOBAL", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::SPFVertex::VertexUnknown
        tmp_value = PyInt_FromLong(ns3::SPFVertex::VertexUnknown);
        PyDict_SetItemString((PyObject*) PyNs3SPFVertex_Type.tp_dict, "VertexUnknown", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::SPFVertex::VertexRouter
        tmp_value = PyInt_FromLong(ns3::SPFVertex::VertexRouter);
        PyDict_SetItemString((PyObject*) PyNs3SPFVertex_Type.tp_dict, "VertexRouter", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::SPFVertex::VertexNetwork
        tmp_value = PyInt_FromLong(ns3::SPFVertex::VertexNetwork);
        PyDict_SetItemString((PyObject*) PyNs3SPFVertex_Type.tp_dict, "VertexNetwork", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Icmpv4DestinationUnreachable::NET_UNREACHABLE
        tmp_value = PyInt_FromLong(ns3::Icmpv4DestinationUnreachable::NET_UNREACHABLE);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv4DestinationUnreachable_Type.tp_dict, "NET_UNREACHABLE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv4DestinationUnreachable::HOST_UNREACHABLE
        tmp_value = PyInt_FromLong(ns3::Icmpv4DestinationUnreachable::HOST_UNREACHABLE);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv4DestinationUnreachable_Type.tp_dict, "HOST_UNREACHABLE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv4DestinationUnreachable::PROTOCOL_UNREACHABLE
        tmp_value = PyInt_FromLong(ns3::Icmpv4DestinationUnreachable::PROTOCOL_UNREACHABLE);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv4DestinationUnreachable_Type.tp_dict, "PROTOCOL_UNREACHABLE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv4DestinationUnreachable::PORT_UNREACHABLE
        tmp_value = PyInt_FromLong(ns3::Icmpv4DestinationUnreachable::PORT_UNREACHABLE);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv4DestinationUnreachable_Type.tp_dict, "PORT_UNREACHABLE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv4DestinationUnreachable::FRAG_NEEDED
        tmp_value = PyInt_FromLong(ns3::Icmpv4DestinationUnreachable::FRAG_NEEDED);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv4DestinationUnreachable_Type.tp_dict, "FRAG_NEEDED", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv4DestinationUnreachable::SOURCE_ROUTE_FAILED
        tmp_value = PyInt_FromLong(ns3::Icmpv4DestinationUnreachable::SOURCE_ROUTE_FAILED);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv4DestinationUnreachable_Type.tp_dict, "SOURCE_ROUTE_FAILED", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Icmpv4Header::ECHO_REPLY
        tmp_value = PyInt_FromLong(ns3::Icmpv4Header::ECHO_REPLY);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv4Header_Type.tp_dict, "ECHO_REPLY", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv4Header::DEST_UNREACH
        tmp_value = PyInt_FromLong(ns3::Icmpv4Header::DEST_UNREACH);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv4Header_Type.tp_dict, "DEST_UNREACH", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv4Header::ECHO
        tmp_value = PyInt_FromLong(ns3::Icmpv4Header::ECHO);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv4Header_Type.tp_dict, "ECHO", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv4Header::TIME_EXCEEDED
        tmp_value = PyInt_FromLong(ns3::Icmpv4Header::TIME_EXCEEDED);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv4Header_Type.tp_dict, "TIME_EXCEEDED", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Icmpv4TimeExceeded::TIME_TO_LIVE
        tmp_value = PyInt_FromLong(ns3::Icmpv4TimeExceeded::TIME_TO_LIVE);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv4TimeExceeded_Type.tp_dict, "TIME_TO_LIVE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv4TimeExceeded::FRAGMENT_REASSEMBLY
        tmp_value = PyInt_FromLong(ns3::Icmpv4TimeExceeded::FRAGMENT_REASSEMBLY);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv4TimeExceeded_Type.tp_dict, "FRAGMENT_REASSEMBLY", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Icmpv6Header::ICMPV6_ERROR_DESTINATION_UNREACHABLE
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ERROR_DESTINATION_UNREACHABLE);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ERROR_DESTINATION_UNREACHABLE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ERROR_PACKET_TOO_BIG
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ERROR_PACKET_TOO_BIG);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ERROR_PACKET_TOO_BIG", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ERROR_TIME_EXCEEDED
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ERROR_TIME_EXCEEDED);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ERROR_TIME_EXCEEDED", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ERROR_PARAMETER_ERROR
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ERROR_PARAMETER_ERROR);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ERROR_PARAMETER_ERROR", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ECHO_REQUEST
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ECHO_REQUEST);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ECHO_REQUEST", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ECHO_REPLY
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ECHO_REPLY);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ECHO_REPLY", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_SUBSCRIBE_REQUEST
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_SUBSCRIBE_REQUEST);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_SUBSCRIBE_REQUEST", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_SUBSCRIBE_REPORT
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_SUBSCRIBE_REPORT);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_SUBSCRIBE_REPORT", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_SUBSCRIVE_END
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_SUBSCRIVE_END);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_SUBSCRIVE_END", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ND_ROUTER_SOLICITATION
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ND_ROUTER_SOLICITATION);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ND_ROUTER_SOLICITATION", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ND_ROUTER_ADVERTISEMENT
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ND_ROUTER_ADVERTISEMENT);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ND_ROUTER_ADVERTISEMENT", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ND_NEIGHBOR_SOLICITATION
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ND_NEIGHBOR_SOLICITATION);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ND_NEIGHBOR_SOLICITATION", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ND_NEIGHBOR_ADVERTISEMENT
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ND_NEIGHBOR_ADVERTISEMENT);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ND_NEIGHBOR_ADVERTISEMENT", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ND_REDIRECTION
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ND_REDIRECTION);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ND_REDIRECTION", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ROUTER_RENUMBER
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ROUTER_RENUMBER);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ROUTER_RENUMBER", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_INFORMATION_REQUEST
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_INFORMATION_REQUEST);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_INFORMATION_REQUEST", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_INFORMATION_RESPONSE
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_INFORMATION_RESPONSE);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_INFORMATION_RESPONSE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_INVERSE_ND_SOLICITATION
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_INVERSE_ND_SOLICITATION);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_INVERSE_ND_SOLICITATION", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_INVERSE_ND_ADVERSTISEMENT
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_INVERSE_ND_ADVERSTISEMENT);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_INVERSE_ND_ADVERSTISEMENT", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_MLDV2_SUBSCRIBE_REPORT
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_MLDV2_SUBSCRIBE_REPORT);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_MLDV2_SUBSCRIBE_REPORT", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_MOBILITY_HA_DISCOVER_REQUEST
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_MOBILITY_HA_DISCOVER_REQUEST);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_MOBILITY_HA_DISCOVER_REQUEST", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_MOBILITY_HA_DISCOVER_RESPONSE
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_MOBILITY_HA_DISCOVER_RESPONSE);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_MOBILITY_HA_DISCOVER_RESPONSE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_MOBILITY_MOBILE_PREFIX_SOLICITATION
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_MOBILITY_MOBILE_PREFIX_SOLICITATION);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_MOBILITY_MOBILE_PREFIX_SOLICITATION", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_SECURE_ND_CERTIFICATE_PATH_SOLICITATION
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_SECURE_ND_CERTIFICATE_PATH_SOLICITATION);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_SECURE_ND_CERTIFICATE_PATH_SOLICITATION", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_SECURE_ND_CERTIFICATE_PATH_ADVERTISEMENT
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_SECURE_ND_CERTIFICATE_PATH_ADVERTISEMENT);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_SECURE_ND_CERTIFICATE_PATH_ADVERTISEMENT", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_EXPERIMENTAL_MOBILITY
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_EXPERIMENTAL_MOBILITY);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_EXPERIMENTAL_MOBILITY", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Icmpv6Header::ICMPV6_OPT_LINK_LAYER_SOURCE
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_OPT_LINK_LAYER_SOURCE);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_OPT_LINK_LAYER_SOURCE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_OPT_LINK_LAYER_TARGET
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_OPT_LINK_LAYER_TARGET);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_OPT_LINK_LAYER_TARGET", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_OPT_PREFIX
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_OPT_PREFIX);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_OPT_PREFIX", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_OPT_REDIRECTED
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_OPT_REDIRECTED);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_OPT_REDIRECTED", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_OPT_MTU
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_OPT_MTU);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_OPT_MTU", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Icmpv6Header::ICMPV6_NO_ROUTE
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_NO_ROUTE);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_NO_ROUTE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ADM_PROHIBITED
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ADM_PROHIBITED);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ADM_PROHIBITED", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_NOT_NEIGHBOUR
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_NOT_NEIGHBOUR);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_NOT_NEIGHBOUR", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_ADDR_UNREACHABLE
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_ADDR_UNREACHABLE);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_ADDR_UNREACHABLE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_PORT_UNREACHABLE
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_PORT_UNREACHABLE);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_PORT_UNREACHABLE", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Icmpv6Header::ICMPV6_HOPLIMIT
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_HOPLIMIT);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_HOPLIMIT", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_FRAGTIME
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_FRAGTIME);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_FRAGTIME", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Icmpv6Header::ICMPV6_MALFORMED_HEADER
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_MALFORMED_HEADER);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_MALFORMED_HEADER", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_UNKNOWN_NEXT_HEADER
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_UNKNOWN_NEXT_HEADER);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_UNKNOWN_NEXT_HEADER", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Icmpv6Header::ICMPV6_UNKNOWN_OPTION
        tmp_value = PyInt_FromLong(ns3::Icmpv6Header::ICMPV6_UNKNOWN_OPTION);
        PyDict_SetItemString((PyObject*) PyNs3Icmpv6Header_Type.tp_dict, "ICMPV6_UNKNOWN_OPTION", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Ipv4Header::DscpDefault
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::DscpDefault);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "DscpDefault", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::CS1
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::CS1);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "CS1", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::AF11
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::AF11);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "AF11", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::AF12
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::AF12);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "AF12", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::AF13
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::AF13);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "AF13", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::CS2
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::CS2);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "CS2", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::AF21
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::AF21);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "AF21", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::AF22
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::AF22);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "AF22", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::AF23
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::AF23);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "AF23", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::CS3
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::CS3);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "CS3", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::AF31
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::AF31);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "AF31", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::AF32
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::AF32);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "AF32", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::AF33
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::AF33);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "AF33", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::CS4
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::CS4);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "CS4", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::AF41
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::AF41);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "AF41", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::AF42
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::AF42);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "AF42", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::AF43
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::AF43);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "AF43", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::CS5
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::CS5);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "CS5", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::EF
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::EF);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "EF", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::CS6
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::CS6);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "CS6", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::CS7
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::CS7);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "CS7", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Ipv4Header::NotECT
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::NotECT);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "NotECT", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::ECT1
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::ECT1);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "ECT1", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::ECT0
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::ECT0);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "ECT0", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4Header::CE
        tmp_value = PyInt_FromLong(ns3::Ipv4Header::CE);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4Header_Type.tp_dict, "CE", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Ipv6Header::IPV6_EXT_HOP_BY_HOP
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_EXT_HOP_BY_HOP);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_EXT_HOP_BY_HOP", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_IPV4
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_IPV4);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_IPV4", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_TCP
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_TCP);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_TCP", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_UDP
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_UDP);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_UDP", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_IPV6
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_IPV6);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_IPV6", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_EXT_ROUTING
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_EXT_ROUTING);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_EXT_ROUTING", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_EXT_FRAGMENTATION
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_EXT_FRAGMENTATION);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_EXT_FRAGMENTATION", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_EXT_CONFIDENTIALITY
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_EXT_CONFIDENTIALITY);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_EXT_CONFIDENTIALITY", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_EXT_AUTHENTIFICATION
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_EXT_AUTHENTIFICATION);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_EXT_AUTHENTIFICATION", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_ICMPV6
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_ICMPV6);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_ICMPV6", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_EXT_END
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_EXT_END);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_EXT_END", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_EXT_DESTINATION
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_EXT_DESTINATION);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_EXT_DESTINATION", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_SCTP
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_SCTP);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_SCTP", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_EXT_MOBILITY
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_EXT_MOBILITY);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_EXT_MOBILITY", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6Header::IPV6_UDP_LITE
        tmp_value = PyInt_FromLong(ns3::Ipv6Header::IPV6_UDP_LITE);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6Header_Type.tp_dict, "IPV6_UDP_LITE", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::TcpHeader::NONE
        tmp_value = PyInt_FromLong(ns3::TcpHeader::NONE);
        PyDict_SetItemString((PyObject*) PyNs3TcpHeader_Type.tp_dict, "NONE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::TcpHeader::FIN
        tmp_value = PyInt_FromLong(ns3::TcpHeader::FIN);
        PyDict_SetItemString((PyObject*) PyNs3TcpHeader_Type.tp_dict, "FIN", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::TcpHeader::SYN
        tmp_value = PyInt_FromLong(ns3::TcpHeader::SYN);
        PyDict_SetItemString((PyObject*) PyNs3TcpHeader_Type.tp_dict, "SYN", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::TcpHeader::RST
        tmp_value = PyInt_FromLong(ns3::TcpHeader::RST);
        PyDict_SetItemString((PyObject*) PyNs3TcpHeader_Type.tp_dict, "RST", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::TcpHeader::PSH
        tmp_value = PyInt_FromLong(ns3::TcpHeader::PSH);
        PyDict_SetItemString((PyObject*) PyNs3TcpHeader_Type.tp_dict, "PSH", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::TcpHeader::ACK
        tmp_value = PyInt_FromLong(ns3::TcpHeader::ACK);
        PyDict_SetItemString((PyObject*) PyNs3TcpHeader_Type.tp_dict, "ACK", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::TcpHeader::URG
        tmp_value = PyInt_FromLong(ns3::TcpHeader::URG);
        PyDict_SetItemString((PyObject*) PyNs3TcpHeader_Type.tp_dict, "URG", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::TcpHeader::ECE
        tmp_value = PyInt_FromLong(ns3::TcpHeader::ECE);
        PyDict_SetItemString((PyObject*) PyNs3TcpHeader_Type.tp_dict, "ECE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::TcpHeader::CWR
        tmp_value = PyInt_FromLong(ns3::TcpHeader::CWR);
        PyDict_SetItemString((PyObject*) PyNs3TcpHeader_Type.tp_dict, "CWR", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::ArpHeader::ARP_TYPE_REQUEST
        tmp_value = PyInt_FromLong(ns3::ArpHeader::ARP_TYPE_REQUEST);
        PyDict_SetItemString((PyObject*) PyNs3ArpHeader_Type.tp_dict, "ARP_TYPE_REQUEST", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::ArpHeader::ARP_TYPE_REPLY
        tmp_value = PyInt_FromLong(ns3::ArpHeader::ARP_TYPE_REPLY);
        PyDict_SetItemString((PyObject*) PyNs3ArpHeader_Type.tp_dict, "ARP_TYPE_REPLY", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::IpL4Protocol::RX_OK
        tmp_value = PyInt_FromLong(ns3::IpL4Protocol::RX_OK);
        PyDict_SetItemString((PyObject*) PyNs3IpL4Protocol_Type.tp_dict, "RX_OK", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::IpL4Protocol::RX_CSUM_FAILED
        tmp_value = PyInt_FromLong(ns3::IpL4Protocol::RX_CSUM_FAILED);
        PyDict_SetItemString((PyObject*) PyNs3IpL4Protocol_Type.tp_dict, "RX_CSUM_FAILED", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::IpL4Protocol::RX_ENDPOINT_CLOSED
        tmp_value = PyInt_FromLong(ns3::IpL4Protocol::RX_ENDPOINT_CLOSED);
        PyDict_SetItemString((PyObject*) PyNs3IpL4Protocol_Type.tp_dict, "RX_ENDPOINT_CLOSED", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::IpL4Protocol::RX_ENDPOINT_UNREACH
        tmp_value = PyInt_FromLong(ns3::IpL4Protocol::RX_ENDPOINT_UNREACH);
        PyDict_SetItemString((PyObject*) PyNs3IpL4Protocol_Type.tp_dict, "RX_ENDPOINT_UNREACH", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Ipv4L3Protocol::DROP_TTL_EXPIRED
        tmp_value = PyInt_FromLong(ns3::Ipv4L3Protocol::DROP_TTL_EXPIRED);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4L3Protocol_Type.tp_dict, "DROP_TTL_EXPIRED", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4L3Protocol::DROP_NO_ROUTE
        tmp_value = PyInt_FromLong(ns3::Ipv4L3Protocol::DROP_NO_ROUTE);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4L3Protocol_Type.tp_dict, "DROP_NO_ROUTE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4L3Protocol::DROP_BAD_CHECKSUM
        tmp_value = PyInt_FromLong(ns3::Ipv4L3Protocol::DROP_BAD_CHECKSUM);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4L3Protocol_Type.tp_dict, "DROP_BAD_CHECKSUM", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4L3Protocol::DROP_INTERFACE_DOWN
        tmp_value = PyInt_FromLong(ns3::Ipv4L3Protocol::DROP_INTERFACE_DOWN);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4L3Protocol_Type.tp_dict, "DROP_INTERFACE_DOWN", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4L3Protocol::DROP_ROUTE_ERROR
        tmp_value = PyInt_FromLong(ns3::Ipv4L3Protocol::DROP_ROUTE_ERROR);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4L3Protocol_Type.tp_dict, "DROP_ROUTE_ERROR", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv4L3Protocol::DROP_FRAGMENT_TIMEOUT
        tmp_value = PyInt_FromLong(ns3::Ipv4L3Protocol::DROP_FRAGMENT_TIMEOUT);
        PyDict_SetItemString((PyObject*) PyNs3Ipv4L3Protocol_Type.tp_dict, "DROP_FRAGMENT_TIMEOUT", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::Ipv6L3Protocol::DROP_TTL_EXPIRED
        tmp_value = PyInt_FromLong(ns3::Ipv6L3Protocol::DROP_TTL_EXPIRED);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6L3Protocol_Type.tp_dict, "DROP_TTL_EXPIRED", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6L3Protocol::DROP_NO_ROUTE
        tmp_value = PyInt_FromLong(ns3::Ipv6L3Protocol::DROP_NO_ROUTE);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6L3Protocol_Type.tp_dict, "DROP_NO_ROUTE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6L3Protocol::DROP_INTERFACE_DOWN
        tmp_value = PyInt_FromLong(ns3::Ipv6L3Protocol::DROP_INTERFACE_DOWN);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6L3Protocol_Type.tp_dict, "DROP_INTERFACE_DOWN", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6L3Protocol::DROP_ROUTE_ERROR
        tmp_value = PyInt_FromLong(ns3::Ipv6L3Protocol::DROP_ROUTE_ERROR);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6L3Protocol_Type.tp_dict, "DROP_ROUTE_ERROR", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::Ipv6L3Protocol::DROP_UNKNOWN_PROTOCOL
        tmp_value = PyInt_FromLong(ns3::Ipv6L3Protocol::DROP_UNKNOWN_PROTOCOL);
        PyDict_SetItemString((PyObject*) PyNs3Ipv6L3Protocol_Type.tp_dict, "DROP_UNKNOWN_PROTOCOL", tmp_value);
        Py_DECREF(tmp_value);
    }
    submodule = initinternet_FatalImpl();
    if (submodule == NULL) {
        return;
    }
    Py_INCREF(submodule);
    PyModule_AddObject(m, (char *) "FatalImpl", submodule);
}
