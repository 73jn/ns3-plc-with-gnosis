# 1 "netinet/ip_icmp.c"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "/usr/obj/usr/src/sys/GENERIC/opt_global.h" 1
# 2 "<command line>" 2
# 1 "netinet/ip_icmp.c"
# 37 "netinet/ip_icmp.c"
# 1 "/usr/obj/usr/src/sys/GENERIC/opt_ipsec.h" 1
# 38 "netinet/ip_icmp.c" 2
# 1 "/usr/obj/usr/src/sys/GENERIC/opt_mac.h" 1
# 39 "netinet/ip_icmp.c" 2

# 1 "/usr/src/sys/sys/param.h" 1
# 65 "/usr/src/sys/sys/param.h"
# 1 "/usr/src/sys/sys/types.h" 1
# 45 "/usr/src/sys/sys/types.h"
# 1 "/usr/src/sys/sys/cdefs.h" 1
# 46 "/usr/src/sys/sys/types.h" 2


# 1 "/usr/obj/usr/src/sys/GENERIC/machine/endian.h" 1
# 41 "/usr/obj/usr/src/sys/GENERIC/machine/endian.h"
# 1 "/usr/src/sys/sys/_types.h" 1
# 33 "/usr/src/sys/sys/_types.h"
# 1 "/usr/obj/usr/src/sys/GENERIC/machine/_types.h" 1
# 45 "/usr/obj/usr/src/sys/GENERIC/machine/_types.h"
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;







typedef int __attribute__((__mode__(__DI__))) __int64_t;
typedef unsigned int __attribute__((__mode__(__DI__))) __uint64_t;
# 70 "/usr/obj/usr/src/sys/GENERIC/machine/_types.h"
typedef unsigned long __clock_t;
typedef __int32_t __critical_t;
typedef __int32_t __intfptr_t;
typedef __int64_t __intmax_t;
typedef __int32_t __intptr_t;
typedef __int32_t __int_fast8_t;
typedef __int32_t __int_fast16_t;
typedef __int32_t __int_fast32_t;
typedef __int64_t __int_fast64_t;
typedef __int8_t __int_least8_t;
typedef __int16_t __int_least16_t;
typedef __int32_t __int_least32_t;
typedef __int64_t __int_least64_t;
typedef __int32_t __ptrdiff_t;
typedef __int32_t __register_t;
typedef __int32_t __segsz_t;
typedef __uint32_t __size_t;
typedef __int32_t __ssize_t;
typedef __int32_t __time_t;
typedef __uint32_t __uintfptr_t;
typedef __uint64_t __uintmax_t;
typedef __uint32_t __uintptr_t;
typedef __uint32_t __uint_fast8_t;
typedef __uint32_t __uint_fast16_t;
typedef __uint32_t __uint_fast32_t;
typedef __uint64_t __uint_fast64_t;
typedef __uint8_t __uint_least8_t;
typedef __uint16_t __uint_least16_t;
typedef __uint32_t __uint_least32_t;
typedef __uint64_t __uint_least64_t;
typedef __uint32_t __u_register_t;
typedef __uint32_t __vm_offset_t;
typedef __int64_t __vm_ooffset_t;
typedef __uint64_t __vm_pindex_t;
typedef __uint32_t __vm_size_t;





typedef __builtin_va_list __va_list;





typedef __va_list __gnuc_va_list;
# 34 "/usr/src/sys/sys/_types.h" 2




typedef __int32_t __clockid_t;
typedef __uint32_t __fflags_t;
typedef __uint64_t __fsblkcnt_t;
typedef __uint64_t __fsfilcnt_t;
typedef __uint32_t __gid_t;
typedef __int64_t __id_t;
typedef long __key_t;
typedef __uint16_t __mode_t;
typedef int __nl_item;
typedef __int64_t __off_t;
typedef __int32_t __pid_t;
typedef __int64_t __rlim_t;
typedef __uint8_t __sa_family_t;
typedef __uint32_t __socklen_t;
typedef __int32_t __timer_t;
typedef __uint32_t __uid_t;
# 73 "/usr/src/sys/sys/_types.h"
typedef int __ct_rune_t;
typedef __ct_rune_t __rune_t;
typedef __ct_rune_t __wchar_t;
typedef __ct_rune_t __wint_t;





typedef union {
        char __mbstate8[128];
        __int64_t _mbstateL;
} __mbstate_t;
# 42 "/usr/obj/usr/src/sys/GENERIC/machine/endian.h" 2
# 97 "/usr/obj/usr/src/sys/GENERIC/machine/endian.h"
static __inline __uint64_t
__bswap64(__uint64_t _x)
{
        return ((_x >> 56) | ((_x >> 40) & 0xff00) | ((_x >> 24) & 0xff0000) |
            ((_x >> 8) & 0xff000000) | ((_x << 8) & ((__uint64_t)0xff << 32)) |
            ((_x << 24) & ((__uint64_t)0xff << 40)) |
            ((_x << 40) & ((__uint64_t)0xff << 48)) | ((_x << 56)));
}

static __inline __uint32_t
__bswap32(__uint32_t _x)
{

        return (__extension__ ({ register __uint32_t __X = (_x); __asm ("bswap %0" : "+r" (__X)); __X; }));
}

static __inline __uint16_t
__bswap16(__uint16_t _x)
{

        return (__extension__ ({ register __uint16_t __X = (_x); __asm ("xchgb %h0, %b0" : "+q" (__X)); __X; }));
}
# 49 "/usr/src/sys/sys/types.h" 2



typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned short ushort;
typedef unsigned int uint;






typedef __int8_t int8_t;




typedef __int16_t int16_t;




typedef __int32_t int32_t;




typedef __int64_t int64_t;




typedef __uint8_t uint8_t;




typedef __uint16_t uint16_t;




typedef __uint32_t uint32_t;




typedef __uint64_t uint64_t;




typedef __intptr_t intptr_t;
typedef __uintptr_t uintptr_t;



typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;

typedef __uint64_t u_quad_t;
typedef __int64_t quad_t;
typedef quad_t * qaddr_t;

typedef char * caddr_t;
typedef const char * c_caddr_t;
typedef volatile char *v_caddr_t;
typedef __critical_t critical_t;
typedef __int64_t daddr_t;
typedef __uint32_t fixpt_t;


typedef __gid_t gid_t;




typedef __uint32_t in_addr_t;




typedef __uint16_t in_port_t;




typedef __id_t id_t;



typedef __uint32_t ino_t;


typedef __key_t key_t;




typedef __mode_t mode_t;



typedef __uint16_t nlink_t;


typedef __off_t off_t;




typedef __pid_t pid_t;



typedef __register_t register_t;


typedef __rlim_t rlim_t;



typedef __segsz_t segsz_t;
typedef __u_register_t u_register_t;


typedef __uid_t uid_t;



typedef __vm_offset_t vm_offset_t;
typedef __vm_ooffset_t vm_ooffset_t;
typedef __vm_pindex_t vm_pindex_t;
typedef __vm_size_t vm_size_t;


typedef int boolean_t;
typedef __intfptr_t intfptr_t;
# 201 "/usr/src/sys/sys/types.h"
typedef __uint32_t intrmask_t;

typedef __uintfptr_t uintfptr_t;
typedef __uint64_t uoff_t;
typedef struct vm_page *vm_page_t;

struct cdev;

typedef __uint32_t udev_t;
typedef struct cdev *dev_t;
# 222 "/usr/src/sys/sys/types.h"
typedef __clock_t clock_t;




typedef __clockid_t clockid_t;




typedef __fflags_t fflags_t;




typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;




typedef __size_t size_t;




typedef __ssize_t ssize_t;




typedef __time_t time_t;




typedef __timer_t timer_t;
# 268 "/usr/src/sys/sys/types.h"
# 1 "/usr/src/sys/sys/select.h" 1
# 42 "/usr/src/sys/sys/select.h"
# 1 "/usr/src/sys/sys/_sigset.h" 1
# 55 "/usr/src/sys/sys/_sigset.h"
typedef struct __sigset {
        __uint32_t __bits[4];
} __sigset_t;
# 43 "/usr/src/sys/sys/select.h" 2
# 1 "/usr/src/sys/sys/timespec.h" 1
# 50 "/usr/src/sys/sys/timespec.h"
struct timespec {
        time_t tv_sec;
        long tv_nsec;
};
# 44 "/usr/src/sys/sys/select.h" 2
# 52 "/usr/src/sys/sys/select.h"
typedef unsigned long __fd_mask;

typedef __fd_mask fd_mask;




typedef __sigset_t sigset_t;
# 81 "/usr/src/sys/sys/select.h"
typedef struct fd_set {
        __fd_mask __fds_bits[(((1024U) + (((sizeof(__fd_mask) * 8)) - 1)) / ((sizeof(__fd_mask) * 8)))];
} fd_set;
# 269 "/usr/src/sys/sys/types.h" 2
# 66 "/usr/src/sys/sys/param.h" 2
# 75 "/usr/src/sys/sys/param.h"
# 1 "/usr/src/sys/sys/syslimits.h" 1
# 76 "/usr/src/sys/sys/param.h" 2
# 91 "/usr/src/sys/sys/param.h"
# 1 "/usr/src/sys/sys/errno.h" 1
# 92 "/usr/src/sys/sys/param.h" 2
# 1 "/usr/src/sys/sys/time.h" 1
# 47 "/usr/src/sys/sys/time.h"
struct timeval {
        long tv_sec;
        long tv_usec;
};

struct timezone {
        int tz_minuteswest;
        int tz_dsttime;
};
# 65 "/usr/src/sys/sys/time.h"
struct bintime {
        time_t sec;
        uint64_t frac;
};

static __inline void
bintime_addx(struct bintime *bt, uint64_t x)
{
        uint64_t u;

        u = bt->frac;
        bt->frac += x;
        if (u > bt->frac)
                bt->sec++;
}

static __inline void
bintime_add(struct bintime *bt, struct bintime *bt2)
{
        uint64_t u;

        u = bt->frac;
        bt->frac += bt2->frac;
        if (u > bt->frac)
                bt->sec++;
        bt->sec += bt2->sec;
}

static __inline void
bintime_sub(struct bintime *bt, struct bintime *bt2)
{
        uint64_t u;

        u = bt->frac;
        bt->frac -= bt2->frac;
        if (u < bt->frac)
                bt->sec--;
        bt->sec -= bt2->sec;
}
# 119 "/usr/src/sys/sys/time.h"
static __inline void
bintime2timespec(struct bintime *bt, struct timespec *ts)
{

        ts->tv_sec = bt->sec;
        ts->tv_nsec = ((uint64_t)1000000000 * (uint32_t)(bt->frac >> 32)) >> 32;
}

static __inline void
timespec2bintime(struct timespec *ts, struct bintime *bt)
{

        bt->sec = ts->tv_sec;

        bt->frac = ts->tv_nsec * (uint64_t)18446744073LL;
}

static __inline void
bintime2timeval(struct bintime *bt, struct timeval *tv)
{

        tv->tv_sec = bt->sec;
        tv->tv_usec = ((uint64_t)1000000 * (uint32_t)(bt->frac >> 32)) >> 32;
}

static __inline void
timeval2bintime(struct timeval *tv, struct bintime *bt)
{

        bt->sec = tv->tv_sec;

        bt->frac = tv->tv_usec * (uint64_t)18446744073709LL;
}
# 231 "/usr/src/sys/sys/time.h"
struct itimerval {
        struct timeval it_interval;
        struct timeval it_value;
};




struct clockinfo {
        int hz;
        int tick;
        int spare;
        int stathz;
        int profhz;
};
# 261 "/usr/src/sys/sys/time.h"
extern time_t time_second;
extern time_t time_uptime;
# 286 "/usr/src/sys/sys/time.h"
void binuptime(struct bintime *bt);
void nanouptime(struct timespec *tsp);
void microuptime(struct timeval *tvp);

void bintime(struct bintime *bt);
void nanotime(struct timespec *tsp);
void microtime(struct timeval *tvp);

void getbinuptime(struct bintime *bt);
void getnanouptime(struct timespec *tsp);
void getmicrouptime(struct timeval *tvp);

void getbintime(struct bintime *bt);
void getnanotime(struct timespec *tsp);
void getmicrotime(struct timeval *tvp);


int itimerdecr(struct itimerval *itp, int usec);
int itimerfix(struct timeval *tv);
void timevaladd(struct timeval *t1, struct timeval *t2);
void timevalsub(struct timeval *t1, struct timeval *t2);
int tvtohz(struct timeval *tv);
# 93 "/usr/src/sys/sys/param.h" 2
# 1 "/usr/src/sys/sys/priority.h" 1
# 123 "/usr/src/sys/sys/priority.h"
struct priority {
        u_char pri_class;
        u_char pri_level;
        u_char pri_native;
        u_char pri_user;
};
# 94 "/usr/src/sys/sys/param.h" 2
# 105 "/usr/src/sys/sys/param.h"
# 1 "/usr/obj/usr/src/sys/GENERIC/machine/param.h" 1
# 106 "/usr/src/sys/sys/param.h" 2
# 266 "/usr/src/sys/sys/param.h"

__uint32_t htonl(__uint32_t);
__uint16_t htons(__uint16_t);
__uint32_t ntohl(__uint32_t);
__uint16_t ntohs(__uint16_t);

# 41 "netinet/ip_icmp.c" 2
# 1 "/usr/src/sys/sys/systm.h" 1
# 45 "/usr/src/sys/sys/systm.h"
# 1 "/usr/obj/usr/src/sys/GENERIC/machine/atomic.h" 1
# 148 "/usr/obj/usr/src/sys/GENERIC/machine/atomic.h"
static __inline int
atomic_cmpset_int(volatile u_int *dst, u_int exp, u_int src)
{
        int res = exp;

        __asm volatile (
        "	" "" "	"
        "	cmpxchgl %1,%2 ;	"
        "       setz	%%al ;		"
        "	movzbl	%%al,%0 ;	"
        "1:				"
        "# atomic_cmpset_int"
        : "+a" (res)
        : "r" (src),
          "m" (*(dst))
        : "memory");

        return (res);
}
# 238 "/usr/obj/usr/src/sys/GENERIC/machine/atomic.h"
static __inline void atomic_set_char(volatile u_char *p, u_char v){ __asm volatile("" "orb %b1,%0" : "+m" (*p) : "iq" (v)); };
static __inline void atomic_clear_char(volatile u_char *p, u_char v){ __asm volatile("" "andb %b1,%0" : "+m" (*p) : "iq" (~v)); };
static __inline void atomic_add_char(volatile u_char *p, u_char v){ __asm volatile("" "addb %b1,%0" : "+m" (*p) : "iq" (v)); };
static __inline void atomic_subtract_char(volatile u_char *p, u_char v){ __asm volatile("" "subb %b1,%0" : "+m" (*p) : "iq" (v)); };

static __inline void atomic_set_short(volatile u_short *p, u_short v){ __asm volatile("" "orw %w1,%0" : "+m" (*p) : "ir" (v)); };
static __inline void atomic_clear_short(volatile u_short *p, u_short v){ __asm volatile("" "andw %w1,%0" : "+m" (*p) : "ir" (~v)); };
static __inline void atomic_add_short(volatile u_short *p, u_short v){ __asm volatile("" "addw %w1,%0" : "+m" (*p) : "ir" (v)); };
static __inline void atomic_subtract_short(volatile u_short *p, u_short v){ __asm volatile("" "subw %w1,%0" : "+m" (*p) : "ir" (v)); };

static __inline void atomic_set_int(volatile u_int *p, u_int v){ __asm volatile("" "orl %1,%0" : "+m" (*p) : "ir" (v)); };
static __inline void atomic_clear_int(volatile u_int *p, u_int v){ __asm volatile("" "andl %1,%0" : "+m" (*p) : "ir" (~v)); };
static __inline void atomic_add_int(volatile u_int *p, u_int v){ __asm volatile("" "addl %1,%0" : "+m" (*p) : "ir" (v)); };
static __inline void atomic_subtract_int(volatile u_int *p, u_int v){ __asm volatile("" "subl %1,%0" : "+m" (*p) : "ir" (v)); };

static __inline void atomic_set_long(volatile u_long *p, u_long v){ __asm volatile("" "orl %1,%0" : "+m" (*p) : "ir" (v)); };
static __inline void atomic_clear_long(volatile u_long *p, u_long v){ __asm volatile("" "andl %1,%0" : "+m" (*p) : "ir" (~v)); };
static __inline void atomic_add_long(volatile u_long *p, u_long v){ __asm volatile("" "addl %1,%0" : "+m" (*p) : "ir" (v)); };
static __inline void atomic_subtract_long(volatile u_long *p, u_long v){ __asm volatile("" "subl %1,%0" : "+m" (*p) : "ir" (v)); };

static __inline u_char atomic_load_acq_char(volatile u_char *p) { u_char res; __asm volatile("" "cmpxchgb %b0,%1" : "=a" (res), "+m" (*p) : : "memory"); return (res); } static __inline void atomic_store_rel_char(volatile u_char *p, u_char v){ __asm volatile("xchgb %b1,%0" : "+m" (*p), "+r" (v) : : "memory"); };
static __inline u_short atomic_load_acq_short(volatile u_short *p) { u_short res; __asm volatile("" "cmpxchgw %w0,%1" : "=a" (res), "+m" (*p) : : "memory"); return (res); } static __inline void atomic_store_rel_short(volatile u_short *p, u_short v){ __asm volatile("xchgw %w1,%0" : "+m" (*p), "+r" (v) : : "memory"); };
static __inline u_int atomic_load_acq_int(volatile u_int *p) { u_int res; __asm volatile("" "cmpxchgl %0,%1" : "=a" (res), "+m" (*p) : : "memory"); return (res); } static __inline void atomic_store_rel_int(volatile u_int *p, u_int v){ __asm volatile("xchgl %1,%0" : "+m" (*p), "+r" (v) : : "memory"); };
static __inline u_long atomic_load_acq_long(volatile u_long *p) { u_long res; __asm volatile("" "cmpxchgl %0,%1" : "=a" (res), "+m" (*p) : : "memory"); return (res); } static __inline void atomic_store_rel_long(volatile u_long *p, u_long v){ __asm volatile("xchgl %1,%0" : "+m" (*p), "+r" (v) : : "memory"); };
# 360 "/usr/obj/usr/src/sys/GENERIC/machine/atomic.h"
static __inline int
atomic_cmpset_ptr(volatile void *dst, void *exp, void *src)
{

        return (atomic_cmpset_int((volatile u_int *)dst, (u_int)exp,
            (u_int)src));
}

static __inline void *
atomic_load_acq_ptr(volatile void *p)
{
        return (void *)atomic_load_acq_int((volatile u_int *)p);
}

static __inline void
atomic_store_rel_ptr(volatile void *p, void *v)
{
        atomic_store_rel_int((volatile u_int *)p, (u_int)v);
}
# 399 "/usr/obj/usr/src/sys/GENERIC/machine/atomic.h"
static __inline void atomic_set_ptr(volatile void *p, uintptr_t v) { atomic_set_int((volatile u_int *)p, v); } static __inline void atomic_set_acq_ptr(volatile void *p, uintptr_t v) { atomic_set_int((volatile u_int *)p, v);} static __inline void atomic_set_rel_ptr(volatile void *p, uintptr_t v) { atomic_set_int((volatile u_int *)p, v);}
static __inline void atomic_clear_ptr(volatile void *p, uintptr_t v) { atomic_clear_int((volatile u_int *)p, v); } static __inline void atomic_clear_acq_ptr(volatile void *p, uintptr_t v) { atomic_clear_int((volatile u_int *)p, v);} static __inline void atomic_clear_rel_ptr(volatile void *p, uintptr_t v) { atomic_clear_int((volatile u_int *)p, v);}
static __inline void atomic_add_ptr(volatile void *p, uintptr_t v) { atomic_add_int((volatile u_int *)p, v); } static __inline void atomic_add_acq_ptr(volatile void *p, uintptr_t v) { atomic_add_int((volatile u_int *)p, v);} static __inline void atomic_add_rel_ptr(volatile void *p, uintptr_t v) { atomic_add_int((volatile u_int *)p, v);}
static __inline void atomic_subtract_ptr(volatile void *p, uintptr_t v) { atomic_subtract_int((volatile u_int *)p, v); } static __inline void atomic_subtract_acq_ptr(volatile void *p, uintptr_t v) { atomic_subtract_int((volatile u_int *)p, v);} static __inline void atomic_subtract_rel_ptr(volatile void *p, uintptr_t v) { atomic_subtract_int((volatile u_int *)p, v);}





static __inline u_int
atomic_readandclear_int(volatile u_int *addr)
{
        u_int result;

        __asm volatile (
        "	xorl	%0,%0 ;		"
        "	xchgl	%1,%0 ;		"
        "# atomic_readandclear_int"
        : "=&r" (result)
        : "m" (*addr));

        return (result);
}

static __inline u_long
atomic_readandclear_long(volatile u_long *addr)
{
        u_long result;

        __asm volatile (
        "	xorl	%0,%0 ;		"
        "	xchgl	%1,%0 ;		"
        "# atomic_readandclear_int"
        : "=&r" (result)
        : "m" (*addr));

        return (result);
}
# 46 "/usr/src/sys/sys/systm.h" 2
# 1 "/usr/obj/usr/src/sys/GENERIC/machine/cpufunc.h" 1
# 46 "/usr/obj/usr/src/sys/GENERIC/machine/cpufunc.h"
# 1 "/usr/obj/usr/src/sys/GENERIC/machine/psl.h" 1
# 47 "/usr/obj/usr/src/sys/GENERIC/machine/cpufunc.h" 2

struct thread;
struct region_descriptor;


# 62 "/usr/obj/usr/src/sys/GENERIC/machine/cpufunc.h"
static __inline void
breakpoint(void)
{
        __asm volatile("int $3");
}

static __inline u_int
bsfl(u_int mask)
{
        u_int result;

        __asm volatile("bsfl %1,%0" : "=r" (result) : "rm" (mask));
        return (result);
}

static __inline u_int
bsrl(u_int mask)
{
        u_int result;

        __asm volatile("bsrl %1,%0" : "=r" (result) : "rm" (mask));
        return (result);
}

static __inline void
disable_intr(void)
{
        __asm volatile("cli" : : : "memory");
}

static __inline void
do_cpuid(u_int ax, u_int *p)
{
        __asm volatile("cpuid"
                         : "=a" (p[0]), "=b" (p[1]), "=c" (p[2]), "=d" (p[3])
                         : "0" (ax));
}

static __inline void
enable_intr(void)
{
        __asm volatile("sti");
}



static __inline int
ffs(int mask)
{






         return (mask == 0 ? mask : (int)bsfl((u_int)mask) + 1);
}



static __inline int
fls(int mask)
{
        return (mask == 0 ? mask : (int)bsrl((u_int)mask) + 1);
}

static __inline void
halt(void)
{
        __asm volatile("hlt");
}
# 171 "/usr/obj/usr/src/sys/GENERIC/machine/cpufunc.h"
static __inline u_char
inbc(u_int port)
{
        u_char data;

        __asm volatile("inb %1,%0" : "=a" (data) : "id" ((u_short)(port)));
        return (data);
}

static __inline void
outbc(u_int port, u_char data)
{
        __asm volatile("outb %0,%1" : : "a" (data), "id" ((u_short)(port)));
}



static __inline u_char
inbv(u_int port)
{
        u_char data;





        __asm volatile("inb %%dx,%0" : "=a" (data) : "d" (port));
        return (data);
}

static __inline u_int
inl(u_int port)
{
        u_int data;

        __asm volatile("inl %%dx,%0" : "=a" (data) : "d" (port));
        return (data);
}

static __inline void
insb(u_int port, void *addr, size_t cnt)
{
        __asm volatile("cld; rep; insb"
                         : "+D" (addr), "+c" (cnt)
                         : "d" (port)
                         : "memory");
}

static __inline void
insw(u_int port, void *addr, size_t cnt)
{
        __asm volatile("cld; rep; insw"
                         : "+D" (addr), "+c" (cnt)
                         : "d" (port)
                         : "memory");
}

static __inline void
insl(u_int port, void *addr, size_t cnt)
{
        __asm volatile("cld; rep; insl"
                         : "+D" (addr), "+c" (cnt)
                         : "d" (port)
                         : "memory");
}

static __inline void
invd(void)
{
        __asm volatile("invd");
}

static __inline u_short
inw(u_int port)
{
        u_short data;

        __asm volatile("inw %%dx,%0" : "=a" (data) : "d" (port));
        return (data);
}

static __inline void
outbv(u_int port, u_char data)
{
        u_char al;






        al = data;
        __asm volatile("outb %0,%%dx" : : "a" (al), "d" (port));
}

static __inline void
outl(u_int port, u_int data)
{





        __asm volatile("outl %0,%%dx" : : "a" (data), "d" (port));
}

static __inline void
outsb(u_int port, const void *addr, size_t cnt)
{
        __asm volatile("cld; rep; outsb"
                         : "+S" (addr), "+c" (cnt)
                         : "d" (port));
}

static __inline void
outsw(u_int port, const void *addr, size_t cnt)
{
        __asm volatile("cld; rep; outsw"
                         : "+S" (addr), "+c" (cnt)
                         : "d" (port));
}

static __inline void
outsl(u_int port, const void *addr, size_t cnt)
{
        __asm volatile("cld; rep; outsl"
                         : "+S" (addr), "+c" (cnt)
                         : "d" (port));
}

static __inline void
outw(u_int port, u_short data)
{
        __asm volatile("outw %0,%%dx" : : "a" (data), "d" (port));
}

static __inline void
ia32_pause(void)
{
        __asm volatile("pause");
}

static __inline u_int
read_eflags(void)
{
        u_int ef;

        __asm volatile("pushfl; popl %0" : "=r" (ef));
        return (ef);
}

static __inline u_int64_t
rdmsr(u_int msr)
{
        u_int64_t rv;

        __asm volatile("rdmsr" : "=A" (rv) : "c" (msr));
        return (rv);
}

static __inline u_int64_t
rdpmc(u_int pmc)
{
        u_int64_t rv;

        __asm volatile("rdpmc" : "=A" (rv) : "c" (pmc));
        return (rv);
}

static __inline u_int64_t
rdtsc(void)
{
        u_int64_t rv;

        __asm volatile("rdtsc" : "=A" (rv));
        return (rv);
}

static __inline void
wbinvd(void)
{
        __asm volatile("wbinvd");
}

static __inline void
write_eflags(u_int ef)
{
        __asm volatile("pushl %0; popfl" : : "r" (ef));
}

static __inline void
wrmsr(u_int msr, u_int64_t newval)
{
        __asm volatile("wrmsr" : : "A" (newval), "c" (msr));
}

static __inline void
load_cr0(u_int data)
{

        __asm volatile("movl %0,%%cr0" : : "r" (data));
}

static __inline u_int
rcr0(void)
{
        u_int data;

        __asm volatile("movl %%cr0,%0" : "=r" (data));
        return (data);
}

static __inline u_int
rcr2(void)
{
        u_int data;

        __asm volatile("movl %%cr2,%0" : "=r" (data));
        return (data);
}

static __inline void
load_cr3(u_int data)
{

        __asm volatile("movl %0,%%cr3" : : "r" (data) : "memory");
}

static __inline u_int
rcr3(void)
{
        u_int data;

        __asm volatile("movl %%cr3,%0" : "=r" (data));
        return (data);
}

static __inline void
load_cr4(u_int data)
{
        __asm volatile("movl %0,%%cr4" : : "r" (data));
}

static __inline u_int
rcr4(void)
{
        u_int data;

        __asm volatile("movl %%cr4,%0" : "=r" (data));
        return (data);
}




static __inline void
invltlb(void)
{

        load_cr3(rcr3());
}





static __inline void
invlpg(u_int addr)
{

        __asm volatile("invlpg %0" : : "m" (*(char *)addr) : "memory");
}

static __inline u_int
rfs(void)
{
        u_int sel;
        __asm volatile("movl %%fs,%0" : "=rm" (sel));
        return (sel);
}

static __inline u_int
rgs(void)
{
        u_int sel;
        __asm volatile("movl %%gs,%0" : "=rm" (sel));
        return (sel);
}

static __inline void
load_fs(u_int sel)
{
        __asm volatile("movl %0,%%fs" : : "rm" (sel));
}

static __inline void
load_gs(u_int sel)
{
        __asm volatile("movl %0,%%gs" : : "rm" (sel));
}


static __inline void
lidt(struct region_descriptor *addr)
{
        __asm volatile("lidt (%0)" : : "r" (addr));
}


static __inline void
lldt(u_short sel)
{
        __asm volatile("lldt %0" : : "r" (sel));
}


static __inline void
ltr(u_short sel)
{
        __asm volatile("ltr %0" : : "r" (sel));
}

static __inline u_int
rdr0(void)
{
        u_int data;
        __asm volatile("movl %%dr0,%0" : "=r" (data));
        return (data);
}

static __inline void
load_dr0(u_int dr0)
{
        __asm volatile("movl %0,%%dr0" : : "r" (dr0));
}

static __inline u_int
rdr1(void)
{
        u_int data;
        __asm volatile("movl %%dr1,%0" : "=r" (data));
        return (data);
}

static __inline void
load_dr1(u_int dr1)
{
        __asm volatile("movl %0,%%dr1" : : "r" (dr1));
}

static __inline u_int
rdr2(void)
{
        u_int data;
        __asm volatile("movl %%dr2,%0" : "=r" (data));
        return (data);
}

static __inline void
load_dr2(u_int dr2)
{
        __asm volatile("movl %0,%%dr2" : : "r" (dr2));
}

static __inline u_int
rdr3(void)
{
        u_int data;
        __asm volatile("movl %%dr3,%0" : "=r" (data));
        return (data);
}

static __inline void
load_dr3(u_int dr3)
{
        __asm volatile("movl %0,%%dr3" : : "r" (dr3));
}

static __inline u_int
rdr4(void)
{
        u_int data;
        __asm volatile("movl %%dr4,%0" : "=r" (data));
        return (data);
}

static __inline void
load_dr4(u_int dr4)
{
        __asm volatile("movl %0,%%dr4" : : "r" (dr4));
}

static __inline u_int
rdr5(void)
{
        u_int data;
        __asm volatile("movl %%dr5,%0" : "=r" (data));
        return (data);
}

static __inline void
load_dr5(u_int dr5)
{
        __asm volatile("movl %0,%%dr5" : : "r" (dr5));
}

static __inline u_int
rdr6(void)
{
        u_int data;
        __asm volatile("movl %%dr6,%0" : "=r" (data));
        return (data);
}

static __inline void
load_dr6(u_int dr6)
{
        __asm volatile("movl %0,%%dr6" : : "r" (dr6));
}

static __inline u_int
rdr7(void)
{
        u_int data;
        __asm volatile("movl %%dr7,%0" : "=r" (data));
        return (data);
}

static __inline void
load_dr7(u_int dr7)
{
        __asm volatile("movl %0,%%dr7" : : "r" (dr7));
}

static __inline register_t
intr_disable(void)
{
        register_t eflags;

        eflags = read_eflags();
        disable_intr();
        return (eflags);
}

static __inline void
intr_restore(register_t eflags)
{
        write_eflags(eflags);
}
# 692 "/usr/obj/usr/src/sys/GENERIC/machine/cpufunc.h"
void reset_dbregs(void);


# 47 "/usr/src/sys/sys/systm.h" 2
# 1 "/usr/src/sys/sys/callout.h" 1
# 45 "/usr/src/sys/sys/callout.h"
# 1 "/usr/src/sys/sys/queue.h" 1
# 491 "/usr/src/sys/sys/queue.h"
struct quehead {
        struct quehead *qh_link;
        struct quehead *qh_rlink;
};



static __inline void
insque(void *a, void *b)
{
        struct quehead *element = (struct quehead *)a,
                 *head = (struct quehead *)b;

        element->qh_link = head->qh_link;
        element->qh_rlink = head;
        head->qh_link = element;
        element->qh_link->qh_rlink = element;
}

static __inline void
remque(void *a)
{
        struct quehead *element = (struct quehead *)a;

        element->qh_link->qh_rlink = element->qh_rlink;
        element->qh_rlink->qh_link = element->qh_link;
        element->qh_rlink = 0;
}
# 46 "/usr/src/sys/sys/callout.h" 2

struct callout_list { struct callout *slh_first; };
struct callout_tailq { struct callout *tqh_first; struct callout **tqh_last; };

struct callout {
        union {
                struct { struct callout *sle_next; } sle;
                struct { struct callout *tqe_next; struct callout **tqe_prev; } tqe;
        } c_links;
        int c_time;
        void *c_arg;
        void (*c_func)(void *);
        int c_flags;
};






struct callout_handle {
        struct callout *callout;
};


extern struct callout_list callfree;
extern struct callout *callout;
extern int ncallout;
extern struct callout_tailq *callwheel;
extern int callwheelsize, callwheelbits, callwheelmask, softticks;
extern struct mtx callout_lock;



void callout_init(struct callout *, int);

void callout_reset(struct callout *, int, void (*)(void *), void *);
int callout_stop(struct callout *);
# 48 "/usr/src/sys/sys/systm.h" 2


extern int securelevel;
extern int suser_enabled;

extern int cold;
extern const char *panicstr;
extern char version[];
extern char copyright[];
extern int kstack_pages;
extern int uarea_pages;

extern int nswap;

extern u_int nselcoll;
extern struct mtx sellock;
extern struct cv selwait;

extern long physmem;

extern dev_t rootdev;
extern dev_t rootdevs[2];
extern char *rootdevnames[2];
extern struct vnode *rootvp;

extern int boothowto;
extern int bootverbose;

extern int maxusers;
# 94 "/usr/src/sys/sys/systm.h"
extern int envmode;
extern int hintmode;
extern int dynamic_kenv;
extern struct sx kenv_lock;
extern char *kern_envp;
extern char static_env[];
extern char static_hints[];

extern char **kenvp;





struct clockframe;
struct malloc_type;
struct mtx;
struct proc;
struct kse;
struct socket;
struct thread;
struct tty;
struct ucred;
struct uio;
struct _jmp_buf;

int setjmp(struct _jmp_buf *);
void longjmp(struct _jmp_buf *, int) __attribute__((__noreturn__));
void Debugger(const char *msg);
int dumpstatus(vm_offset_t addr, off_t count);
int nullop(void);
int eopnotsupp(void);
int seltrue(dev_t dev, int which, struct thread *td);
int ureadc(int, struct uio *);
void hashdestroy(void *, struct malloc_type *, u_long);
void *hashinit(int count, struct malloc_type *type, u_long *hashmask);
void *phashinit(int count, struct malloc_type *type, u_long *nentries);




void panic(const char *, ...) __attribute__((__noreturn__)) __attribute__((__format__ (__printf__, 1, 2)));


void cpu_boot(int);
void cpu_rootconf(void);
extern uint32_t crc32_tab[];
uint32_t crc32(const void *buf, size_t size);
void critical_enter(void);
void critical_exit(void);
void init_param1(void);
void init_param2(long physpages);
void tablefull(const char *);
int kvprintf(char const *, void (*)(int, void*), void *, int,
            __va_list) __attribute__((__format__ (__printf__, 1, 0)));
void log(int, const char *, ...) __attribute__((__format__ (__printf__, 2, 3)));
void log_console(struct uio *);
int printf(const char *, ...) __attribute__((__format__ (__printf__, 1, 2)));
int snprintf(char *, size_t, const char *, ...) __attribute__((__format__ (__printf__, 3, 4)));
int sprintf(char *buf, const char *, ...) __attribute__((__format__ (__printf__, 2, 3)));
int uprintf(const char *, ...) __attribute__((__format__ (__printf__, 1, 2)));
int vprintf(const char *, __va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsnprintf(char *, size_t, const char *, __va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsprintf(char *buf, const char *, __va_list) __attribute__((__format__ (__printf__, 2, 0)));
int ttyprintf(struct tty *, const char *, ...) __attribute__((__format__ (__printf__, 2, 3)));
int sscanf(const char *, char const *, ...);
int vsscanf(const char *, char const *, __va_list);
long strtol(const char *, char **, int);
u_long strtoul(const char *, char **, int);
quad_t strtoq(const char *, char **, int);
u_quad_t strtouq(const char *, char **, int);
void tprintf(struct proc *p, int pri, const char *, ...) __attribute__((__format__ (__printf__, 3, 4)));

void bcopy(const void *from, void *to, size_t len);
void ovbcopy(const void *from, void *to, size_t len);


extern void (*bzero)(void *buf, size_t len);




void *memcpy(void *to, const void *from, size_t len);

int copystr(const void *kfaddr, void *kdaddr, size_t len,
            size_t *lencopied);
int copyinstr(const void *udaddr, void *kaddr, size_t len,
            size_t *lencopied);
int copyin(const void *udaddr, void *kaddr, size_t len);
int copyout(const void *kaddr, void *udaddr, size_t len);

int fubyte(const void *base);
long fuword(const void *base);
int fuword16(void *base);
int32_t fuword32(const void *base);
int64_t fuword64(const void *base);
int subyte(void *base, int byte);
int suword(void *base, long word);
int suword16(void *base, int word);
int suword32(void *base, int32_t word);
int suword64(void *base, int64_t word);

void realitexpire(void *);

void hardclock(struct clockframe *frame);
void hardclock_process(struct thread *td, int user);
void softclock(void *);
void statclock(struct clockframe *frame);
void statclock_process(struct kse *ke, register_t pc, int user);

void startprofclock(struct proc *);
void stopprofclock(struct proc *);
void setstatclockrate(int hzrate);




int suser(struct thread *td);
int suser_cred(struct ucred *cred, int flag);
int cr_cansee(struct ucred *u1, struct ucred *u2);
int cr_canseesocket(struct ucred *cred, struct socket *so);

char *getenv(const char *name);
void freeenv(char *env);
int getenv_int(const char *name, int *data);
int getenv_string(const char *name, char *data, int size);
int getenv_quad(const char *name, quad_t *data);
int setenv(const char *name, const char *value);
int unsetenv(const char *name);
int testenv(const char *name);






# 1 "/usr/src/sys/sys/libkern.h" 1
# 43 "/usr/src/sys/sys/libkern.h"
# 1 "/usr/src/sys/sys/systm.h" 1
# 44 "/usr/src/sys/sys/libkern.h" 2



extern u_char const bcd2bin_data[];
extern u_char const bin2bcd_data[];
extern char const hex2ascii_data[];





static __inline int imax(int a, int b) { return (a > b ? a : b); }
static __inline int imin(int a, int b) { return (a < b ? a : b); }
static __inline long lmax(long a, long b) { return (a > b ? a : b); }
static __inline long lmin(long a, long b) { return (a < b ? a : b); }
static __inline u_int max(u_int a, u_int b) { return (a > b ? a : b); }
static __inline u_int min(u_int a, u_int b) { return (a < b ? a : b); }
static __inline quad_t qmax(quad_t a, quad_t b) { return (a > b ? a : b); }
static __inline quad_t qmin(quad_t a, quad_t b) { return (a < b ? a : b); }
static __inline u_long ulmax(u_long a, u_long b) { return (a > b ? a : b); }
static __inline u_long ulmin(u_long a, u_long b) { return (a < b ? a : b); }


uint32_t arc4random(void);
void arc4rand(void *ptr, u_int len, int reseed);
int bcmp(const void *, const void *, size_t);
void *bsearch(const void *, const void *, size_t,
            size_t, int (*)(const void *, const void *));






int fnmatch(const char *, const char *, int);
int locc(int, char *, u_int);
void qsort(void *base, size_t nmemb, size_t size,
            int (*compar)(const void *, const void *));
u_long random(void);
char *index(const char *, int);
char *rindex(const char *, int);
int scanc(u_int, const u_char *, const u_char *, int);
int skpc(int, int, char *);
void srandom(u_long);
char *strcat(char *, const char *);
int strcmp(const char *, const char *);
char *strcpy(char *, const char *);
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
size_t strlen(const char *);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
char *strsep(char **, const char *delim);
int strvalid(const char *, size_t);


static __inline int
memcmp(const void *b1, const void *b2, size_t len)
{
        return (bcmp(b1, b2, len));
}

static __inline void *
memset(void *b, int c, size_t len)
{
        char *bb;

        if (c == 0)
                bzero(b, len);
        else
                for (bb = (char *)b; len--; )
                        *bb++ = c;
        return (b);
}
# 231 "/usr/src/sys/sys/systm.h" 2


void consinit(void);
void cpu_initclocks(void);
void usrinfoinit(void);


void shutdown_nice(int);




void inittodr(time_t base);
void resettodr(void);
void startrtclock(void);


typedef void timeout_t(void *);



void callout_handle_init(struct callout_handle *);
struct callout_handle timeout(timeout_t *, void *, int);
void untimeout(timeout_t *, void *, struct callout_handle);
caddr_t kern_timeout_callwheel_alloc(caddr_t v);
void kern_timeout_callwheel_init(void);


static __inline void spl0(void) { return; }
static __inline intrmask_t splbio(void) { return 0; }
static __inline intrmask_t splcam(void) { return 0; }
static __inline intrmask_t splclock(void) { return 0; }
static __inline intrmask_t splhigh(void) { return 0; }
static __inline intrmask_t splimp(void) { return 0; }
static __inline intrmask_t splnet(void) { return 0; }
static __inline intrmask_t splsoftcam(void) { return 0; }
static __inline intrmask_t splsoftclock(void) { return 0; }
static __inline intrmask_t splsofttty(void) { return 0; }
static __inline intrmask_t splsoftvm(void) { return 0; }
static __inline intrmask_t splsofttq(void) { return 0; }
static __inline intrmask_t splstatclock(void) { return 0; }
static __inline intrmask_t spltty(void) { return 0; }
static __inline intrmask_t splvm(void) { return 0; }
static __inline void splx(intrmask_t ipl __attribute__((__unused__))) { return; }






typedef void (*exitlist_fn)(struct proc *procp);

int at_exit(exitlist_fn function);
int rm_at_exit(exitlist_fn function);


typedef void (*forklist_fn)(struct proc *parent, struct proc *child, int flags);

int at_fork(forklist_fn function);
int rm_at_fork(forklist_fn function);


typedef void (*execlist_fn)(struct proc *procp);

int at_exec(execlist_fn function);
int rm_at_exec(execlist_fn function);
# 305 "/usr/src/sys/sys/systm.h"
typedef void (*watchdog_tickle_fn)(void);

extern watchdog_tickle_fn wdog_tickler;





int msleep(void *chan, struct mtx *mtx, int pri, const char *wmesg,
            int timo);
void abortsleep(struct thread *td);

void wakeup(void *chan);
void wakeup_one(void *chan);





int major(dev_t x);
int minor(dev_t x);
dev_t makedev(int x, int y);
udev_t dev2udev(dev_t x);
dev_t udev2dev(udev_t x, int b);
int uminor(udev_t dev);
int umajor(udev_t dev);
udev_t makeudev(int x, int y);


void DELAY(int usec);
# 42 "netinet/ip_icmp.c" 2
# 1 "/usr/src/sys/sys/mac.h" 1
# 45 "/usr/src/sys/sys/mac.h"
# 1 "/usr/src/sys/sys/_label.h" 1
# 48 "/usr/src/sys/sys/_label.h"
struct label {
        int l_flags;
        union {
                void *l_ptr;
                long l_long;
        } l_perpolicy[4];
};
# 46 "/usr/src/sys/sys/mac.h" 2
# 67 "/usr/src/sys/sys/mac.h"
struct mac {
        size_t m_buflen;
        char *m_string;
};

typedef struct mac *mac_t;
# 113 "/usr/src/sys/sys/mac.h"
struct bpf_d;
struct componentname;
struct devfs_dirent;
struct ifnet;
struct ifreq;
struct image_params;
struct ipq;
struct mbuf;
struct mount;
struct proc;
struct sockaddr;
struct socket;
struct pipe;
struct thread;
struct timespec;
struct ucred;
struct uio;
struct vattr;
struct vnode;

# 1 "/usr/src/sys/sys/acl.h" 1
# 48 "/usr/src/sys/sys/acl.h"
typedef int acl_type_t;
typedef int acl_tag_t;
typedef mode_t acl_perm_t;
typedef mode_t *acl_permset_t;

struct acl_entry {
        acl_tag_t ae_tag;
        uid_t ae_id;
        acl_perm_t ae_perm;
};
typedef struct acl_entry *acl_entry_t;


struct acl {
        int acl_cnt;
        struct acl_entry acl_entry[32];
};


struct acl_t_struct {
        struct acl ats_acl;
        int ats_cur_entry;
};
typedef struct acl_t_struct *acl_t;
# 126 "/usr/src/sys/sys/acl.h"
acl_perm_t acl_posix1e_mode_to_perm(acl_tag_t tag, mode_t mode);
struct acl_entry acl_posix1e_mode_to_entry(acl_tag_t tag, uid_t uid,
    gid_t gid, mode_t mode);
mode_t acl_posix1e_perms_to_mode(struct acl_entry *acl_user_obj_entry,
    struct acl_entry *acl_group_obj_entry, struct acl_entry *acl_other_entry);
int acl_posix1e_check(struct acl *acl);
# 134 "/usr/src/sys/sys/mac.h" 2

struct vop_setlabel_args;




void mac_init_bpfdesc(struct bpf_d *);
void mac_init_cred(struct ucred *);
void mac_init_devfsdirent(struct devfs_dirent *);
void mac_init_ifnet(struct ifnet *);
void mac_init_ipq(struct ipq *);
int mac_init_socket(struct socket *, int flag);
void mac_init_pipe(struct pipe *);
int mac_init_mbuf(struct mbuf *m, int flag);
void mac_init_mount(struct mount *);
void mac_init_proc(struct proc *);
void mac_init_vnode(struct vnode *);
void mac_init_vnode_label(struct label *);
void mac_copy_vnode_label(struct label *, struct label *label);
void mac_destroy_bpfdesc(struct bpf_d *);
void mac_destroy_cred(struct ucred *);
void mac_destroy_devfsdirent(struct devfs_dirent *);
void mac_destroy_ifnet(struct ifnet *);
void mac_destroy_ipq(struct ipq *);
void mac_destroy_socket(struct socket *);
void mac_destroy_pipe(struct pipe *);
void mac_destroy_proc(struct proc *);
void mac_destroy_mbuf(struct mbuf *);
void mac_destroy_mount(struct mount *);
void mac_destroy_vnode(struct vnode *);
void mac_destroy_vnode_label(struct label *);





void mac_associate_vnode_devfs(struct mount *mp, struct devfs_dirent *de,
            struct vnode *vp);
int mac_associate_vnode_extattr(struct mount *mp, struct vnode *vp);
void mac_associate_vnode_singlelabel(struct mount *mp, struct vnode *vp);
void mac_create_devfs_device(struct mount *mp, dev_t dev,
            struct devfs_dirent *de);
void mac_create_devfs_directory(struct mount *mp, char *dirname,
            int dirnamelen, struct devfs_dirent *de);
void mac_create_devfs_symlink(struct ucred *cred, struct mount *mp,
            struct devfs_dirent *dd, struct devfs_dirent *de);
int mac_create_vnode_extattr(struct ucred *cred, struct mount *mp,
            struct vnode *dvp, struct vnode *vp, struct componentname *cnp);
void mac_create_mount(struct ucred *cred, struct mount *mp);
void mac_create_root_mount(struct ucred *cred, struct mount *mp);
void mac_relabel_vnode(struct ucred *cred, struct vnode *vp,
            struct label *newlabel);
void mac_update_devfsdirent(struct mount *mp, struct devfs_dirent *de,
            struct vnode *vp);




void mac_create_mbuf_from_socket(struct socket *so, struct mbuf *m);
void mac_create_socket(struct ucred *cred, struct socket *socket);
void mac_create_socket_from_socket(struct socket *oldsocket,
            struct socket *newsocket);
void mac_set_socket_peer_from_mbuf(struct mbuf *mbuf,
            struct socket *socket);
void mac_set_socket_peer_from_socket(struct socket *oldsocket,
            struct socket *newsocket);
void mac_create_pipe(struct ucred *cred, struct pipe *pipe);




void mac_create_bpfdesc(struct ucred *cred, struct bpf_d *bpf_d);
void mac_create_ifnet(struct ifnet *ifp);
void mac_create_ipq(struct mbuf *fragment, struct ipq *ipq);
void mac_create_datagram_from_ipq(struct ipq *ipq, struct mbuf *datagram);
void mac_create_fragment(struct mbuf *datagram, struct mbuf *fragment);
void mac_create_mbuf_from_mbuf(struct mbuf *oldmbuf, struct mbuf *newmbuf);
void mac_create_mbuf_linklayer(struct ifnet *ifnet, struct mbuf *m);
void mac_create_mbuf_from_bpfdesc(struct bpf_d *bpf_d, struct mbuf *m);
void mac_create_mbuf_from_ifnet(struct ifnet *ifnet, struct mbuf *m);
void mac_create_mbuf_multicast_encap(struct mbuf *oldmbuf,
            struct ifnet *ifnet, struct mbuf *newmbuf);
void mac_create_mbuf_netlayer(struct mbuf *oldmbuf, struct mbuf *newmbuf);
int mac_fragment_match(struct mbuf *fragment, struct ipq *ipq);
void mac_update_ipq(struct mbuf *fragment, struct ipq *ipq);




void mac_create_cred(struct ucred *cred_parent, struct ucred *cred_child);
int mac_execve_enter(struct image_params *imgp, struct mac *mac_p,
            struct label *execlabel);
void mac_execve_exit(struct image_params *imgp);
void mac_execve_transition(struct ucred *old, struct ucred *new,
            struct vnode *vp, struct label *interpvnodelabel,
            struct image_params *imgp);
int mac_execve_will_transition(struct ucred *old, struct vnode *vp,
            struct label *interpvnodelabel, struct image_params *imgp);
void mac_create_proc0(struct ucred *cred);
void mac_create_proc1(struct ucred *cred);
void mac_thread_userret(struct thread *td);


int mac_check_bpfdesc_receive(struct bpf_d *bpf_d, struct ifnet *ifnet);
int mac_check_cred_visible(struct ucred *u1, struct ucred *u2);
int mac_check_ifnet_transmit(struct ifnet *ifnet, struct mbuf *m);
int mac_check_kenv_dump(struct ucred *cred);
int mac_check_kenv_get(struct ucred *cred, char *name);
int mac_check_kenv_set(struct ucred *cred, char *name, char *value);
int mac_check_kenv_unset(struct ucred *cred, char *name);
int mac_check_kld_load(struct ucred *cred, struct vnode *vp);
int mac_check_kld_stat(struct ucred *cred);
int mac_check_kld_unload(struct ucred *cred);
int mac_check_mount_stat(struct ucred *cred, struct mount *mp);
int mac_check_pipe_ioctl(struct ucred *cred, struct pipe *pipe,
            unsigned long cmd, void *data);
int mac_check_pipe_poll(struct ucred *cred, struct pipe *pipe);
int mac_check_pipe_read(struct ucred *cred, struct pipe *pipe);
int mac_check_pipe_stat(struct ucred *cred, struct pipe *pipe);
int mac_check_pipe_write(struct ucred *cred, struct pipe *pipe);
int mac_check_proc_debug(struct ucred *cred, struct proc *proc);
int mac_check_proc_sched(struct ucred *cred, struct proc *proc);
int mac_check_proc_signal(struct ucred *cred, struct proc *proc,
            int signum);
int mac_check_socket_bind(struct ucred *cred, struct socket *so,
            struct sockaddr *sockaddr);
int mac_check_socket_connect(struct ucred *cred, struct socket *so,
            struct sockaddr *sockaddr);
int mac_check_socket_deliver(struct socket *so, struct mbuf *m);
int mac_check_socket_listen(struct ucred *cred, struct socket *so);
int mac_check_socket_receive(struct ucred *cred, struct socket *so);
int mac_check_socket_send(struct ucred *cred, struct socket *so);
int mac_check_socket_visible(struct ucred *cred, struct socket *so);
int mac_check_system_acct(struct ucred *cred, struct vnode *vp);
int mac_check_system_nfsd(struct ucred *cred);
int mac_check_system_reboot(struct ucred *cred, int howto);
int mac_check_system_settime(struct ucred *cred);
int mac_check_system_swapon(struct ucred *cred, struct vnode *vp);
int mac_check_system_sysctl(struct ucred *cred, int *name,
            u_int namelen, void *old, size_t *oldlenp, int inkernel,
            void *new, size_t newlen);
int mac_check_vnode_access(struct ucred *cred, struct vnode *vp,
            int acc_mode);
int mac_check_vnode_chdir(struct ucred *cred, struct vnode *dvp);
int mac_check_vnode_chroot(struct ucred *cred, struct vnode *dvp);
int mac_check_vnode_create(struct ucred *cred, struct vnode *dvp,
            struct componentname *cnp, struct vattr *vap);
int mac_check_vnode_delete(struct ucred *cred, struct vnode *dvp,
            struct vnode *vp, struct componentname *cnp);
int mac_check_vnode_deleteacl(struct ucred *cred, struct vnode *vp,
            acl_type_t type);
int mac_check_vnode_exec(struct ucred *cred, struct vnode *vp,
            struct image_params *imgp);
int mac_check_vnode_getacl(struct ucred *cred, struct vnode *vp,
            acl_type_t type);
int mac_check_vnode_getextattr(struct ucred *cred, struct vnode *vp,
            int attrnamespace, const char *name, struct uio *uio);
int mac_check_vnode_link(struct ucred *cred, struct vnode *dvp,
            struct vnode *vp, struct componentname *cnp);
int mac_check_vnode_lookup(struct ucred *cred, struct vnode *dvp,
            struct componentname *cnp);
int mac_check_vnode_mmap(struct ucred *cred, struct vnode *vp,
            int prot);
int mac_check_vnode_mprotect(struct ucred *cred, struct vnode *vp,
            int prot);
int mac_check_vnode_open(struct ucred *cred, struct vnode *vp,
            int acc_mode);
int mac_check_vnode_poll(struct ucred *active_cred,
            struct ucred *file_cred, struct vnode *vp);
int mac_check_vnode_read(struct ucred *active_cred,
            struct ucred *file_cred, struct vnode *vp);
int mac_check_vnode_readdir(struct ucred *cred, struct vnode *vp);
int mac_check_vnode_readlink(struct ucred *cred, struct vnode *vp);
int mac_check_vnode_rename_from(struct ucred *cred, struct vnode *dvp,
            struct vnode *vp, struct componentname *cnp);
int mac_check_vnode_rename_to(struct ucred *cred, struct vnode *dvp,
            struct vnode *vp, int samedir, struct componentname *cnp);
int mac_check_vnode_revoke(struct ucred *cred, struct vnode *vp);
int mac_check_vnode_setacl(struct ucred *cred, struct vnode *vp,
            acl_type_t type, struct acl *acl);
int mac_check_vnode_setextattr(struct ucred *cred, struct vnode *vp,
            int attrnamespace, const char *name, struct uio *uio);
int mac_check_vnode_setflags(struct ucred *cred, struct vnode *vp,
            u_long flags);
int mac_check_vnode_setmode(struct ucred *cred, struct vnode *vp,
            mode_t mode);
int mac_check_vnode_setowner(struct ucred *cred, struct vnode *vp,
            uid_t uid, gid_t gid);
int mac_check_vnode_setutimes(struct ucred *cred, struct vnode *vp,
            struct timespec atime, struct timespec mtime);
int mac_check_vnode_stat(struct ucred *active_cred,
            struct ucred *file_cred, struct vnode *vp);
int mac_check_vnode_write(struct ucred *active_cred,
            struct ucred *file_cred, struct vnode *vp);
int mac_getsockopt_label_get(struct ucred *cred, struct socket *so,
            struct mac *extmac);
int mac_getsockopt_peerlabel_get(struct ucred *cred, struct socket *so,
            struct mac *extmac);
int mac_ioctl_ifnet_get(struct ucred *cred, struct ifreq *ifr,
            struct ifnet *ifnet);
int mac_ioctl_ifnet_set(struct ucred *cred, struct ifreq *ifr,
            struct ifnet *ifnet);
int mac_setsockopt_label_set(struct ucred *cred, struct socket *so,
            struct mac *extmac);
int mac_pipe_label_set(struct ucred *cred, struct pipe *pipe,
            struct label *label);
void mac_cred_mmapped_drop_perms(struct thread *td, struct ucred *cred);





int vop_stdsetlabel_ea(struct vop_setlabel_args *ap);
# 43 "netinet/ip_icmp.c" 2
# 1 "/usr/src/sys/sys/mbuf.h" 1
# 70 "/usr/src/sys/sys/mbuf.h"
struct m_hdr {
        struct mbuf *mh_next;
        struct mbuf *mh_nextpkt;
        caddr_t mh_data;
        int mh_len;
        int mh_flags;
        short mh_type;
};




struct m_tag {
        struct { struct m_tag *sle_next; } m_tag_link;
        u_int16_t m_tag_id;
        u_int16_t m_tag_len;
        u_int32_t m_tag_cookie;
};




struct pkthdr {
        struct ifnet *rcvif;
        int len;

        void *header;

        int csum_flags;
        int csum_data;
        struct packet_tags { struct m_tag *slh_first; } tags;
        struct label label;
};




struct m_ext {
        caddr_t ext_buf;
        void (*ext_free)
                    (void *, void *);
        void *ext_args;
        u_int ext_size;
        u_int *ref_cnt;
        int ext_type;
};





struct mbuf {
        struct m_hdr m_hdr;
        union {
                struct {
                        struct pkthdr MH_pkthdr;
                        union {
                                struct m_ext MH_ext;
                                char MH_databuf[((256 - sizeof(struct m_hdr)) - sizeof(struct pkthdr))];
                        } MH_dat;
                } MH;
                char M_databuf[(256 - sizeof(struct m_hdr))];
        } M_dat;
};
# 230 "/usr/src/sys/sys/mbuf.h"
struct mbpstat {
        u_long mb_mbfree;
        u_long mb_mbpgs;
        u_long mb_clfree;
        u_long mb_clpgs;
        long mb_mbtypes[16];
        short mb_active;
};
# 247 "/usr/src/sys/sys/mbuf.h"
struct mbstat {
        u_long m_drops;
        u_long m_wait;
        u_long m_drain;
        u_long m_mcfail;
        u_long m_mpfail;
        u_long m_msize;
        u_long m_mclbytes;
        u_long m_minclsize;
        u_long m_mlen;
        u_long m_mhlen;

        short m_numtypes;
};
# 406 "/usr/src/sys/sys/mbuf.h"
extern int max_datalen;
extern int max_hdr;
extern int max_linkhdr;
extern int max_protohdr;
extern struct mbstat mbstat;
extern int nmbclusters;
extern int nmbcnt;
extern int nmbufs;
extern int nsfbufs;

void _mext_free(struct mbuf *);
void m_adj(struct mbuf *, int);
void m_cat(struct mbuf *, struct mbuf *);
void m_chtype(struct mbuf *, short);
void m_clget(struct mbuf *, int);
void m_extadd(struct mbuf *, caddr_t, u_int,
                    void (*)(void *, void *), void *, int, int);
void m_copyback(struct mbuf *, int, int, caddr_t);
void m_copydata(const struct mbuf *, int, int, caddr_t);
struct mbuf *m_copym(struct mbuf *, int, int, int);
struct mbuf *m_copypacket(struct mbuf *, int);
void m_copy_pkthdr(struct mbuf *, struct mbuf *);
struct mbuf *m_devget(char *, int, int, struct ifnet *,
                    void (*)(char *, caddr_t, u_int));
struct mbuf *m_dup(struct mbuf *, int);
u_int m_fixhdr(struct mbuf *);
struct mbuf *m_free(struct mbuf *);
void m_freem(struct mbuf *);
struct mbuf *m_get(int, short);
struct mbuf *m_get_clrd(int, short);
struct mbuf *m_getcl(int, short, int);
struct mbuf *m_gethdr(int, short);
struct mbuf *m_gethdr_clrd(int, short);
struct mbuf *m_getm(struct mbuf *, int, int, short);
u_int m_length(struct mbuf *, struct mbuf **);
struct mbuf *m_prepend(struct mbuf *, int, int);
void m_print(const struct mbuf *);
struct mbuf *m_pulldown(struct mbuf *, int, int, int *);
struct mbuf *m_pullup(struct mbuf *, int);
struct mbuf *m_split(struct mbuf *, int, int);
# 524 "/usr/src/sys/sys/mbuf.h"
struct m_tag *m_tag_alloc(u_int32_t, int, int, int);
void m_tag_free(struct m_tag *);
void m_tag_prepend(struct mbuf *, struct m_tag *);
void m_tag_unlink(struct mbuf *, struct m_tag *);
void m_tag_delete(struct mbuf *, struct m_tag *);
void m_tag_delete_chain(struct mbuf *, struct m_tag *);
struct m_tag *m_tag_locate(struct mbuf *, u_int32_t, int, struct m_tag *);
struct m_tag *m_tag_copy(struct m_tag *);
int m_tag_copy_chain(struct mbuf *, struct mbuf *);
void m_tag_init(struct mbuf *);
struct m_tag *m_tag_first(struct mbuf *);
struct m_tag *m_tag_next(struct mbuf *, struct m_tag *);




static __inline struct m_tag *
m_tag_get(int type, int length, int wait)
{
        return m_tag_alloc(0, type, length, wait);
}

static __inline struct m_tag *
m_tag_find(struct mbuf *m, int type, struct m_tag *start)
{
        return m_tag_locate(m, 0, type, start);
}
# 44 "netinet/ip_icmp.c" 2
# 1 "/usr/src/sys/sys/protosw.h" 1
# 43 "/usr/src/sys/sys/protosw.h"
# 1 "net/pfil.h" 1
# 36 "net/pfil.h"
struct mbuf;
struct ifnet;





struct packet_filter_hook {
        struct { struct packet_filter_hook *tqe_next; struct packet_filter_hook **tqe_prev; } pfil_link;
        int (*pfil_func)(void *, int, struct ifnet *, int, struct mbuf **);
        int pfil_flags;
};






typedef struct pfil_list { struct packet_filter_hook *tqh_first; struct packet_filter_hook **tqh_last; } pfil_list_t;

struct pfil_head {
        pfil_list_t ph_in;
        pfil_list_t ph_out;
        int ph_init;
};

struct packet_filter_hook *pfil_hook_get(int, struct pfil_head *);
int pfil_add_hook(int (*func)(void *, int,
            struct ifnet *, int, struct mbuf **), int, struct pfil_head *);
int pfil_remove_hook(int (*func)(void *, int,
            struct ifnet *, int, struct mbuf **), int, struct pfil_head *);



# 1 "/usr/obj/usr/src/sys/GENERIC/opt_ipfilter.h" 1
# 71 "net/pfil.h" 2
# 44 "/usr/src/sys/sys/protosw.h" 2


struct mbuf;
struct thread;
struct sockaddr;
struct socket;
struct sockopt;
# 76 "/usr/src/sys/sys/protosw.h"
typedef void pr_input_t (struct mbuf *, int);
typedef int pr_input6_t (struct mbuf **, int*, int);
typedef void pr_in_input_t (struct mbuf *, int, int);
typedef int pr_output_t (struct mbuf *, struct socket *);
typedef int pr_in_output_t (struct mbuf *, struct socket *, struct sockaddr *);
typedef void pr_ctlinput_t (int, struct sockaddr *, void *);
typedef int pr_ctloutput_t (struct socket *, struct sockopt *);
typedef void pr_init_t (void);
typedef void pr_fasttimo_t (void);
typedef void pr_slowtimo_t (void);
typedef void pr_drain_t (void);

typedef int pr_usrreq_t(struct socket *, int, struct mbuf *,
                             struct mbuf *, struct mbuf *, struct thread *);

struct protosw {
        short pr_type;
        struct domain *pr_domain;
        short pr_protocol;
        short pr_flags;

        pr_input_t *pr_input;
        pr_output_t *pr_output;
        pr_ctlinput_t *pr_ctlinput;
        pr_ctloutput_t *pr_ctloutput;

        pr_usrreq_t *pr_ousrreq;

        pr_init_t *pr_init;
        pr_fasttimo_t *pr_fasttimo;
        pr_slowtimo_t *pr_slowtimo;
        pr_drain_t *pr_drain;

        struct pr_usrreqs *pr_usrreqs;
        struct pfil_head pr_pfh;
};
# 187 "/usr/src/sys/sys/protosw.h"
struct ifnet;
struct stat;
struct ucred;
struct uio;







struct pr_usrreqs {
        int (*pru_abort)(struct socket *so);
        int (*pru_accept)(struct socket *so, struct sockaddr **nam);
        int (*pru_attach)(struct socket *so, int proto, struct thread *td);
        int (*pru_bind)(struct socket *so, struct sockaddr *nam,
                    struct thread *td);
        int (*pru_connect)(struct socket *so, struct sockaddr *nam,
                    struct thread *td);
        int (*pru_connect2)(struct socket *so1, struct socket *so2);
        int (*pru_control)(struct socket *so, u_long cmd, caddr_t data,
                    struct ifnet *ifp, struct thread *td);
        int (*pru_detach)(struct socket *so);
        int (*pru_disconnect)(struct socket *so);
        int (*pru_listen)(struct socket *so, struct thread *td);
        int (*pru_peeraddr)(struct socket *so, struct sockaddr **nam);
        int (*pru_rcvd)(struct socket *so, int flags);
        int (*pru_rcvoob)(struct socket *so, struct mbuf *m, int flags);
        int (*pru_send)(struct socket *so, int flags, struct mbuf *m,
                    struct sockaddr *addr, struct mbuf *control,
                    struct thread *td);



        int (*pru_sense)(struct socket *so, struct stat *sb);
        int (*pru_shutdown)(struct socket *so);
        int (*pru_sockaddr)(struct socket *so, struct sockaddr **nam);
# 233 "/usr/src/sys/sys/protosw.h"
        int (*pru_sosend)(struct socket *so, struct sockaddr *addr,
                    struct uio *uio, struct mbuf *top, struct mbuf *control,
                    int flags, struct thread *td);
        int (*pru_soreceive)(struct socket *so, struct sockaddr **paddr,
                    struct uio *uio, struct mbuf **mp0, struct mbuf **controlp,
                    int *flagsp);
        int (*pru_sopoll)(struct socket *so, int events,
                    struct ucred *cred, struct thread *td);
};

int pru_accept_notsupp(struct socket *so, struct sockaddr **nam);
int pru_connect_notsupp(struct socket *so, struct sockaddr *nam,
            struct thread *td);
int pru_connect2_notsupp(struct socket *so1, struct socket *so2);
int pru_control_notsupp(struct socket *so, u_long cmd, caddr_t data,
            struct ifnet *ifp, struct thread *td);
int pru_listen_notsupp(struct socket *so, struct thread *td);
int pru_rcvd_notsupp(struct socket *so, int flags);
int pru_rcvoob_notsupp(struct socket *so, struct mbuf *m, int flags);
int pru_sense_null(struct socket *so, struct stat *sb);
# 326 "/usr/src/sys/sys/protosw.h"
void pfctlinput(int, struct sockaddr *);
void pfctlinput2(int, struct sockaddr *, void *);
struct protosw *pffindproto(int family, int protocol, int type);
struct protosw *pffindtype(int family, int type);
# 45 "netinet/ip_icmp.c" 2
# 1 "/usr/src/sys/sys/socket.h" 1
# 43 "/usr/src/sys/sys/socket.h"
# 1 "/usr/obj/usr/src/sys/GENERIC/machine/param.h" 1
# 44 "/usr/src/sys/sys/socket.h" 2
# 71 "/usr/src/sys/sys/socket.h"
typedef __sa_family_t sa_family_t;
# 81 "/usr/src/sys/sys/socket.h"
typedef __socklen_t socklen_t;
# 148 "/usr/src/sys/sys/socket.h"
struct linger {
        int l_onoff;
        int l_linger;
};


struct accept_filter_arg {
        char af_name[16];
        char af_arg[256-16];
};
# 220 "/usr/src/sys/sys/socket.h"
struct sockaddr {
        unsigned char sa_len;
        sa_family_t sa_family;
        char sa_data[14];
};







struct sockproto {
        unsigned short sp_family;
        unsigned short sp_protocol;
};
# 248 "/usr/src/sys/sys/socket.h"
struct sockaddr_storage {
        unsigned char ss_len;
        sa_family_t ss_family;
        char __ss_pad1[((sizeof(__int64_t)) - sizeof(unsigned char) - sizeof(sa_family_t))];
        __int64_t __ss_align;
        char __ss_pad2[(128U - sizeof(unsigned char) - sizeof(sa_family_t) - ((sizeof(__int64_t)) - sizeof(unsigned char) - sizeof(sa_family_t)) - (sizeof(__int64_t)))];
};
# 375 "/usr/src/sys/sys/socket.h"
struct iovec {
        void *iov_base;
        size_t iov_len;
};






struct msghdr {
        void *msg_name;
        socklen_t msg_namelen;
        struct iovec *msg_iov;
        int msg_iovlen;
        void *msg_control;
        socklen_t msg_controllen;
        int msg_flags;
};
# 414 "/usr/src/sys/sys/socket.h"
struct cmsghdr {
        socklen_t cmsg_len;
        int cmsg_level;
        int cmsg_type;

};
# 436 "/usr/src/sys/sys/socket.h"
struct cmsgcred {
        pid_t cmcred_pid;
        uid_t cmcred_uid;
        uid_t cmcred_euid;
        gid_t cmcred_gid;
        short cmcred_ngroups;
        gid_t cmcred_groups[16];
};
# 481 "/usr/src/sys/sys/socket.h"
struct osockaddr {
        unsigned short sa_family;
        char sa_data[14];
};




struct omsghdr {
        char *msg_name;
        int msg_namelen;
        struct iovec *msg_iov;
        int msg_iovlen;
        char *msg_accrights;
        int msg_accrightslen;
};
# 510 "/usr/src/sys/sys/socket.h"
struct sf_hdtr {
        struct iovec *headers;
        int hdr_cnt;
        struct iovec *trailers;
        int trl_cnt;
};
# 46 "netinet/ip_icmp.c" 2

# 1 "/usr/src/sys/sys/kernel.h" 1
# 48 "/usr/src/sys/sys/kernel.h"
# 1 "/usr/src/sys/sys/linker_set.h" 1
# 49 "/usr/src/sys/sys/kernel.h" 2







# 1 "/usr/src/sys/sys/module.h" 1
# 42 "/usr/src/sys/sys/module.h"
typedef enum modeventtype {
        MOD_LOAD,
        MOD_UNLOAD,
        MOD_SHUTDOWN
} modeventtype_t;

typedef struct module *module_t;
typedef int (*modeventhand_t)(module_t, int , void *);




typedef struct moduledata {
        const char *name;
        modeventhand_t evhand;
        void *priv;
} moduledata_t;





typedef union modspecific {
        int intval;
        u_int uintval;
        long longval;
        u_long ulongval;
} modspecific_t;




struct mod_depend {
        int md_ver_minimum;
        int md_ver_preferred;
        int md_ver_maximum;
};




struct mod_version {
        int mv_version;
};

struct mod_metadata {
        int md_version;
        int md_type;
        void *md_data;
        const char *md_cval;
};
# 128 "/usr/src/sys/sys/module.h"
extern struct sx modules_sx;
# 137 "/usr/src/sys/sys/module.h"
struct linker_file;

void module_register_init(const void *);
int module_register(const struct moduledata *, struct linker_file *);
module_t module_lookupbyname(const char *);
module_t module_lookupbyid(int);
void module_reference(module_t);
void module_release(module_t);
int module_unload(module_t);
int module_getid(module_t);
module_t module_getfnext(module_t);
void module_setspecific(module_t, modspecific_t *);
# 167 "/usr/src/sys/sys/module.h"
struct module_stat {
        int version;
        char name[32];
        int refs;
        int id;
        modspecific_t data;
};
# 57 "/usr/src/sys/sys/kernel.h" 2




extern unsigned long hostid;
extern char hostname[256];
extern int hostnamelen;
extern char domainname[256];
extern int domainnamelen;
extern char kernelname[1024];


extern struct timeval boottime;

extern struct timezone tz;

extern int tick;
extern int hz;
extern int psratio;
extern int stathz;
extern int profhz;
extern int ticks;
extern int lbolt;
# 107 "/usr/src/sys/sys/kernel.h"
enum sysinit_sub_id {
        SI_SUB_DUMMY = 0x0000000,
        SI_SUB_DONE = 0x0000001,
        SI_SUB_TUNABLES = 0x0700000,
        SI_SUB_CONSOLE = 0x0800000,
        SI_SUB_COPYRIGHT = 0x0800001,
        SI_SUB_MTX_POOL = 0x0900000,
        SI_SUB_VM = 0x1000000,
        SI_SUB_KMEM = 0x1800000,
        SI_SUB_KVM_RSRC = 0x1A00000,
        SI_SUB_WITNESS = 0x1A80000,
        SI_SUB_LOCK = 0x1B00000,
        SI_SUB_EVENTHANDLER = 0x1C00000,
        SI_SUB_KLD = 0x2000000,
        SI_SUB_CPU = 0x2100000,
        SI_SUB_MAC = 0x2180000,
        SI_SUB_MAC_POLICY = 0x21C0000,
        SI_SUB_MAC_LATE = 0x21D0000,
        SI_SUB_INTRINSIC = 0x2200000,
        SI_SUB_VM_CONF = 0x2300000,
        SI_SUB_RUN_QUEUE = 0x2400000,
        SI_SUB_KTRACE = 0x2480000,
        SI_SUB_CREATE_INIT = 0x2500000,
        SI_SUB_SCHED_IDLE = 0x2600000,
        SI_SUB_MBUF = 0x2700000,
        SI_SUB_INTR = 0x2800000,
        SI_SUB_SOFTINTR = 0x2800001,
        SI_SUB_DEVFS = 0x2F00000,
        SI_SUB_INIT_IF = 0x3000000,
        SI_SUB_DRIVERS = 0x3100000,
        SI_SUB_CONFIGURE = 0x3800000,
        SI_SUB_VFS = 0x4000000,
        SI_SUB_CLOCKS = 0x4800000,
        SI_SUB_CLIST = 0x5800000,
        SI_SUB_SYSV_SHM = 0x6400000,
        SI_SUB_SYSV_SEM = 0x6800000,
        SI_SUB_SYSV_MSG = 0x6C00000,
        SI_SUB_P1003_1B = 0x6E00000,
        SI_SUB_PSEUDO = 0x7000000,
        SI_SUB_EXEC = 0x7400000,
        SI_SUB_PROTO_BEGIN = 0x8000000,
        SI_SUB_PROTO_IF = 0x8400000,
        SI_SUB_PROTO_DOMAIN = 0x8800000,
        SI_SUB_PROTO_END = 0x8ffffff,
        SI_SUB_KPROF = 0x9000000,
        SI_SUB_KICK_SCHEDULER = 0xa000000,
        SI_SUB_INT_CONFIG_HOOKS = 0xa800000,
        SI_SUB_ROOT_CONF = 0xb000000,
        SI_SUB_DUMP_CONF = 0xb200000,
        SI_SUB_VINUM = 0xb300000,
        SI_SUB_RAID = 0xb380000,
        SI_SUB_MOUNT_ROOT = 0xb400000,
        SI_SUB_SWAP = 0xc000000,
        SI_SUB_INTRINSIC_POST = 0xd000000,
        SI_SUB_KTHREAD_INIT = 0xe000000,
        SI_SUB_KTHREAD_PAGE = 0xe400000,
        SI_SUB_KTHREAD_VM = 0xe800000,
        SI_SUB_KTHREAD_BUF = 0xea00000,
        SI_SUB_KTHREAD_UPDATE = 0xec00000,
        SI_SUB_KTHREAD_IDLE = 0xee00000,
        SI_SUB_SMP = 0xf000000,
        SI_SUB_RUN_SCHEDULER = 0xfffffff
};





enum sysinit_elem_order {
        SI_ORDER_FIRST = 0x0000000,
        SI_ORDER_SECOND = 0x0000001,
        SI_ORDER_THIRD = 0x0000002,
        SI_ORDER_MIDDLE = 0x1000000,
        SI_ORDER_ANY = 0xfffffff
};
# 207 "/usr/src/sys/sys/kernel.h"
typedef void (*sysinit_nfunc_t)(void *);
typedef void (*sysinit_cfunc_t)(const void *);

struct sysinit {
        enum sysinit_sub_id subsystem;
        enum sysinit_elem_order order;
        sysinit_cfunc_t func;
        const void *udata;
};
# 258 "/usr/src/sys/sys/kernel.h"
void sysinit_add(struct sysinit **set, struct sysinit **set_end);







extern void tunable_int_init(void *);
struct tunable_int {
        const char *path;
        int *var;
};
# 286 "/usr/src/sys/sys/kernel.h"
extern void tunable_quad_init(void *);
struct tunable_quad {
        const char *path;
        quad_t *var;
};
# 306 "/usr/src/sys/sys/kernel.h"
extern void tunable_str_init(void *);
struct tunable_str {
        const char *path;
        char *var;
        int size;
};
# 329 "/usr/src/sys/sys/kernel.h"
struct intr_config_hook {
        struct { struct intr_config_hook *tqe_next; struct intr_config_hook **tqe_prev; } ich_links;
        void (*ich_func)(void *arg);
        void *ich_arg;
};

int config_intrhook_establish(struct intr_config_hook *hook);
void config_intrhook_disestablish(struct intr_config_hook *hook);
# 48 "netinet/ip_icmp.c" 2
# 1 "/usr/src/sys/sys/sysctl.h" 1
# 45 "/usr/src/sys/sys/sysctl.h"
struct thread;
# 64 "/usr/src/sys/sys/sysctl.h"
struct ctlname {
        char *ctl_name;
        int ctl_type;
};
# 113 "/usr/src/sys/sys/sysctl.h"
struct sysctl_req {
        struct thread *td;
        int lock;
        void *oldptr;
        size_t oldlen;
        size_t oldidx;
        int (*oldfunc)(struct sysctl_req *, const void *, size_t);
        void *newptr;
        size_t newlen;
        size_t newidx;
        int (*newfunc)(struct sysctl_req *, void *, size_t);
};

struct sysctl_oid_list { struct sysctl_oid *slh_first; };





struct sysctl_oid {
        struct sysctl_oid_list *oid_parent;
        struct { struct sysctl_oid *sle_next; } oid_link;
        int oid_number;
        u_int oid_kind;
        void *oid_arg1;
        int oid_arg2;
        const char *oid_name;
        int (*oid_handler)(struct sysctl_oid *oidp, void *arg1, int arg2, struct sysctl_req *req);
        const char *oid_fmt;
        int oid_refcnt;
        const char *descr;
};




int sysctl_handle_int(struct sysctl_oid *oidp, void *arg1, int arg2, struct sysctl_req *req);
int sysctl_handle_long(struct sysctl_oid *oidp, void *arg1, int arg2, struct sysctl_req *req);
int sysctl_handle_intptr(struct sysctl_oid *oidp, void *arg1, int arg2, struct sysctl_req *req);
int sysctl_handle_string(struct sysctl_oid *oidp, void *arg1, int arg2, struct sysctl_req *req);
int sysctl_handle_opaque(struct sysctl_oid *oidp, void *arg1, int arg2, struct sysctl_req *req);




void sysctl_register_oid(struct sysctl_oid *oidp);
void sysctl_unregister_oid(struct sysctl_oid *oidp);
# 174 "/usr/src/sys/sys/sysctl.h"
struct sysctl_ctx_entry {
        struct sysctl_oid *entry;
        struct { struct sysctl_ctx_entry *tqe_next; struct sysctl_ctx_entry **tqe_prev; } link;
};

struct sysctl_ctx_list { struct sysctl_ctx_entry *tqh_first; struct sysctl_ctx_entry **tqh_last; };
# 554 "/usr/src/sys/sys/sysctl.h"
extern struct sysctl_oid_list sysctl__children;
extern struct sysctl_oid_list sysctl__kern_children;
extern struct sysctl_oid_list sysctl__sysctl_children;
extern struct sysctl_oid_list sysctl__vm_children;
extern struct sysctl_oid_list sysctl__vfs_children;
extern struct sysctl_oid_list sysctl__net_children;
extern struct sysctl_oid_list sysctl__debug_children;
extern struct sysctl_oid_list sysctl__debug_sizeof_children;
extern struct sysctl_oid_list sysctl__hw_children;
extern struct sysctl_oid_list sysctl__machdep_children;
extern struct sysctl_oid_list sysctl__user_children;
extern struct sysctl_oid_list sysctl__compat_children;

extern char machine[];
extern char osrelease[];
extern char ostype[];


struct sysctl_oid *sysctl_add_oid(struct sysctl_ctx_list *clist,
                struct sysctl_oid_list *parent, int nbr, const char *name,
                int kind, void *arg1, int arg2,
                int (*handler) (struct sysctl_oid *oidp, void *arg1, int arg2, struct sysctl_req *req),
                const char *fmt, const char *descr);
int sysctl_remove_oid(struct sysctl_oid *oidp, int del, int recurse);
int sysctl_ctx_init(struct sysctl_ctx_list *clist);
int sysctl_ctx_free(struct sysctl_ctx_list *clist);
struct sysctl_ctx_entry *sysctl_ctx_entry_add(struct sysctl_ctx_list *clist,
                struct sysctl_oid *oidp);
struct sysctl_ctx_entry *sysctl_ctx_entry_find(struct sysctl_ctx_list *clist,
                struct sysctl_oid *oidp);
int sysctl_ctx_entry_del(struct sysctl_ctx_list *clist,
                struct sysctl_oid *oidp);

int kernel_sysctl(struct thread *td, int *name, u_int namelen, void *old,
                      size_t *oldlenp, void *new, size_t newlen,
                      size_t *retval);
int kernel_sysctlbyname(struct thread *td, char *name,
                void *old, size_t *oldlenp, void *new, size_t newlen,
                size_t *retval);
int userland_sysctl(struct thread *td, int *name, u_int namelen, void *old,
                        size_t *oldlenp, int inkernel, void *new, size_t newlen,
                        size_t *retval);
int sysctl_find_oid(int *name, u_int namelen, struct sysctl_oid **noid,
                        int *nindx, struct sysctl_req *req);
void sysctl_wire_old_buffer(struct sysctl_req *req, size_t len);
# 49 "netinet/ip_icmp.c" 2

# 1 "net/if.h" 1
# 55 "net/if.h"
struct ifnet;
# 72 "net/if.h"
struct if_clone {
        struct { struct if_clone *le_next; struct if_clone **le_prev; } ifc_list;
        const char *ifc_name;
        size_t ifc_namelen;
        int ifc_minifs;
        int ifc_maxunit;
        unsigned char *ifc_units;
        int ifc_bmlen;

        int (*ifc_create)(struct if_clone *, int);
        void (*ifc_destroy)(struct ifnet *);
};
# 95 "net/if.h"
struct if_clonereq {
        int ifcr_total;
        int ifcr_count;
        char *ifcr_buffer;
};





struct if_data {

        u_char ifi_type;
        u_char ifi_physical;
        u_char ifi_addrlen;
        u_char ifi_hdrlen;
        u_char ifi_recvquota;
        u_char ifi_xmitquota;
        u_long ifi_mtu;
        u_long ifi_metric;
        u_long ifi_baudrate;

        u_long ifi_ipackets;
        u_long ifi_ierrors;
        u_long ifi_opackets;
        u_long ifi_oerrors;
        u_long ifi_collisions;
        u_long ifi_ibytes;
        u_long ifi_obytes;
        u_long ifi_imcasts;
        u_long ifi_omcasts;
        u_long ifi_iqdrops;
        u_long ifi_noproto;
        u_long ifi_hwassist;
        u_long ifi_unused;
        struct timeval ifi_lastchange;
};
# 185 "net/if.h"
struct if_msghdr {
        u_short ifm_msglen;
        u_char ifm_version;
        u_char ifm_type;
        int ifm_addrs;
        int ifm_flags;
        u_short ifm_index;
        struct if_data ifm_data;
};





struct ifa_msghdr {
        u_short ifam_msglen;
        u_char ifam_version;
        u_char ifam_type;
        int ifam_addrs;
        int ifam_flags;
        u_short ifam_index;
        int ifam_metric;
};





struct ifma_msghdr {
        u_short ifmam_msglen;
        u_char ifmam_version;
        u_char ifmam_type;
        int ifmam_addrs;
        int ifmam_flags;
        u_short ifmam_index;
};




struct if_announcemsghdr {
        u_short ifan_msglen;
        u_char ifan_version;
        u_char ifan_type;
        u_short ifan_index;
        char ifan_name[16];
        u_short ifan_what;
};
# 243 "net/if.h"
struct ifreq {
        char ifr_name[16];
        union {
                struct sockaddr ifru_addr;
                struct sockaddr ifru_dstaddr;
                struct sockaddr ifru_broadaddr;
                short ifru_flags[2];
                short ifru_index;
                int ifru_metric;
                int ifru_mtu;
                int ifru_phys;
                int ifru_media;
                caddr_t ifru_data;
                int ifru_cap[2];
        } ifr_ifru;
# 271 "net/if.h"
};






struct ifaliasreq {
        char ifra_name[16];
        struct sockaddr ifra_addr;
        struct sockaddr ifra_broadaddr;
        struct sockaddr ifra_mask;
};

struct ifmediareq {
        char ifm_name[16];
        int ifm_current;
        int ifm_mask;
        int ifm_status;
        int ifm_active;
        int ifm_count;
        int *ifm_ulist;
};
# 303 "net/if.h"
struct ifstat {
        char ifs_name[16];
        char ascii[800 + 1];
};







struct ifconf {
        int ifc_len;
        union {
                caddr_t ifcu_buf;
                struct ifreq *ifcu_req;
        } ifc_ifcu;


};





struct if_laddrreq {
        char iflr_name[16];
        u_int flags;

        u_int prefixlen;
        struct sockaddr_storage addr;
        struct sockaddr_storage dstaddr;
};
# 361 "net/if.h"
struct thread;


# 1 "net/if_var.h" 1
# 69 "net/if_var.h"
struct mbuf;
struct thread;
struct rtentry;
struct rt_addrinfo;
struct socket;
struct ether_header;
# 83 "net/if_var.h"
# 1 "/usr/src/sys/sys/lock.h" 1
# 36 "/usr/src/sys/sys/lock.h"
# 1 "/usr/src/sys/sys/_lock.h" 1
# 34 "/usr/src/sys/sys/_lock.h"
struct lock_object {
        struct lock_class *lo_class;
        const char *lo_name;
        const char *lo_type;
        u_int lo_flags;
        struct { struct lock_object *tqe_next; struct lock_object **tqe_prev; } lo_list;
        struct witness *lo_witness;
};
# 37 "/usr/src/sys/sys/lock.h" 2

struct thread;
# 50 "/usr/src/sys/sys/lock.h"
struct lock_class {
        const char *lc_name;
        u_int lc_flags;
};
# 97 "/usr/src/sys/sys/lock.h"
struct lock_instance {
        struct lock_object *li_lock;
        const char *li_file;
        int li_line;
        u_int li_flags;
};
# 116 "/usr/src/sys/sys/lock.h"
struct lock_list_entry {
        struct lock_list_entry *ll_next;
        struct lock_instance ll_children[3];
        u_int ll_count;
};
# 195 "/usr/src/sys/sys/lock.h"
extern struct lock_class lock_class_mtx_sleep;
extern struct lock_class lock_class_mtx_spin;
extern struct lock_class lock_class_sx;

void witness_init(struct lock_object *);
void witness_destroy(struct lock_object *);
void witness_lock(struct lock_object *, int, const char *, int);
void witness_upgrade(struct lock_object *, int, const char *, int);
void witness_downgrade(struct lock_object *, int, const char *, int);
void witness_unlock(struct lock_object *, int, const char *, int);
void witness_save(struct lock_object *, const char **, int *);
void witness_restore(struct lock_object *, const char *, int);
int witness_list_locks(struct lock_list_entry **);
int witness_list(struct thread *);
int witness_sleep(int, struct lock_object *, const char *, int);
void witness_assert(struct lock_object *, int, const char *, int);
int witness_line(struct lock_object *);
const char *witness_file(struct lock_object *);
# 84 "net/if_var.h" 2
# 1 "/usr/src/sys/sys/mutex.h" 1
# 38 "/usr/src/sys/sys/mutex.h"
# 1 "/usr/src/sys/sys/_mutex.h" 1
# 37 "/usr/src/sys/sys/_mutex.h"
struct mtx {
        struct lock_object mtx_object;
        volatile uintptr_t mtx_lock;
        volatile u_int mtx_recurse;
        struct { struct thread *tqh_first; struct thread **tqh_last; } mtx_blocked;
        struct { struct mtx *le_next; struct mtx **le_prev; } mtx_contested;
# 53 "/usr/src/sys/sys/_mutex.h"
};
# 39 "/usr/src/sys/sys/mutex.h" 2


# 1 "/usr/src/sys/sys/pcpu.h" 1
# 45 "/usr/src/sys/sys/pcpu.h"
# 1 "/usr/src/sys/sys/vmmeter.h" 1
# 43 "/usr/src/sys/sys/vmmeter.h"
struct vmmeter {



        u_int v_swtch;
        u_int v_trap;
        u_int v_syscall;
        u_int v_intr;
        u_int v_soft;



        u_int v_vm_faults;
        u_int v_cow_faults;
        u_int v_cow_optim;
        u_int v_zfod;
        u_int v_ozfod;
        u_int v_swapin;
        u_int v_swapout;
        u_int v_swappgsin;
        u_int v_swappgsout;
        u_int v_vnodein;
        u_int v_vnodeout;
        u_int v_vnodepgsin;
        u_int v_vnodepgsout;
        u_int v_intrans;
        u_int v_reactivated;
        u_int v_pdwakeups;
        u_int v_pdpages;

        u_int v_dfree;
        u_int v_pfree;
        u_int v_tfree;



        u_int v_page_size;
        u_int v_page_count;
        u_int v_free_reserved;
        u_int v_free_target;
        u_int v_free_min;
        u_int v_free_count;
        u_int v_wire_count;
        u_int v_active_count;
        u_int v_inactive_target;
        u_int v_inactive_count;
        u_int v_cache_count;
        u_int v_cache_min;
        u_int v_cache_max;
        u_int v_pageout_free_min;
        u_int v_interrupt_free_min;
        u_int v_free_severe;



        u_int v_forks;
        u_int v_vforks;
        u_int v_rforks;
        u_int v_kthreads;
        u_int v_forkpages;
        u_int v_vforkpages;
        u_int v_rforkpages;
        u_int v_kthreadpages;
};


extern struct vmmeter cnt;





static __inline
int
vm_page_count_reserved(void)
{
    return (cnt.v_free_reserved > (cnt.v_free_count + cnt.v_cache_count));
}
# 129 "/usr/src/sys/sys/vmmeter.h"
static __inline
int
vm_page_count_severe(void)
{
    return (cnt.v_free_severe > (cnt.v_free_count + cnt.v_cache_count));
}
# 146 "/usr/src/sys/sys/vmmeter.h"
static __inline
int
vm_page_count_min(void)
{
    return (cnt.v_free_min > (cnt.v_free_count + cnt.v_cache_count));
}






static __inline
int
vm_page_count_target(void)
{
    return (cnt.v_free_target > (cnt.v_free_count + cnt.v_cache_count));
}






static __inline
int
vm_paging_target(void)
{
    return (
        (cnt.v_free_target + cnt.v_cache_min) -
        (cnt.v_free_count + cnt.v_cache_count)
    );
}





static __inline
int
vm_paging_needed(void)
{
    return (
        (cnt.v_free_reserved + cnt.v_cache_min) >
        (cnt.v_free_count + cnt.v_cache_count)
    );
}




struct vmtotal {
        int16_t t_rq;
        int16_t t_dw;
        int16_t t_pw;
        int16_t t_sl;
        int16_t t_sw;
        int32_t t_vm;
        int32_t t_avm;
        int32_t t_rm;
        int32_t t_arm;
        int32_t t_vmshr;
        int32_t t_avmshr;
        int32_t t_rmshr;
        int32_t t_armshr;
        int32_t t_free;
};
# 46 "/usr/src/sys/sys/pcpu.h" 2
# 1 "/usr/obj/usr/src/sys/GENERIC/machine/pcpu.h" 1
# 34 "/usr/obj/usr/src/sys/GENERIC/machine/pcpu.h"
# 1 "/usr/obj/usr/src/sys/GENERIC/machine/segments.h" 1
# 65 "/usr/obj/usr/src/sys/GENERIC/machine/segments.h"
struct segment_descriptor {
        unsigned sd_lolimit:16 ;
        unsigned sd_lobase:24 __attribute__((__packed__));
        unsigned sd_type:5 ;
        unsigned sd_dpl:2 ;
        unsigned sd_p:1 ;
        unsigned sd_hilimit:4 ;
        unsigned sd_xx:2 ;
        unsigned sd_def32:1 ;
        unsigned sd_gran:1 ;
        unsigned sd_hibase:8 ;
} ;




struct gate_descriptor {
        unsigned gd_looffset:16 ;
        unsigned gd_selector:16 ;
        unsigned gd_stkcpy:5 ;
        unsigned gd_xx:3 ;
        unsigned gd_type:5 ;
        unsigned gd_dpl:2 ;
        unsigned gd_p:1 ;
        unsigned gd_hioffset:16 ;
} ;




union descriptor {
        struct segment_descriptor sd;
        struct gate_descriptor gd;
};
# 142 "/usr/obj/usr/src/sys/GENERIC/machine/segments.h"
struct soft_segment_descriptor {
        unsigned ssd_base ;
        unsigned ssd_limit ;
        unsigned ssd_type:5 ;
        unsigned ssd_dpl:2 ;
        unsigned ssd_p:1 ;
        unsigned ssd_xx:4 ;
        unsigned ssd_xx1:2 ;
        unsigned ssd_def32:1 ;
        unsigned ssd_gran:1 ;
};




struct region_descriptor {
        unsigned rd_limit:16;
        unsigned rd_base:32 __attribute__((__packed__));
};
# 223 "/usr/obj/usr/src/sys/GENERIC/machine/segments.h"
extern int _default_ldt;
extern union descriptor gdt[];
extern struct soft_segment_descriptor gdt_segs[];
extern struct gate_descriptor *idt;
extern union descriptor ldt[(16 + 1)];

void lgdt(struct region_descriptor *rdp);
void sdtossd(struct segment_descriptor *sdp,
            struct soft_segment_descriptor *ssdp);
void ssdtosd(struct soft_segment_descriptor *ssdp,
            struct segment_descriptor *sdp);
# 35 "/usr/obj/usr/src/sys/GENERIC/machine/pcpu.h" 2
# 1 "/usr/obj/usr/src/sys/GENERIC/machine/tss.h" 1
# 47 "/usr/obj/usr/src/sys/GENERIC/machine/tss.h"
struct i386tss {
        int tss_link;
        int tss_esp0;
        int tss_ss0;
        int tss_esp1;
        int tss_ss1;
        int tss_esp2;
        int tss_ss2;
        int tss_cr3;
        int tss_eip;
        int tss_eflags;
        int tss_eax;
        int tss_ecx;
        int tss_edx;
        int tss_ebx;
        int tss_esp;
        int tss_ebp;
        int tss_esi;
        int tss_edi;
        int tss_es;
        int tss_cs;
        int tss_ss;
        int tss_ds;
        int tss_fs;
        int tss_gs;
        int tss_ldt;
        int tss_ioopt;

};
# 36 "/usr/obj/usr/src/sys/GENERIC/machine/pcpu.h" 2
# 47 "/usr/src/sys/sys/pcpu.h" 2

struct pcb;
struct thread;







struct pcpu {
        struct thread *pc_curthread;
        struct thread *pc_idlethread;
        struct thread *pc_fpcurthread;
        struct thread *pc_deadthread;
        struct pcb *pc_curpcb;
        struct bintime pc_switchtime;
        int pc_switchticks;
        u_int pc_cpuid;
        u_int pc_cpumask;
        u_int pc_other_cpus;
        struct { struct pcpu *sle_next; } pc_allcpu;
        struct lock_list_entry *pc_spinlocks;




        struct pcpu *pc_prvspace; struct i386tss pc_common_tss; struct segment_descriptor pc_common_tssd; struct segment_descriptor *pc_tss_gdt; int pc_currentldt; u_int32_t pc_int_pending; u_int32_t pc_ipending; u_int32_t pc_fpending; u_int32_t pc_spending;
        struct vmmeter pc_cnt;
};

struct cpuhead { struct pcpu *slh_first; };

extern struct cpuhead cpuhead;
# 109 "/usr/src/sys/sys/pcpu.h"
void cpu_pcpu_init(struct pcpu *pcpu, int cpuid, size_t size);
void db_show_mdpcpu(struct pcpu *pcpu);

void pcpu_destroy(struct pcpu *pcpu);
struct pcpu *pcpu_find(u_int cpuid);
void pcpu_init(struct pcpu *pcpu, int cpuid, size_t size);
# 42 "/usr/src/sys/sys/mutex.h" 2





# 1 "/usr/obj/usr/src/sys/GENERIC/machine/mutex.h" 1
# 40 "/usr/obj/usr/src/sys/GENERIC/machine/mutex.h"
extern struct mtx clock_lock;
# 48 "/usr/src/sys/sys/mutex.h" 2
# 100 "/usr/src/sys/sys/mutex.h"
void mtx_init(struct mtx *m, const char *name, const char *type, int opts);
void mtx_destroy(struct mtx *m);
void mtx_sysinit(void *arg);
void mutex_init(void);
void _mtx_lock_sleep(struct mtx *m, int opts, const char *file, int line);
void _mtx_unlock_sleep(struct mtx *m, int opts, const char *file, int line);
void _mtx_lock_spin(struct mtx *m, int opts, const char *file, int line);
void _mtx_unlock_spin(struct mtx *m, int opts, const char *file, int line);
int _mtx_trylock(struct mtx *m, int opts, const char *file, int line);
void _mtx_lock_flags(struct mtx *m, int opts, const char *file, int line);
void _mtx_unlock_flags(struct mtx *m, int opts, const char *file, int line);
void _mtx_lock_spin_flags(struct mtx *m, int opts, const char *file,
                             int line);
void _mtx_unlock_spin_flags(struct mtx *m, int opts, const char *file,
                             int line);

void _mtx_assert(struct mtx *m, int what, const char *file, int line);

int mtx_lock_giant(int sysctlvar);
void mtx_unlock_giant(int s);
# 242 "/usr/src/sys/sys/mutex.h"
struct mtx *mtx_pool_find(void *ptr);
struct mtx *mtx_pool_alloc(void);
void mtx_pool_lock(void *ptr);
void mtx_pool_unlock(void *ptr);

extern int mtx_pool_valid;
# 291 "/usr/src/sys/sys/mutex.h"
extern struct mtx sched_lock;
extern struct mtx Giant;




extern int kern_giant_proc;
extern int kern_giant_file;
extern int kern_giant_ucred;
# 338 "/usr/src/sys/sys/mutex.h"
struct mtx_args {
        struct mtx *ma_mtx;
        const char *ma_desc;
        int ma_opts;
};
# 85 "net/if_var.h" 2
# 1 "/usr/src/sys/sys/event.h" 1
# 52 "/usr/src/sys/sys/event.h"
struct kevent {
        uintptr_t ident;
        short filter;
        u_short flags;
        u_int fflags;
        intptr_t data;
        void *udata;
};
# 120 "/usr/src/sys/sys/event.h"
struct knote;
struct klist { struct knote *slh_first; };
# 137 "/usr/src/sys/sys/event.h"
struct filterops {
        int f_isfd;
        int (*f_attach)(struct knote *kn);
        void (*f_detach)(struct knote *kn);
        int (*f_event)(struct knote *kn, long hint);
};

struct knote {
        struct { struct knote *sle_next; } kn_link;
        struct { struct knote *sle_next; } kn_selnext;
        struct { struct knote *tqe_next; struct knote **tqe_prev; } kn_tqe;
        struct kqueue *kn_kq;
        struct kevent kn_kevent;
        int kn_status;
        int kn_sfflags;
        intptr_t kn_sdata;
        union {
                struct file *p_fp;
                struct proc *p_proc;
        } kn_ptr;
        struct filterops *kn_fop;
        void *kn_hook;
# 170 "/usr/src/sys/sys/event.h"
};

struct thread;
struct proc;

extern void knote(struct klist *list, long hint);
extern void knote_remove(struct thread *p, struct klist *list);
extern void knote_fdclose(struct thread *p, int fd);
extern int kqueue_register(struct kqueue *kq,
                    struct kevent *kev, struct thread *p);
extern int kqueue_add_filteropts(int filt, struct filterops *filtops);
extern int kqueue_del_filteropts(int filt);
# 86 "net/if_var.h" 2

struct ifnethead { struct ifnet *tqh_first; struct ifnet **tqh_last; };
struct ifaddrhead { struct ifaddr *tqh_first; struct ifaddr **tqh_last; };
struct ifprefixhead { struct ifprefix *tqh_first; struct ifprefix **tqh_last; };
struct ifmultihead { struct ifmultiaddr *tqh_first; struct ifmultiaddr **tqh_last; };




struct ifqueue {
        struct mbuf *ifq_head;
        struct mbuf *ifq_tail;
        int ifq_len;
        int ifq_maxlen;
        int ifq_drops;
        struct mtx ifq_mtx;
};
# 129 "net/if_var.h"
struct ifnet {
        void *if_softc;
        char *if_name;
        struct { struct ifnet *tqe_next; struct ifnet **tqe_prev; } if_link;
        struct ifaddrhead if_addrhead;
        struct klist if_klist;
        int if_pcount;
        struct bpf_if *if_bpf;
        u_short if_index;
        short if_unit;
        short if_timer;
        u_short if_nvlans;
        int if_flags;
        int if_capabilities;
        int if_capenable;
        int if_ipending;
        void *if_linkmib;
        size_t if_linkmiblen;
        struct if_data if_data;
        struct ifmultihead if_multiaddrs;
        int if_amcount;

        int (*if_output)
                (struct ifnet *, struct mbuf *, struct sockaddr *,
                     struct rtentry *);
        void (*if_input)
                (struct ifnet *, struct mbuf *);
        void (*if_start)
                (struct ifnet *);
        int (*if_done)
                (struct ifnet *);
        int (*if_ioctl)
                (struct ifnet *, u_long, caddr_t);
        void (*if_watchdog)
                (struct ifnet *);
        int (*if_poll_recv)
                (struct ifnet *, int *);
        int (*if_poll_xmit)
                (struct ifnet *, int *);
        void (*if_poll_intren)
                (struct ifnet *);
        void (*if_poll_slowinput)
                (struct ifnet *, struct mbuf *);
        void (*if_init)
                (void *);
        int (*if_resolvemulti)
                (struct ifnet *, struct sockaddr **, struct sockaddr *);
        struct ifqueue if_snd;
        struct ifqueue *if_poll_slowq;
        struct ifprefixhead if_prefixhead;
        u_int8_t *if_broadcastaddr;
        struct label if_label;
};

typedef void if_init_f_t(void *);
# 293 "net/if_var.h"
static __inline int
if_handoff(struct ifqueue *ifq, struct mbuf *m, struct ifnet *ifp, int adjust)
{
        int active = 0;

        _mtx_lock_flags(((&(ifq)->ifq_mtx)), (0), "net/if_var.h", 298);
        if (((ifq)->ifq_len >= (ifq)->ifq_maxlen)) {
                ((ifq)->ifq_drops++);
                _mtx_unlock_flags(((&(ifq)->ifq_mtx)), (0), "net/if_var.h", 301);
                m_freem(m);
                return (0);
        }
        if (ifp != 0) {
                ifp->if_data.ifi_obytes += m->M_dat.MH.MH_pkthdr.len + adjust;
                if (m->m_hdr.mh_flags & 0x0400)
                        ifp->if_data.ifi_omcasts++;
                active = ifp->if_flags & 0x400;
        }
        do { (m)->m_hdr.mh_nextpkt = 0; if ((ifq)->ifq_tail == 0) (ifq)->ifq_head = m; else (ifq)->ifq_tail->m_hdr.mh_nextpkt = m; (ifq)->ifq_tail = m; (ifq)->ifq_len++; } while (0);
        _mtx_unlock_flags(((&(ifq)->ifq_mtx)), (0), "net/if_var.h", 312);
        if (ifp != 0 && !active)
                (*ifp->if_start)(ifp);
        return (1);
}
# 333 "net/if_var.h"
struct ifaddr {
        struct sockaddr *ifa_addr;
        struct sockaddr *ifa_dstaddr;

        struct sockaddr *ifa_netmask;
        struct if_data if_data;
        struct ifnet *ifa_ifp;
        struct { struct ifaddr *tqe_next; struct ifaddr **tqe_prev; } ifa_link;
        void (*ifa_rtrequest)
                (int, struct rtentry *, struct rt_addrinfo *);
        u_short ifa_flags;
        u_int ifa_refcnt;
        int ifa_metric;



        int (*ifa_claim_addr)
                (struct ifaddr *, struct sockaddr *);

};
# 364 "net/if_var.h"
struct ifprefix {
        struct sockaddr *ifpr_prefix;
        struct ifnet *ifpr_ifp;
        struct { struct ifprefix *tqe_next; struct ifprefix **tqe_prev; } ifpr_list;
        u_char ifpr_plen;
        u_char ifpr_type;
};







struct ifmultiaddr {
        struct { struct ifmultiaddr *tqe_next; struct ifmultiaddr **tqe_prev; } ifma_link;
        struct sockaddr *ifma_addr;
        struct sockaddr *ifma_lladdr;
        struct ifnet *ifma_ifp;
        u_int ifma_refcount;
        void *ifma_protospec;
};
# 396 "net/if_var.h"
struct ifindex_entry {
        struct ifnet *ife_ifnet;
        struct ifaddr *ife_ifnet_addr;
        dev_t ife_dev;
};





extern struct ifnethead ifnet;
extern struct ifindex_entry *ifindex_table;
extern int ifqmaxlen;
extern struct ifnet *loif;
extern int if_index;

int if_addmulti(struct ifnet *, struct sockaddr *, struct ifmultiaddr **);
int if_allmulti(struct ifnet *, int);
void if_attach(struct ifnet *);
int if_delmulti(struct ifnet *, struct sockaddr *);
void if_detach(struct ifnet *);
void if_down(struct ifnet *);
int if_printf(struct ifnet *, const char *, ...) __attribute__((__format__ (__printf__, 2, 3)));
void if_route(struct ifnet *, int flag, int fam);
int if_setlladdr(struct ifnet *, const u_char *, int);
void if_unroute(struct ifnet *, int flag, int fam);
void if_up(struct ifnet *);

int ifioctl(struct socket *, u_long, caddr_t, struct thread *);
int ifpromisc(struct ifnet *, int);
struct ifnet *ifunit(const char *);
struct ifnet *if_withname(struct sockaddr *);

int if_poll_recv_slow(struct ifnet *ifp, int *quotap);
void if_poll_xmit_slow(struct ifnet *ifp, int *quotap);
void if_poll_throttle(void);
void if_poll_unthrottle(void *);
void if_poll_init(void);
void if_poll(void);

struct ifaddr *ifa_ifwithaddr(struct sockaddr *);
struct ifaddr *ifa_ifwithdstaddr(struct sockaddr *);
struct ifaddr *ifa_ifwithnet(struct sockaddr *);
struct ifaddr *ifa_ifwithroute(int, struct sockaddr *, struct sockaddr *);
struct ifaddr *ifaof_ifpforaddr(struct sockaddr *, struct ifnet *);
void ifafree(struct ifaddr *);

struct ifmultiaddr *ifmaof_ifpforaddr(struct sockaddr *, struct ifnet *);
int if_simloop(struct ifnet *ifp, struct mbuf *m, int af, int hlen);

void if_clone_attach(struct if_clone *);
void if_clone_detach(struct if_clone *);

int if_clone_create(char *, int);
int if_clone_destroy(const char *);
# 365 "net/if.h" 2
# 51 "netinet/ip_icmp.c" 2
# 1 "net/if_types.h" 1
# 52 "netinet/ip_icmp.c" 2
# 1 "net/route.h" 1
# 52 "net/route.h"
struct route {
        struct rtentry *ro_rt;
        struct sockaddr ro_dst;
};





struct rt_metrics {
        u_long rmx_locks;
        u_long rmx_mtu;
        u_long rmx_hopcount;
        u_long rmx_expire;
        u_long rmx_recvpipe;
        u_long rmx_sendpipe;
        u_long rmx_ssthresh;
        u_long rmx_rtt;
        u_long rmx_rttvar;
        u_long rmx_pksent;
        u_long rmx_filler[4];
};
# 86 "net/route.h"
struct mbuf;
# 97 "net/route.h"
# 1 "net/radix.h" 1
# 48 "net/radix.h"
struct radix_node {
        struct radix_mask *rn_mklist;
        struct radix_node *rn_parent;
        short rn_bit;
        char rn_bmask;
        u_char rn_flags;



        union {
                struct {
                        caddr_t rn_Key;
                        caddr_t rn_Mask;
                        struct radix_node *rn_Dupedkey;
                } rn_leaf;
                struct {
                        int rn_Off;
                        struct radix_node *rn_L;
                        struct radix_node *rn_R;
                } rn_node;
        } rn_u;





};
# 87 "net/radix.h"
struct radix_mask {
        short rm_bit;
        char rm_unused;
        u_char rm_flags;
        struct radix_mask *rm_mklist;
        union {
                caddr_t rmu_mask;
                struct radix_node *rmu_leaf;
        } rm_rmu;
        int rm_refs;
};
# 111 "net/radix.h"
typedef int walktree_f_t(struct radix_node *, void *);

struct radix_node_head {
        struct radix_node *rnh_treetop;
        int rnh_addrsize;
        int rnh_pktsize;
        struct radix_node *(*rnh_addaddr)
                (void *v, void *mask,
                     struct radix_node_head *head, struct radix_node nodes[]);
        struct radix_node *(*rnh_addpkt)
                (void *v, void *mask,
                     struct radix_node_head *head, struct radix_node nodes[]);
        struct radix_node *(*rnh_deladdr)
                (void *v, void *mask, struct radix_node_head *head);
        struct radix_node *(*rnh_delpkt)
                (void *v, void *mask, struct radix_node_head *head);
        struct radix_node *(*rnh_matchaddr)
                (void *v, struct radix_node_head *head);
        struct radix_node *(*rnh_lookup)
                (void *v, void *mask, struct radix_node_head *head);
        struct radix_node *(*rnh_matchpkt)
                (void *v, struct radix_node_head *head);
        int (*rnh_walktree)
                (struct radix_node_head *head, walktree_f_t *f, void *w);
        int (*rnh_walktree_from)
                (struct radix_node_head *head, void *a, void *m,
                     walktree_f_t *f, void *w);
        void (*rnh_close)
                (struct radix_node *rn, struct radix_node_head *head);
        struct radix_node rnh_nodes[3];
};
# 157 "net/radix.h"
void rn_init(void);
int rn_inithead(void **, int);
int rn_refines(void *, void *);
struct radix_node
         *rn_addmask(void *, int, int),
         *rn_addroute (void *, void *, struct radix_node_head *,
                        struct radix_node [2]),
         *rn_delete(void *, void *, struct radix_node_head *),
         *rn_lookup (void *v_arg, void *m_arg,
                        struct radix_node_head *head),
         *rn_match(void *, struct radix_node_head *);
# 98 "net/route.h" 2

struct rtentry {
        struct radix_node rt_nodes[2];


        struct sockaddr *rt_gateway;
        long rt_refcnt;
        u_long rt_flags;
        struct ifnet *rt_ifp;
        struct ifaddr *rt_ifa;
        struct sockaddr *rt_genmask;
        caddr_t rt_llinfo;
        struct rt_metrics rt_rmx;
        struct rtentry *rt_gwroute;
        int (*rt_output)(struct ifnet *, struct mbuf *, struct sockaddr *,
                    struct rtentry *);

        struct rtentry *rt_parent;
        void *rt_filler2;
};





struct ortentry {
        u_long rt_hash;
        struct sockaddr rt_dst;
        struct sockaddr rt_gateway;
        short rt_flags;
        short rt_refcnt;
        u_long rt_use;
        struct ifnet *rt_ifp;
};
# 164 "net/route.h"
struct rtstat {
        short rts_badredirect;
        short rts_dynamic;
        short rts_newgateway;
        short rts_unreach;
        short rts_wildcard;
};



struct rt_msghdr {
        u_short rtm_msglen;
        u_char rtm_version;
        u_char rtm_type;
        u_short rtm_index;
        int rtm_flags;
        int rtm_addrs;
        pid_t rtm_pid;
        int rtm_seq;
        int rtm_errno;
        int rtm_use;
        u_long rtm_inits;
        struct rt_metrics rtm_rmx;
};
# 249 "net/route.h"
struct rt_addrinfo {
        int rti_addrs;
        struct sockaddr *rti_info[8];
        int rti_flags;
        struct ifaddr *rti_ifa;
        struct ifnet *rti_ifp;
};

struct route_cb {
        int ip_count;
        int ip6_count;
        int ipx_count;
        int ns_count;
        int any_count;
};
# 274 "net/route.h"
extern struct route_cb route_cb;
extern struct radix_node_head *rt_tables[35 +1];

struct ifmultiaddr;

void route_init(void);
int rt_getifa(struct rt_addrinfo *);
void rt_ifannouncemsg(struct ifnet *, int);
void rt_ifmsg(struct ifnet *);
void rt_missmsg(int, struct rt_addrinfo *, int, int);
void rt_newaddrmsg(int, struct ifaddr *, int, struct rtentry *);
void rt_newmaddrmsg(int, struct ifmultiaddr *);
int rt_setgate(struct rtentry *, struct sockaddr *, struct sockaddr *);
void rtalloc(struct route *);
void rtalloc_ign(struct route *, u_long);
struct rtentry *
         rtalloc1(struct sockaddr *, int, u_long);
void rtfree(struct rtentry *);
int rtinit(struct ifaddr *, int, int);
int rtioctl(u_long, caddr_t);
void rtredirect(struct sockaddr *, struct sockaddr *,
            struct sockaddr *, int, struct sockaddr *, struct rtentry **);
int rtrequest(int, struct sockaddr *,
            struct sockaddr *, struct sockaddr *, int, struct rtentry **);
int rtrequest1(int, struct rt_addrinfo *, struct rtentry **);
# 53 "netinet/ip_icmp.c" 2

# 1 "netinet/in.h" 1
# 85 "netinet/in.h"
struct in_addr {
        in_addr_t s_addr;
};




struct sockaddr_in {
        uint8_t sin_len;
        sa_family_t sin_family;
        in_port_t sin_port;
        struct in_addr sin_addr;
        char sin_zero[8];
};
# 412 "netinet/in.h"
struct ip_mreq {
        struct in_addr imr_multiaddr;
        struct in_addr imr_interface;
};
# 533 "netinet/in.h"
struct ifnet; struct mbuf;

int in_broadcast(struct in_addr, struct ifnet *);
int in_canforward(struct in_addr);
int in_localaddr(struct in_addr);
char *inet_ntoa(struct in_addr);
char *inet_ntoa_r(struct in_addr ina, char *buf);
# 553 "netinet/in.h"
# 1 "netinet6/in6.h" 1
# 121 "netinet6/in6.h"
struct in6_addr {
        union {
                uint8_t __u6_addr8[16];
                uint16_t __u6_addr16[8];
                uint32_t __u6_addr32[4];
        } __u6_addr;
};
# 149 "netinet6/in6.h"
struct sockaddr_in6 {
        uint8_t sin6_len;
        sa_family_t sin6_family;
        in_port_t sin6_port;
        uint32_t sin6_flowinfo;
        struct in6_addr sin6_addr;
        uint32_t sin6_scope_id;
};
# 174 "netinet6/in6.h"
extern const struct sockaddr_in6 sa6_any;

extern const struct in6_addr in6mask0;
extern const struct in6_addr in6mask32;
extern const struct in6_addr in6mask64;
extern const struct in6_addr in6mask96;
extern const struct in6_addr in6mask128;
# 229 "netinet6/in6.h"
extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;

extern const struct in6_addr in6addr_nodelocal_allnodes;
extern const struct in6_addr in6addr_linklocal_allnodes;
extern const struct in6_addr in6addr_linklocal_allrouters;
# 392 "netinet6/in6.h"
struct route_in6 {
        struct rtentry *ro_rt;
        struct sockaddr_in6 ro_dst;
};
# 464 "netinet6/in6.h"
struct ipv6_mreq {
        struct in6_addr ipv6mr_multiaddr;
        unsigned int ipv6mr_interface;
};




struct in6_pktinfo {
        struct in6_addr ipi6_addr;
        unsigned int ipi6_ifindex;
};
# 594 "netinet6/in6.h"
struct cmsghdr;

int in6_cksum (struct mbuf *, u_int8_t, u_int32_t, u_int32_t);
int in6_localaddr (struct in6_addr *);
int in6_addrscope (struct in6_addr *);
struct in6_ifaddr *in6_ifawithscope (struct ifnet *, struct in6_addr *);
struct in6_ifaddr *in6_ifawithifp (struct ifnet *, struct in6_addr *);
extern void in6_if_up (struct ifnet *);
struct sockaddr;
extern u_char ip6_protox[];

void in6_sin6_2_sin (struct sockaddr_in *sin, struct sockaddr_in6 *sin6);

void in6_sin_2_v4mapsin6 (struct sockaddr_in *sin, struct sockaddr_in6 *sin6);

void in6_sin6_2_sin_in_sock (struct sockaddr *nam);
void in6_sin_2_v4mapsin6_in_sock (struct sockaddr **nam);





extern int (*faithprefix_p)(struct in6_addr *);








struct cmsghdr;

extern int inet6_option_space (int);
extern int inet6_option_init (void *, struct cmsghdr **, int);
extern int inet6_option_append (struct cmsghdr *, const uint8_t *, int, int);

extern uint8_t *inet6_option_alloc (struct cmsghdr *, int, int, int);
extern int inet6_option_next (const struct cmsghdr *, uint8_t **);
extern int inet6_option_find (const struct cmsghdr *, uint8_t **, int);

extern size_t inet6_rthdr_space (int, int);
extern struct cmsghdr *inet6_rthdr_init (void *, int);
extern int inet6_rthdr_add (struct cmsghdr *, const struct in6_addr *, unsigned int);

extern int inet6_rthdr_lasthop (struct cmsghdr *, unsigned int);



extern int inet6_rthdr_segments (const struct cmsghdr *);
extern struct in6_addr *inet6_rthdr_getaddr (struct cmsghdr *, int);
extern int inet6_rthdr_getflags (const struct cmsghdr *, int);

extern int inet6_opt_init (void *, size_t);
extern int inet6_opt_append (void *, size_t, int, uint8_t, size_t, uint8_t, void **);

extern int inet6_opt_finish (void *, size_t, int);
extern int inet6_opt_set_val (void *, size_t, void *, int);

extern int inet6_opt_next (void *, size_t, int, uint8_t *, size_t *, void **);

extern int inet6_opt_find (void *, size_t, int, uint8_t, size_t *, void **);

extern int inet6_opt_get_val (void *, size_t, void *, int);
extern size_t inet6_rth_space (int, int);
extern void *inet6_rth_init (void *, int, int, int);
extern int inet6_rth_add (void *, const struct in6_addr *);
extern int inet6_rth_reverse (const void *, void *);
extern int inet6_rth_segments (const void *);
extern struct in6_addr *inet6_rth_getaddr (const void *, int);

# 554 "netinet/in.h" 2
# 55 "netinet/ip_icmp.c" 2
# 1 "netinet/in_systm.h" 1
# 53 "netinet/in_systm.h"
typedef u_int16_t n_short;
typedef u_int32_t n_long;

typedef u_int32_t n_time;


n_time iptime(void);
# 56 "netinet/ip_icmp.c" 2
# 1 "netinet/in_var.h" 1
# 41 "netinet/in_var.h"
# 1 "/usr/src/sys/sys/fnv_hash.h" 1
# 11 "/usr/src/sys/sys/fnv_hash.h"
typedef u_int32_t Fnv32_t;
typedef u_int64_t Fnv64_t;







static __inline Fnv32_t
fnv_32_buf(const void *buf, size_t len, Fnv32_t hval)
{
        const u_int8_t *s = (const u_int8_t *)buf;

        while (len-- != 0) {
                hval *= ((Fnv32_t) 0x01000193UL);
                hval ^= *s++;
        }
        return hval;
}

static __inline Fnv32_t
fnv_32_str(const char *str, Fnv32_t hval)
{
        const u_int8_t *s = (const u_int8_t *)str;
        Fnv32_t c;

        while ((c = *s++) != 0) {
                hval *= ((Fnv32_t) 0x01000193UL);
                hval ^= c;
        }
        return hval;
}

static __inline Fnv64_t
fnv_64_buf(const void *buf, size_t len, Fnv64_t hval)
{
        const u_int8_t *s = (const u_int8_t *)buf;

        while (len-- != 0) {
                hval *= ((Fnv64_t) 0x100000001b3ULL);
                hval ^= *s++;
        }
        return hval;
}

static __inline Fnv64_t
fnv_64_str(const char *str, Fnv64_t hval)
{
        const u_int8_t *s = (const u_int8_t *)str;
        u_register_t c;

        while ((c = *s++) != 0) {
                hval *= ((Fnv64_t) 0x100000001b3ULL);
                hval ^= c;
        }
        return hval;
}
# 42 "netinet/in_var.h" 2







struct in_ifaddr {
        struct ifaddr ia_ifa;



        u_long ia_net;
        u_long ia_netmask;
        u_long ia_subnet;
        u_long ia_subnetmask;
        struct in_addr ia_netbroadcast;
        struct { struct in_ifaddr *le_next; struct in_ifaddr **le_prev; } ia_hash;
        struct { struct in_ifaddr *tqe_next; struct in_ifaddr **tqe_prev; } ia_link;
        struct sockaddr_in ia_addr;
        struct sockaddr_in ia_dstaddr;

        struct sockaddr_in ia_sockmask;
};

struct in_aliasreq {
        char ifra_name[16];
        struct sockaddr_in ifra_addr;
        struct sockaddr_in ifra_broadaddr;

        struct sockaddr_in ifra_mask;
};
# 86 "netinet/in_var.h"
extern struct ifqueue ipintrq;
extern struct in_addr zeroin_addr;
extern u_char inetctlerrmap[];




extern struct in_ifaddrhashhead { struct in_ifaddr *lh_first; } *in_ifaddrhashtbl;
extern struct in_ifaddrhead { struct in_ifaddr *tqh_first; struct in_ifaddr **tqh_last; } in_ifaddrhead;
extern u_long in_ifaddrhmask;
# 140 "netinet/in_var.h"
struct router_info {
        struct ifnet *rti_ifp;
        int rti_type;
        int rti_time;
        struct router_info *rti_next;
};
# 155 "netinet/in_var.h"
struct in_multi {
        struct { struct in_multi *le_next; struct in_multi **le_prev; } inm_link;
        struct in_addr inm_addr;
        struct ifnet *inm_ifp;
        struct ifmultiaddr *inm_ifma;
        u_int inm_timer;
        u_int inm_state;
        struct router_info *inm_rti;
};




extern struct sysctl_oid_list sysctl__net_inet_ip_children;
extern struct sysctl_oid_list sysctl__net_inet_raw_children;


extern struct in_multihead { struct in_multi *lh_first; } in_multihead;





struct in_multistep {
        struct in_multi *i_inm;
};
# 225 "netinet/in_var.h"
struct route;
struct in_multi *in_addmulti(struct in_addr *, struct ifnet *);
void in_delmulti(struct in_multi *);
int in_control(struct socket *, u_long, caddr_t, struct ifnet *,
            struct thread *);
void in_rtqdrain(void);
void ip_input(struct mbuf *);
int in_ifadown(struct ifaddr *ifa, int);
void in_ifscrub(struct ifnet *, struct in_ifaddr *);
int ipflow_fastforward(struct mbuf *);
void ipflow_create(const struct route *, struct mbuf *);
void ipflow_slowtimo(void);




# 1 "netinet6/in6_var.h" 1
# 86 "netinet6/in6_var.h"
struct in6_addrlifetime {
        time_t ia6t_expire;
        time_t ia6t_preferred;
        u_int32_t ia6t_vltime;
        u_int32_t ia6t_pltime;
};

struct in6_ifaddr {
        struct ifaddr ia_ifa;


        struct sockaddr_in6 ia_addr;
        struct sockaddr_in6 ia_net;
        struct sockaddr_in6 ia_dstaddr;
        struct sockaddr_in6 ia_prefixmask;
        u_int32_t ia_plen;
        struct in6_ifaddr *ia_next;
        int ia6_flags;

        struct in6_addrlifetime ia6_lifetime;
        struct ifprefix *ia6_ifpr;

        struct nd_prefix *ia6_ndpr;


};




struct in6_ifstat {
        u_quad_t ifs6_in_receive;
        u_quad_t ifs6_in_hdrerr;
        u_quad_t ifs6_in_toobig;
        u_quad_t ifs6_in_noroute;
        u_quad_t ifs6_in_addrerr;
        u_quad_t ifs6_in_protounknown;

        u_quad_t ifs6_in_truncated;
        u_quad_t ifs6_in_discard;

        u_quad_t ifs6_in_deliver;

        u_quad_t ifs6_out_forward;

        u_quad_t ifs6_out_request;

        u_quad_t ifs6_out_discard;
        u_quad_t ifs6_out_fragok;
        u_quad_t ifs6_out_fragfail;
        u_quad_t ifs6_out_fragcreat;

        u_quad_t ifs6_reass_reqd;

        u_quad_t ifs6_reass_ok;


        u_quad_t ifs6_reass_fail;


        u_quad_t ifs6_in_mcast;
        u_quad_t ifs6_out_mcast;
};





struct icmp6_ifstat {




        u_quad_t ifs6_in_msg;

        u_quad_t ifs6_in_error;

        u_quad_t ifs6_in_dstunreach;

        u_quad_t ifs6_in_adminprohib;

        u_quad_t ifs6_in_timeexceed;

        u_quad_t ifs6_in_paramprob;

        u_quad_t ifs6_in_pkttoobig;

        u_quad_t ifs6_in_echo;

        u_quad_t ifs6_in_echoreply;

        u_quad_t ifs6_in_routersolicit;

        u_quad_t ifs6_in_routeradvert;

        u_quad_t ifs6_in_neighborsolicit;

        u_quad_t ifs6_in_neighboradvert;

        u_quad_t ifs6_in_redirect;

        u_quad_t ifs6_in_mldquery;

        u_quad_t ifs6_in_mldreport;

        u_quad_t ifs6_in_mlddone;





        u_quad_t ifs6_out_msg;

        u_quad_t ifs6_out_error;

        u_quad_t ifs6_out_dstunreach;

        u_quad_t ifs6_out_adminprohib;

        u_quad_t ifs6_out_timeexceed;

        u_quad_t ifs6_out_paramprob;

        u_quad_t ifs6_out_pkttoobig;

        u_quad_t ifs6_out_echo;

        u_quad_t ifs6_out_echoreply;

        u_quad_t ifs6_out_routersolicit;

        u_quad_t ifs6_out_routeradvert;

        u_quad_t ifs6_out_neighborsolicit;

        u_quad_t ifs6_out_neighboradvert;

        u_quad_t ifs6_out_redirect;

        u_quad_t ifs6_out_mldquery;

        u_quad_t ifs6_out_mldreport;

        u_quad_t ifs6_out_mlddone;
};

struct in6_ifreq {
        char ifr_name[16];
        union {
                struct sockaddr_in6 ifru_addr;
                struct sockaddr_in6 ifru_dstaddr;
                int ifru_flags;
                int ifru_flags6;
                int ifru_metric;
                caddr_t ifru_data;
                struct in6_addrlifetime ifru_lifetime;
                struct in6_ifstat ifru_stat;
                struct icmp6_ifstat ifru_icmp6stat;
                u_int32_t ifru_scope_id[16];
        } ifr_ifru;
};

struct in6_aliasreq {
        char ifra_name[16];
        struct sockaddr_in6 ifra_addr;
        struct sockaddr_in6 ifra_broadaddr;
        struct sockaddr_in6 ifra_prefixmask;
        int ifra_flags;
        struct in6_addrlifetime ifra_lifetime;
};
# 265 "netinet6/in6_var.h"
struct in6_prflags {
        struct prf_ra {
                u_char onlink : 1;
                u_char autonomous : 1;
                u_char reserved : 6;
        } prf_ra;
        u_char prf_reserved1;
        u_short prf_reserved2;

        struct prf_rr {
                u_char decrvalid : 1;
                u_char decrprefd : 1;
                u_char reserved : 6;
        } prf_rr;
        u_char prf_reserved3;
        u_short prf_reserved4;
};

struct in6_prefixreq {
        char ipr_name[16];
        u_char ipr_origin;
        u_char ipr_plen;
        u_int32_t ipr_vltime;
        u_int32_t ipr_pltime;
        struct in6_prflags ipr_flags;
        struct sockaddr_in6 ipr_prefix;
};
# 306 "netinet6/in6_var.h"
struct in6_rrenumreq {
        char irr_name[16];
        u_char irr_origin;
        u_char irr_m_len;
        u_char irr_m_minlen;
        u_char irr_m_maxlen;
        u_char irr_u_uselen;
        u_char irr_u_keeplen;
        struct irr_raflagmask {
                u_char onlink : 1;
                u_char autonomous : 1;
                u_char reserved : 6;
        } irr_raflagmask;
        u_int32_t irr_vltime;
        u_int32_t irr_pltime;
        struct in6_prflags irr_flags;
        struct sockaddr_in6 irr_matchprefix;
        struct sockaddr_in6 irr_useprefix;
};
# 447 "netinet6/in6_var.h"
extern struct in6_ifaddr *in6_ifaddr;

extern struct in6_ifstat **in6_ifstat;
extern size_t in6_ifstatmax;
extern struct icmp6stat icmp6stat;
extern struct icmp6_ifstat **icmp6_ifstat;
extern size_t icmp6_ifstatmax;
# 463 "netinet6/in6_var.h"
extern struct ifqueue ip6intrq;
extern struct in6_addr zeroin6_addr;
extern u_char inet6ctlerrmap[];
extern unsigned long in6_maxmtu;
# 496 "netinet6/in6_var.h"
struct in6_multi_mship {
        struct in6_multi *i6mm_maddr;
        struct { struct in6_multi_mship *le_next; struct in6_multi_mship **le_prev; } i6mm_chain;
};

struct in6_multi {
        struct { struct in6_multi *le_next; struct in6_multi **le_prev; } in6m_entry;
        struct in6_addr in6m_addr;
        struct ifnet *in6m_ifp;
        struct ifmultiaddr *in6m_ifma;
        u_int in6m_refcount;
        u_int in6m_state;
        u_int in6m_timer;
};


extern struct in6_multihead { struct in6_multi *lh_first; } in6_multihead;





struct in6_multistep {
        struct in6_ifaddr *i_ia;
        struct in6_multi *i_in6m;
};
# 567 "netinet6/in6_var.h"
struct in6_multi *in6_addmulti (struct in6_addr *, struct ifnet *, int *);

void in6_delmulti (struct in6_multi *);
extern int in6_ifindex2scopeid (int);
extern int in6_mask2len (struct in6_addr *, u_char *);
extern void in6_len2mask (struct in6_addr *, int);
int in6_control (struct socket *, u_long, caddr_t, struct ifnet *, struct thread *);

int in6_update_ifa (struct ifnet *, struct in6_aliasreq *, struct in6_ifaddr *);

void in6_purgeaddr (struct ifaddr *);
int in6if_do_dad (struct ifnet *);
void in6_purgeif (struct ifnet *);
void in6_savemkludge (struct in6_ifaddr *);
void in6_setmaxmtu (void);
void in6_restoremkludge (struct in6_ifaddr *, struct ifnet *);
void in6_purgemkludge (struct ifnet *);
struct in6_ifaddr *in6ifa_ifpforlinklocal (struct ifnet *, int);
struct in6_ifaddr *in6ifa_ifpwithaddr (struct ifnet *, struct in6_addr *);

char *ip6_sprintf (const struct in6_addr *);
int in6_addr2scopeid (struct ifnet *, struct in6_addr *);
int in6_matchlen (struct in6_addr *, struct in6_addr *);
int in6_are_prefix_equal (struct in6_addr *p1, struct in6_addr *p2, int len);

void in6_prefixlen2mask (struct in6_addr *maskp, int len);
int in6_prefix_ioctl (struct socket *so, u_long cmd, caddr_t data, struct ifnet *ifp);

int in6_prefix_add_ifid (int iilen, struct in6_ifaddr *ia);
void in6_prefix_remove_ifid (int iilen, struct in6_ifaddr *ia);
void in6_purgeprefix (struct ifnet *);

int in6_is_addr_deprecated (struct sockaddr_in6 *);
struct inpcb;
int in6_embedscope (struct in6_addr *, const struct sockaddr_in6 *, struct inpcb *, struct ifnet **);

int in6_recoverscope (struct sockaddr_in6 *, const struct in6_addr *, struct ifnet *);

void in6_clearscope (struct in6_addr *);
# 242 "netinet/in_var.h" 2
# 57 "netinet/ip_icmp.c" 2
# 1 "netinet/ip.h" 1
# 49 "netinet/ip.h"
struct ip {

        u_int ip_hl:4,
                ip_v:4;





        u_char ip_tos;
        u_short ip_len;
        u_short ip_id;
        u_short ip_off;




        u_char ip_ttl;
        u_char ip_p;
        u_short ip_sum;
        struct in_addr ip_src,ip_dst;
} __attribute__((__packed__));


typedef char __assert73[(sizeof (struct ip) == 20) ? 1 : -1];
# 138 "netinet/ip.h"
struct ip_timestamp {
        u_char ipt_code;
        u_char ipt_len;
        u_char ipt_ptr;

        u_int ipt_flg:4,
                ipt_oflw:4;





        union ipt_timestamp {
                n_long ipt_time[1];
                struct ipt_ta {
                        struct in_addr ipt_addr;
                        n_long ipt_time;
                } ipt_ta[1];
        } ipt_timestamp;
};
# 58 "netinet/ip_icmp.c" 2
# 1 "netinet/ip_icmp.h" 1
# 48 "netinet/ip_icmp.h"
struct icmp_ra_addr {
        u_int32_t ira_addr;
        u_int32_t ira_preference;
};




struct icmp {
        u_char icmp_type;
        u_char icmp_code;
        u_short icmp_cksum;
        union {
                u_char ih_pptr;
                struct in_addr ih_gwaddr;
                struct ih_idseq {
                        n_short icd_id;
                        n_short icd_seq;
                } ih_idseq;
                int ih_void;


                struct ih_pmtu {
                        n_short ipm_void;
                        n_short ipm_nextmtu;
                } ih_pmtu;

                struct ih_rtradv {
                        u_char irt_num_addrs;
                        u_char irt_wpa;
                        u_int16_t irt_lifetime;
                } ih_rtradv;
        } icmp_hun;
# 91 "netinet/ip_icmp.h"
        union {
                struct id_ts {
                        n_time its_otime;
                        n_time its_rtime;
                        n_time its_ttime;
                } id_ts;
                struct id_ip {
                        struct ip idi_ip;

                } id_ip;
                struct icmp_ra_addr id_radv;
                u_int32_t id_mask;
                char id_data[1];
        } icmp_dun;







};
# 183 "netinet/ip_icmp.h"
void icmp_error(struct mbuf *, int, int, n_long, struct ifnet *);
void icmp_input(struct mbuf *, int);
# 59 "netinet/ip_icmp.c" 2
# 1 "netinet/ip_var.h" 1
# 49 "netinet/ip_var.h"
struct ipovly {
        u_char ih_x1[9];
        u_char ih_pr;
        u_short ih_len;
        struct in_addr ih_src;
        struct in_addr ih_dst;
};
# 64 "netinet/ip_var.h"
struct ipq {
        struct { struct ipq *tqe_next; struct ipq **tqe_prev; } ipq_list;
        u_char ipq_ttl;
        u_char ipq_p;
        u_short ipq_id;
        struct mbuf *ipq_frags;
        struct in_addr ipq_src,ipq_dst;
        u_int32_t ipq_div_info;
        u_int16_t ipq_div_cookie;
        struct label ipq_label;
};
# 85 "netinet/ip_var.h"
struct ipoption {
        struct in_addr ipopt_dst;
        char ipopt_list[40];
};





struct ip_moptions {
        struct ifnet *imo_multicast_ifp;
        struct in_addr imo_multicast_addr;
        u_char imo_multicast_ttl;
        u_char imo_multicast_loop;
        u_short imo_num_memberships;
        struct in_multi *imo_membership[20];
        u_long imo_multicast_vif;
};

struct ipstat {
        u_long ips_total;
        u_long ips_badsum;
        u_long ips_tooshort;
        u_long ips_toosmall;
        u_long ips_badhlen;
        u_long ips_badlen;
        u_long ips_fragments;
        u_long ips_fragdropped;
        u_long ips_fragtimeout;
        u_long ips_forward;
        u_long ips_fastforward;
        u_long ips_cantforward;
        u_long ips_redirectsent;
        u_long ips_noproto;
        u_long ips_delivered;
        u_long ips_localout;
        u_long ips_odropped;
        u_long ips_reassembled;
        u_long ips_fragmented;
        u_long ips_ofragments;
        u_long ips_cantfrag;
        u_long ips_badoptions;
        u_long ips_noroute;
        u_long ips_badvers;
        u_long ips_rawout;
        u_long ips_toolong;
        u_long ips_notmember;
        u_long ips_nogif;
        u_long ips_badaddr;
};
# 144 "netinet/ip_var.h"
struct ip;
struct inpcb;
struct route;
struct sockopt;

extern struct ipstat ipstat;

extern u_short ip_id;

extern int ip_defttl;
extern int ipforwarding;
extern struct route ipforward_rt;
extern u_char ip_protox[];
extern struct socket *ip_rsvpd;
extern struct socket *ip_mrouter;
extern int (*legal_vif_num)(int);
extern u_long (*ip_mcast_src)(int);
extern int rsvp_on;
extern struct pr_usrreqs rip_usrreqs;

int ip_ctloutput(struct socket *, struct sockopt *sopt);
void ip_drain(void);
void ip_freemoptions(struct ip_moptions *);
void ip_init(void);
extern int (*ip_mforward)(struct ip *, struct ifnet *, struct mbuf *,
                          struct ip_moptions *);
int ip_output(struct mbuf *,
            struct mbuf *, struct route *, int, struct ip_moptions *,
            struct inpcb *);
struct in_ifaddr *
         ip_rtaddr(struct in_addr, struct route *);
void ip_savecontrol(struct inpcb *, struct mbuf **, struct ip *,
                struct mbuf *);
void ip_slowtimo(void);
struct mbuf *
         ip_srcroute(void);
void ip_stripoptions(struct mbuf *, struct mbuf *);




int rip_ctloutput(struct socket *, struct sockopt *);
void rip_ctlinput(int, struct sockaddr *, void *);
void rip_init(void);
void rip_input(struct mbuf *, int);
int rip_output(struct mbuf *, struct socket *, u_long);
void ipip_input(struct mbuf *, int);
void rsvp_input(struct mbuf *, int);
int ip_rsvp_init(struct socket *);
int ip_rsvp_done(void);
extern int (*ip_rsvp_vif)(struct socket *, struct sockopt *);
extern void (*ip_rsvp_force_done)(struct socket *);
extern void (*rsvp_input_p)(struct mbuf *m, int off);
# 206 "netinet/ip_var.h"
void in_delayed_cksum(struct mbuf *m);
# 60 "netinet/ip_icmp.c" 2
# 1 "netinet/icmp_var.h" 1
# 45 "netinet/icmp_var.h"
struct icmpstat {

        u_long icps_error;
        u_long icps_oldshort;
        u_long icps_oldicmp;
        u_long icps_outhist[18 + 1];

        u_long icps_badcode;
        u_long icps_tooshort;
        u_long icps_checksum;
        u_long icps_badlen;
        u_long icps_reflect;
        u_long icps_inhist[18 + 1];
        u_long icps_bmcastecho;
        u_long icps_bmcasttstamp;
        u_long icps_badaddr;
        u_long icps_noroute;
};
# 80 "netinet/icmp_var.h"
extern struct sysctl_oid_list sysctl__net_inet_icmp_children;
extern int badport_bandlim(int);
# 61 "netinet/ip_icmp.c" 2
# 73 "netinet/ip_icmp.c"
# 1 "/usr/obj/usr/src/sys/GENERIC/machine/in_cksum.h" 1
# 57 "/usr/obj/usr/src/sys/GENERIC/machine/in_cksum.h"
static __inline u_int
in_cksum_hdr(const struct ip *ip)
{
        register u_int sum = 0;
# 69 "/usr/obj/usr/src/sys/GENERIC/machine/in_cksum.h"
        __asm volatile ("addl %1, %0" : "+r" (sum) : "g" (((const u_int32_t *)ip)[0 / 4]));
        __asm volatile ("adcl %1, %0" : "+r" (sum) : "g" (((const u_int32_t *)ip)[4 / 4]));
        __asm volatile ("adcl %1, %0" : "+r" (sum) : "g" (((const u_int32_t *)ip)[8 / 4]));
        __asm volatile ("adcl %1, %0" : "+r" (sum) : "g" (((const u_int32_t *)ip)[12 / 4]));
        __asm volatile ("adcl %1, %0" : "+r" (sum) : "g" (((const u_int32_t *)ip)[16 / 4]));
        __asm volatile ("adcl $0, %0" : "+r" (sum));



        sum = (sum & 0xffff) + (sum >> 16);
        if (sum > 0xffff)
                sum -= 0xffff;

        return ~sum & 0xffff;
}

static __inline void
in_cksum_update(struct ip *ip)
{
        int __tmpsum;
        __tmpsum = (int)__bswap16(ip->ip_sum) + 256;
        ip->ip_sum = __bswap16(__tmpsum + (__tmpsum >> 16));
}

static __inline u_short
in_addword(u_short sum, u_short b)
{

        __asm volatile ("addw %1, %0" : "+r" (sum) : "r" (b));
        __asm volatile ("adcw $0, %0" : "+r" (sum));

        return (sum);
}

static __inline u_short
in_pseudo(u_int sum, u_int b, u_int c)
{

        __asm volatile ("addl %1, %0" : "+r" (sum) : "g" (b));
        __asm volatile ("adcl %1, %0" : "+r" (sum) : "g" (c));
        __asm volatile ("adcl $0, %0" : "+r" (sum));

        sum = (sum & 0xffff) + (sum >> 16);
        if (sum > 0xffff)
                sum -= 0xffff;
        return (sum);
}
# 129 "/usr/obj/usr/src/sys/GENERIC/machine/in_cksum.h"
u_short in_cksum_skip(struct mbuf *m, int len, int skip);
# 74 "netinet/ip_icmp.c" 2







static struct icmpstat icmpstat;
static struct sysctl_oid sysctl___net_inet_icmp_stats = { &sysctl__net_inet_icmp_children, { 0 }, 2, 5|((0x80000000|0x40000000)), &icmpstat, sizeof(struct icmpstat), "stats", sysctl_handle_opaque, "S," "icmpstat", 0, "" }; static void const * const __set_sysctl_set_sym_sysctl___net_inet_icmp_stats __attribute__((__section__("set_" "sysctl_set"))) __attribute__((__unused__)) = &sysctl___net_inet_icmp_stats;


static int icmpmaskrepl = 0;
static struct sysctl_oid sysctl___net_inet_icmp_maskrepl = { &sysctl__net_inet_icmp_children, { 0 }, 1, 2|((0x80000000|0x40000000)), &icmpmaskrepl, 0, "maskrepl", sysctl_handle_int, "I", 0, "" }; static void const * const __set_sysctl_set_sym_sysctl___net_inet_icmp_maskrepl __attribute__((__section__("set_" "sysctl_set"))) __attribute__((__unused__)) = &sysctl___net_inet_icmp_maskrepl;


static int drop_redirect = 0;
static struct sysctl_oid sysctl___net_inet_icmp_drop_redirect = { &sysctl__net_inet_icmp_children, { 0 }, (-1), 2|((0x80000000|0x40000000)), &drop_redirect, 0, "drop_redirect", sysctl_handle_int, "I", 0, "" }; static void const * const __set_sysctl_set_sym_sysctl___net_inet_icmp_drop_redirect __attribute__((__section__("set_" "sysctl_set"))) __attribute__((__unused__)) = &sysctl___net_inet_icmp_drop_redirect;


static int log_redirect = 0;
static struct sysctl_oid sysctl___net_inet_icmp_log_redirect = { &sysctl__net_inet_icmp_children, { 0 }, (-1), 2|((0x80000000|0x40000000)), &log_redirect, 0, "log_redirect", sysctl_handle_int, "I", 0, "" }; static void const * const __set_sysctl_set_sym_sysctl___net_inet_icmp_log_redirect __attribute__((__section__("set_" "sysctl_set"))) __attribute__((__unused__)) = &sysctl___net_inet_icmp_log_redirect;


static int icmplim = 200;
static struct sysctl_oid sysctl___net_inet_icmp_icmplim = { &sysctl__net_inet_icmp_children, { 0 }, 3, 2|((0x80000000|0x40000000)), &icmplim, 0, "icmplim", sysctl_handle_int, "I", 0, "" }; static void const * const __set_sysctl_set_sym_sysctl___net_inet_icmp_icmplim __attribute__((__section__("set_" "sysctl_set"))) __attribute__((__unused__)) = &sysctl___net_inet_icmp_icmplim;


static int icmplim_output = 1;
static struct sysctl_oid sysctl___net_inet_icmp_icmplim_output = { &sysctl__net_inet_icmp_children, { 0 }, (-1), 2|((0x80000000|0x40000000)), &icmplim_output, 0, "icmplim_output", sysctl_handle_int, "I", 0, "" }; static void const * const __set_sysctl_set_sym_sysctl___net_inet_icmp_icmplim_output __attribute__((__section__("set_" "sysctl_set"))) __attribute__((__unused__)) = &sysctl___net_inet_icmp_icmplim_output;






static int icmpbmcastecho = 0;
static struct sysctl_oid sysctl___net_inet_icmp_bmcastecho = { &sysctl__net_inet_icmp_children, { 0 }, (-1), 2|((0x80000000|0x40000000)), &icmpbmcastecho, 0, "bmcastecho", sysctl_handle_int, "I", 0, "" }; static void const * const __set_sysctl_set_sym_sysctl___net_inet_icmp_bmcastecho __attribute__((__section__("set_" "sysctl_set"))) __attribute__((__unused__)) = &sysctl___net_inet_icmp_bmcastecho;







static void icmp_reflect(struct mbuf *);
static void icmp_send(struct mbuf *, struct mbuf *, struct route *);
static int ip_next_mtu(int, int);

extern struct protosw inetsw[];





void
icmp_error(n, type, code, dest, destifp)
        struct mbuf *n;
        int type, code;
        n_long dest;
        struct ifnet *destifp;
{
        register struct ip *oip = ((struct ip *)((n)->m_hdr.mh_data)), *nip;
        register unsigned oiplen = oip->ip_hl << 2;
        register struct icmp *icp;
        register struct mbuf *m;
        unsigned icmplen;





        if (type != 5)
                icmpstat.icps_error++;





        if (oip->ip_off &~ (0x2000|0x4000))
                goto freeit;
        if (oip->ip_p == 1 && type != 5 &&
          n->m_hdr.mh_len >= oiplen + 8 &&
          !((((struct icmp *)((caddr_t)oip + oiplen))->icmp_type) == 0 || (((struct icmp *)((caddr_t)oip + oiplen))->icmp_type) == 8 || (((struct icmp *)((caddr_t)oip + oiplen))->icmp_type) == 9 || (((struct icmp *)((caddr_t)oip + oiplen))->icmp_type) == 10 || (((struct icmp *)((caddr_t)oip + oiplen))->icmp_type) == 13 || (((struct icmp *)((caddr_t)oip + oiplen))->icmp_type) == 14 || (((struct icmp *)((caddr_t)oip + oiplen))->icmp_type) == 15 || (((struct icmp *)((caddr_t)oip + oiplen))->icmp_type) == 16 || (((struct icmp *)((caddr_t)oip + oiplen))->icmp_type) == 17 || (((struct icmp *)((caddr_t)oip + oiplen))->icmp_type) == 18)) {
                icmpstat.icps_oldicmp++;
                goto freeit;
        }

        if (n->m_hdr.mh_flags & (0x0200|0x0400))
                goto freeit;



        m = m_gethdr(1, 2);
        if (m == 0)
                goto freeit;



        icmplen = min(oiplen + 8, oip->ip_len);
        if (icmplen < sizeof(struct ip))
                panic("icmp_error: bad length");
        m->m_hdr.mh_len = icmplen + 8;
        do { (m)->m_hdr.mh_data += (((256 - sizeof(struct m_hdr)) - sizeof(struct pkthdr)) - (m->m_hdr.mh_len)) & ~(sizeof(long) - 1); } while (0);
        icp = ((struct icmp *)((m)->m_hdr.mh_data));
        if ((u_int)type > 18)
                panic("icmp_error");
        icmpstat.icps_outhist[type]++;
        icp->icmp_type = type;
        if (type == 5)
                icp->icmp_hun.ih_gwaddr.s_addr = dest;
        else {
                icp->icmp_hun.ih_void = 0;




                if (type == 12) {
                        icp->icmp_hun.ih_pptr = code;
                        code = 0;
                } else if (type == 3 &&
                        code == 4 && destifp) {
                        icp->icmp_hun.ih_pmtu.ipm_nextmtu = __bswap16(destifp->if_data.ifi_mtu);
                }
        }

        icp->icmp_code = code;
        m_copydata(n, 0, icmplen, (caddr_t)&icp->icmp_dun.id_ip.idi_ip);
        nip = &icp->icmp_dun.id_ip.idi_ip;




        nip->ip_len = __bswap16(nip->ip_len);
        nip->ip_off = __bswap16(nip->ip_off);





        if (m->m_hdr.mh_data - sizeof(struct ip) < m->M_dat.MH.MH_dat.MH_databuf)
                panic("icmp len");
        m->m_hdr.mh_data -= sizeof(struct ip);
        m->m_hdr.mh_len += sizeof(struct ip);
        m->M_dat.MH.MH_pkthdr.len = m->m_hdr.mh_len;
        m->M_dat.MH.MH_pkthdr.rcvif = n->M_dat.MH.MH_pkthdr.rcvif;
        nip = ((struct ip *)((m)->m_hdr.mh_data));
        bcopy((caddr_t)oip, (caddr_t)nip, sizeof(struct ip));
        nip->ip_len = m->m_hdr.mh_len;
        nip->ip_v = 4;
        nip->ip_hl = 5;
        nip->ip_p = 1;
        nip->ip_tos = 0;
        icmp_reflect(m);

freeit:
        m_freem(n);
}

static struct sockaddr_in icmpsrc = { sizeof (struct sockaddr_in), 2 };
static struct sockaddr_in icmpdst = { sizeof (struct sockaddr_in), 2 };
static struct sockaddr_in icmpgw = { sizeof (struct sockaddr_in), 2 };




void
icmp_input(m, off)
        register struct mbuf *m;
        int off;
{
        int hlen = off;
        register struct icmp *icp;
        register struct ip *ip = ((struct ip *)((m)->m_hdr.mh_data));
        int icmplen = ip->ip_len;
        register int i;
        struct in_ifaddr *ia;
        void (*ctlfunc)(int, struct sockaddr *, void *);
        int code;
# 265 "netinet/ip_icmp.c"
        if (icmplen < 8) {
                icmpstat.icps_tooshort++;
                goto freeit;
        }
        i = hlen + min(icmplen, (8 + sizeof (struct ip) + 8));
        if (m->m_hdr.mh_len < i && (m = m_pullup(m, i)) == 0) {
                icmpstat.icps_tooshort++;
                return;
        }
        ip = ((struct ip *)((m)->m_hdr.mh_data));
        m->m_hdr.mh_len -= hlen;
        m->m_hdr.mh_data += hlen;
        icp = ((struct icmp *)((m)->m_hdr.mh_data));
        if (in_cksum_skip(m, icmplen, 0)) {
                icmpstat.icps_checksum++;
                goto freeit;
        }
        m->m_hdr.mh_len += hlen;
        m->m_hdr.mh_data -= hlen;

        if (m->M_dat.MH.MH_pkthdr.rcvif && m->M_dat.MH.MH_pkthdr.rcvif->if_data.ifi_type == 0xf2) {



                switch (icp->icmp_type) {
                case 3:
                case 11:
                        break;
                default:
                        goto freeit;
                }
        }
# 307 "netinet/ip_icmp.c"
        if (icp->icmp_type > 18)
                goto raw;
        icmpstat.icps_inhist[icp->icmp_type]++;
        code = icp->icmp_code;
        switch (icp->icmp_type) {

        case 3:
                switch (code) {
                        case 0:
                        case 1:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 11:
                        case 12:
                        case 14:
                        case 15:
                                code = 8;
                                break;

                        case 4:
                                code = 5;
                                break;





                        case 2:
                        case 3:
                                code = 11;
                                break;

                        case 9:
                        case 10:
                        case 13:
                                code = 21;
                                break;

                        default:
                                goto badcode;
                }
                goto deliver;

        case 11:
                if (code > 1)
                        goto badcode;
                code += 18;
                goto deliver;

        case 12:
                if (code > 1)
                        goto badcode;
                code = 20;
                goto deliver;

        case 4:
                if (code)
                        goto badcode;
                code = 4;
        deliver:



                if (icmplen < (8 + sizeof (struct ip) + 8) || icmplen < (8 + ((icp)->icmp_dun.id_ip.idi_ip.ip_hl << 2) + 8) ||
                    icp->icmp_dun.id_ip.idi_ip.ip_hl < (sizeof(struct ip) >> 2)) {
                        icmpstat.icps_badlen++;
                        goto freeit;
                }
                icp->icmp_dun.id_ip.idi_ip.ip_len = __bswap16(icp->icmp_dun.id_ip.idi_ip.ip_len);

                if ((((u_int32_t)(__bswap32(icp->icmp_dun.id_ip.idi_ip.ip_dst.s_addr)) & 0xf0000000) == 0xe0000000))
                        goto badcode;




                icmpsrc.sin_addr = icp->icmp_dun.id_ip.idi_ip.ip_dst;
# 401 "netinet/ip_icmp.c"
                if (code == 5) {
                        struct rtentry *rt;
                        int mtu;

                        rt = rtalloc1((struct sockaddr *)&icmpsrc, 0,
                                      0x100 | 0x10000);
                        if (rt && (rt->rt_flags & 0x4)
                            && !(rt->rt_rmx.rmx_locks & 0x1)) {
                                mtu = __bswap16(icp->icmp_hun.ih_pmtu.ipm_nextmtu);
                                if (!mtu)
                                        mtu = ip_next_mtu(rt->rt_rmx.rmx_mtu,
                                                          1);




                                if (mtu < 296) {


                                        rt->rt_rmx.rmx_locks |= 0x1;
                                } else if (rt->rt_rmx.rmx_mtu > mtu) {
                                        rt->rt_rmx.rmx_mtu = mtu;
                                }
                        }
                        if (rt)
                                do { if ((rt)->rt_refcnt <= 1) rtfree(rt); else (rt)->rt_refcnt--; } while (0);
                }






                ctlfunc = inetsw[ip_protox[icp->icmp_dun.id_ip.idi_ip.ip_p]].pr_ctlinput;
                if (ctlfunc)
                        (*ctlfunc)(code, (struct sockaddr *)&icmpsrc,
                                   (void *)&icp->icmp_dun.id_ip.idi_ip);
                break;

        badcode:
                icmpstat.icps_badcode++;
                break;

        case 8:
                if (!icmpbmcastecho
                    && (m->m_hdr.mh_flags & (0x0400 | 0x0200)) != 0) {
                        icmpstat.icps_bmcastecho++;
                        break;
                }
                icp->icmp_type = 0;
                if (badport_bandlim(1) < 0)
                        goto freeit;
                else
                        goto reflect;

        case 13:
                if (!icmpbmcastecho
                    && (m->m_hdr.mh_flags & (0x0400 | 0x0200)) != 0) {
                        icmpstat.icps_bmcasttstamp++;
                        break;
                }
                if (icmplen < (8 + 3 * sizeof (n_time))) {
                        icmpstat.icps_badlen++;
                        break;
                }
                icp->icmp_type = 14;
                icp->icmp_dun.id_ts.its_rtime = iptime();
                icp->icmp_dun.id_ts.its_ttime = icp->icmp_dun.id_ts.its_rtime;
                if (badport_bandlim(2) < 0)
                        goto freeit;
                else
                        goto reflect;

        case 17:
                if (icmpmaskrepl == 0)
                        break;




                if (icmplen < 12)
                        break;
                switch (ip->ip_dst.s_addr) {

                case (u_int32_t)0xffffffff:
                case (u_int32_t)0x00000000:
                        icmpdst.sin_addr = ip->ip_src;
                        break;

                default:
                        icmpdst.sin_addr = ip->ip_dst;
                }
                ia = (struct in_ifaddr *)ifaof_ifpforaddr(
                            (struct sockaddr *)&icmpdst, m->M_dat.MH.MH_pkthdr.rcvif);
                if (ia == 0)
                        break;
                if (ia->ia_ifa.ifa_ifp == 0)
                        break;
                icp->icmp_type = 18;
                icp->icmp_dun.id_mask = ia->ia_sockmask.sin_addr.s_addr;
                if (ip->ip_src.s_addr == 0) {
                        if (ia->ia_ifa.ifa_ifp->if_flags & 0x2)
                            ip->ip_src = ((struct sockaddr_in *)(&ia->ia_dstaddr))->sin_addr;
                        else if (ia->ia_ifa.ifa_ifp->if_flags & 0x10)
                            ip->ip_src = ((struct sockaddr_in *)(&ia->ia_dstaddr))->sin_addr;
                }
reflect:
                ip->ip_len += hlen;
                icmpstat.icps_reflect++;
                icmpstat.icps_outhist[icp->icmp_type]++;
                icmp_reflect(m);
                return;

        case 5:
                if (log_redirect) {
                        u_long src, dst, gw;

                        src = __bswap32(ip->ip_src.s_addr);
                        dst = __bswap32(icp->icmp_dun.id_ip.idi_ip.ip_dst.s_addr);
                        gw = __bswap32(icp->icmp_hun.ih_gwaddr.s_addr);
                        printf("icmp redirect from %d.%d.%d.%d: "
                               "%d.%d.%d.%d => %d.%d.%d.%d\n",
                               (int)(src >> 24), (int)((src >> 16) & 0xff),
                               (int)((src >> 8) & 0xff), (int)(src & 0xff),
                               (int)(dst >> 24), (int)((dst >> 16) & 0xff),
                               (int)((dst >> 8) & 0xff), (int)(dst & 0xff),
                               (int)(gw >> 24), (int)((gw >> 16) & 0xff),
                               (int)((gw >> 8) & 0xff), (int)(gw & 0xff));
                }
                if (drop_redirect)
                        break;
                if (code > 3)
                        goto badcode;
                if (icmplen < (8 + sizeof (struct ip) + 8) || icmplen < (8 + ((icp)->icmp_dun.id_ip.idi_ip.ip_hl << 2) + 8) ||
                    icp->icmp_dun.id_ip.idi_ip.ip_hl < (sizeof(struct ip) >> 2)) {
                        icmpstat.icps_badlen++;
                        break;
                }







                icmpgw.sin_addr = ip->ip_src;
                icmpdst.sin_addr = icp->icmp_hun.ih_gwaddr;
# 557 "netinet/ip_icmp.c"
                icmpsrc.sin_addr = icp->icmp_dun.id_ip.idi_ip.ip_dst;
                rtredirect((struct sockaddr *)&icmpsrc,
                  (struct sockaddr *)&icmpdst,
                  (struct sockaddr *)0, 0x2 | 0x4,
                  (struct sockaddr *)&icmpgw, (struct rtentry **)0);
                pfctlinput(15, (struct sockaddr *)&icmpsrc);



                break;





        case 0:
        case 9:
        case 10:
        case 14:
        case 16:
        case 18:
        default:
                break;
        }

raw:
        rip_input(m, off);
        return;

freeit:
        m_freem(m);
}




static void
icmp_reflect(m)
        struct mbuf *m;
{
        struct ip *ip = ((struct ip *)((m)->m_hdr.mh_data));
        struct ifaddr *ifa;
        struct in_ifaddr *ia;
        struct in_addr t;
        struct mbuf *opts = 0;
        int optlen = (ip->ip_hl << 2) - sizeof(struct ip);
        struct route *ro = 0, rt;

        if (!in_canforward(ip->ip_src) &&
            ((__bswap32(ip->ip_src.s_addr) & 0xff000000) !=
             (127 << 24))) {
                m_freem(m);
                icmpstat.icps_badaddr++;
                goto done;
        }
        t = ip->ip_dst;
        ip->ip_dst = ip->ip_src;
        ro = &rt;
        bzero(ro, sizeof(*ro));






        for ((ia) = ((((&in_ifaddrhashtbl[fnv_32_buf((&(t.s_addr)), sizeof(t.s_addr), ((Fnv32_t) 33554467UL)) & in_ifaddrhmask])))->lh_first); (ia); (ia) = (((ia))->ia_hash.le_next))
                if (t.s_addr == (&(((struct in_ifaddr *)(ia))->ia_addr))->sin_addr.s_addr)
                        goto match;
        if (m->M_dat.MH.MH_pkthdr.rcvif != 0 &&
            m->M_dat.MH.MH_pkthdr.rcvif->if_flags & 0x2) {
                for ((ifa) = (((&m->M_dat.MH.MH_pkthdr.rcvif->if_addrhead))->tqh_first); (ifa); (ifa) = (((ifa))->ifa_link.tqe_next)) {
                        if (ifa->ifa_addr->sa_family != 2)
                                continue;
                        ia = ((struct in_ifaddr *)(ifa));
                        if (((struct sockaddr_in *)(&ia->ia_dstaddr))->sin_addr.s_addr ==
                            t.s_addr)
                                goto match;
                }
        }
        ia = ip_rtaddr(ip->ip_dst, ro);

        if (ia == 0) {
                m_freem(m);
                icmpstat.icps_noroute++;
                goto done;
        }
match:
        t = (&(((struct in_ifaddr *)(ia))->ia_addr))->sin_addr;
        ip->ip_src = t;
        ip->ip_ttl = ip_defttl;

        if (optlen > 0) {
                register u_char *cp;
                int opt, cnt;
                u_int len;





                cp = (u_char *) (ip + 1);
                if ((opts = ip_srcroute()) == 0 &&
                    (opts = m_gethdr(1, 2))) {
                        opts->m_hdr.mh_len = sizeof(struct in_addr);
                        ((struct in_addr *)((opts)->m_hdr.mh_data))->s_addr = 0;
                }
                if (opts) {





                    for (cnt = optlen; cnt > 0; cnt -= len, cp += len) {
                            opt = cp[0];
                            if (opt == 0)
                                    break;
                            if (opt == 1)
                                    len = 1;
                            else {
                                    if (cnt < 1 + sizeof(*cp))
                                            break;
                                    len = cp[1];
                                    if (len < 1 + sizeof(*cp) ||
                                        len > cnt)
                                            break;
                            }



                            if (opt == 7 || opt == 68 ||
                                opt == 130) {
                                    bcopy((caddr_t)cp,
                                        ((caddr_t)((opts)->m_hdr.mh_data)) + opts->m_hdr.mh_len, len);
                                    opts->m_hdr.mh_len += len;
                            }
                    }

                    cnt = opts->m_hdr.mh_len % 4;
                    if (cnt) {
                            for (; cnt < 4; cnt++) {
                                    *(((caddr_t)((opts)->m_hdr.mh_data)) + opts->m_hdr.mh_len) =
                                        0;
                                    opts->m_hdr.mh_len++;
                            }
                    }




                }




                ip->ip_len -= optlen;
                ip->ip_v = 4;
                ip->ip_hl = 5;
                m->m_hdr.mh_len -= optlen;
                if (m->m_hdr.mh_flags & 0x0002)
                        m->M_dat.MH.MH_pkthdr.len -= optlen;
                optlen += sizeof(struct ip);
                bcopy((caddr_t)ip + optlen, (caddr_t)(ip + 1),
                         (unsigned)(m->m_hdr.mh_len - sizeof(struct ip)));
        }
        m->m_hdr.mh_flags &= ~(0x0200|0x0400);
        icmp_send(m, opts, ro);
done:
        if (opts)
                (void)m_free(opts);
        if (ro && ro->ro_rt)
                do { if ((ro->ro_rt)->rt_refcnt <= 1) rtfree(ro->ro_rt); else (ro->ro_rt)->rt_refcnt--; } while (0);
}





static void
icmp_send(m, opts, rt)
        register struct mbuf *m;
        struct mbuf *opts;
        struct route *rt;
{
        register struct ip *ip = ((struct ip *)((m)->m_hdr.mh_data));
        register int hlen;
        register struct icmp *icp;

        hlen = ip->ip_hl << 2;
        m->m_hdr.mh_data += hlen;
        m->m_hdr.mh_len -= hlen;
        icp = ((struct icmp *)((m)->m_hdr.mh_data));
        icp->icmp_cksum = 0;
        icp->icmp_cksum = in_cksum_skip(m, ip->ip_len - hlen, 0);
        m->m_hdr.mh_data -= hlen;
        m->m_hdr.mh_len += hlen;
        m->M_dat.MH.MH_pkthdr.rcvif = (struct ifnet *)0;
# 761 "netinet/ip_icmp.c"
        (void) ip_output(m, opts, rt, 0, 0, 0);
}

n_time
iptime()
{
        struct timeval atv;
        u_long t;

        getmicrotime(&atv);
        t = (atv.tv_sec % (24*60*60)) * 1000 + atv.tv_usec / 1000;
        return (__bswap32(t));
}







static int
ip_next_mtu(mtu, dir)
        int mtu;
        int dir;
{
        static int mtutab[] = {
                65535, 32000, 17914, 8166, 4352, 2002, 1492, 1006, 508, 296,
                68, 0
        };
        int i;

        for (i = 0; i < (sizeof mtutab) / (sizeof mtutab[0]); i++) {
                if (mtu >= mtutab[i])
                        break;
        }

        if (dir < 0) {
                if (i == 0) {
                        return 0;
                } else {
                        return mtutab[i - 1];
                }
        } else {
                if (mtutab[i] == 0) {
                        return 0;
                } else if(mtu > mtutab[i]) {
                        return mtutab[i];
                } else {
                        return mtutab[i + 1];
                }
        }
}
# 835 "netinet/ip_icmp.c"
int
badport_bandlim(int which)
{
        static int lticks[4 + 1];
        static int lpackets[4 + 1];
        int dticks;
        const char *bandlimittype[] = {
                "Limiting icmp unreach response",
                "Limiting icmp ping response",
                "Limiting icmp tstamp response",
                "Limiting closed port RST response",
                "Limiting open port RST response"
                };






        if (icmplim <= 0 || which > 4 || which < 0)
                return(0);
        dticks = ticks - lticks[which];





        if ((unsigned int)dticks > hz) {
                if (lpackets[which] > icmplim && icmplim_output) {
                        printf("%s from %d to %d packets per second\n",
                                bandlimittype[which],
                                lpackets[which],
                                icmplim
                        );
                }
                lticks[which] = ticks;
                lpackets[which] = 0;
        }





        if (++lpackets[which] > icmplim) {
                return(-1);
        }
        return(0);
}
